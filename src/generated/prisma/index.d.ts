
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Mentee
 * 
 */
export type Mentee = $Result.DefaultSelection<Prisma.$MenteePayload>
/**
 * Model Mentor
 * 
 */
export type Mentor = $Result.DefaultSelection<Prisma.$MentorPayload>
/**
 * Model ServiceFocusRef
 * 
 */
export type ServiceFocusRef = $Result.DefaultSelection<Prisma.$ServiceFocusRefPayload>
/**
 * Model LanguageRef
 * 
 */
export type LanguageRef = $Result.DefaultSelection<Prisma.$LanguageRefPayload>
/**
 * Model DisciplineRef
 * 
 */
export type DisciplineRef = $Result.DefaultSelection<Prisma.$DisciplineRefPayload>
/**
 * Model PreferenceRef
 * 
 */
export type PreferenceRef = $Result.DefaultSelection<Prisma.$PreferenceRefPayload>
/**
 * Model MenteeLanguage
 * 
 */
export type MenteeLanguage = $Result.DefaultSelection<Prisma.$MenteeLanguagePayload>
/**
 * Model MenteeInterest
 * 
 */
export type MenteeInterest = $Result.DefaultSelection<Prisma.$MenteeInterestPayload>
/**
 * Model MenteePriority
 * 
 */
export type MenteePriority = $Result.DefaultSelection<Prisma.$MenteePriorityPayload>
/**
 * Model MentorLanguage
 * 
 */
export type MentorLanguage = $Result.DefaultSelection<Prisma.$MentorLanguagePayload>
/**
 * Model MentorCategory
 * 
 */
export type MentorCategory = $Result.DefaultSelection<Prisma.$MentorCategoryPayload>
/**
 * Model MentorSkill
 * 
 */
export type MentorSkill = $Result.DefaultSelection<Prisma.$MentorSkillPayload>
/**
 * Model MenteeServiceFocus
 * 
 */
export type MenteeServiceFocus = $Result.DefaultSelection<Prisma.$MenteeServiceFocusPayload>
/**
 * Model MenteeLanguageRef
 * 
 */
export type MenteeLanguageRef = $Result.DefaultSelection<Prisma.$MenteeLanguageRefPayload>
/**
 * Model MenteeDisciplineRef
 * 
 */
export type MenteeDisciplineRef = $Result.DefaultSelection<Prisma.$MenteeDisciplineRefPayload>
/**
 * Model MenteePreferenceRef
 * 
 */
export type MenteePreferenceRef = $Result.DefaultSelection<Prisma.$MenteePreferenceRefPayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model MentorCompanyMembership
 * 
 */
export type MentorCompanyMembership = $Result.DefaultSelection<Prisma.$MentorCompanyMembershipPayload>
/**
 * Model UserConsent
 * 
 */
export type UserConsent = $Result.DefaultSelection<Prisma.$UserConsentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  mentee: 'mentee',
  mentor: 'mentor',
  admin: 'admin'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const MentorType: {
  individual: 'individual',
  corporate: 'corporate'
};

export type MentorType = (typeof MentorType)[keyof typeof MentorType]


export const MentorStatus: {
  pending_verification: 'pending_verification',
  verified: 'verified',
  suspended: 'suspended'
};

export type MentorStatus = (typeof MentorStatus)[keyof typeof MentorStatus]


export const BudgetRange: {
  LOW_500: 'LOW_500',
  MEDIUM_1000: 'MEDIUM_1000',
  HIGH_PLUS: 'HIGH_PLUS',
  UNDECIDED: 'UNDECIDED'
};

export type BudgetRange = (typeof BudgetRange)[keyof typeof BudgetRange]


export const TimePreference: {
  WEEKDAY_EVENING: 'WEEKDAY_EVENING',
  WEEKEND: 'WEEKEND',
  FLEXIBLE: 'FLEXIBLE',
  WEEKDAYS_DAY: 'WEEKDAYS_DAY'
};

export type TimePreference = (typeof TimePreference)[keyof typeof TimePreference]


export const MeetingPreference: {
  PLATFORM_INTERNAL: 'PLATFORM_INTERNAL',
  ZOOM: 'ZOOM',
  GOOGLE_MEET: 'GOOGLE_MEET',
  FLEXIBLE: 'FLEXIBLE'
};

export type MeetingPreference = (typeof MeetingPreference)[keyof typeof MeetingPreference]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type MentorType = $Enums.MentorType

export const MentorType: typeof $Enums.MentorType

export type MentorStatus = $Enums.MentorStatus

export const MentorStatus: typeof $Enums.MentorStatus

export type BudgetRange = $Enums.BudgetRange

export const BudgetRange: typeof $Enums.BudgetRange

export type TimePreference = $Enums.TimePreference

export const TimePreference: typeof $Enums.TimePreference

export type MeetingPreference = $Enums.MeetingPreference

export const MeetingPreference: typeof $Enums.MeetingPreference

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mentee`: Exposes CRUD operations for the **Mentee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mentees
    * const mentees = await prisma.mentee.findMany()
    * ```
    */
  get mentee(): Prisma.MenteeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mentor`: Exposes CRUD operations for the **Mentor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mentors
    * const mentors = await prisma.mentor.findMany()
    * ```
    */
  get mentor(): Prisma.MentorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceFocusRef`: Exposes CRUD operations for the **ServiceFocusRef** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceFocusRefs
    * const serviceFocusRefs = await prisma.serviceFocusRef.findMany()
    * ```
    */
  get serviceFocusRef(): Prisma.ServiceFocusRefDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.languageRef`: Exposes CRUD operations for the **LanguageRef** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LanguageRefs
    * const languageRefs = await prisma.languageRef.findMany()
    * ```
    */
  get languageRef(): Prisma.LanguageRefDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.disciplineRef`: Exposes CRUD operations for the **DisciplineRef** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DisciplineRefs
    * const disciplineRefs = await prisma.disciplineRef.findMany()
    * ```
    */
  get disciplineRef(): Prisma.DisciplineRefDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.preferenceRef`: Exposes CRUD operations for the **PreferenceRef** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PreferenceRefs
    * const preferenceRefs = await prisma.preferenceRef.findMany()
    * ```
    */
  get preferenceRef(): Prisma.PreferenceRefDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.menteeLanguage`: Exposes CRUD operations for the **MenteeLanguage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MenteeLanguages
    * const menteeLanguages = await prisma.menteeLanguage.findMany()
    * ```
    */
  get menteeLanguage(): Prisma.MenteeLanguageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.menteeInterest`: Exposes CRUD operations for the **MenteeInterest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MenteeInterests
    * const menteeInterests = await prisma.menteeInterest.findMany()
    * ```
    */
  get menteeInterest(): Prisma.MenteeInterestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.menteePriority`: Exposes CRUD operations for the **MenteePriority** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MenteePriorities
    * const menteePriorities = await prisma.menteePriority.findMany()
    * ```
    */
  get menteePriority(): Prisma.MenteePriorityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mentorLanguage`: Exposes CRUD operations for the **MentorLanguage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MentorLanguages
    * const mentorLanguages = await prisma.mentorLanguage.findMany()
    * ```
    */
  get mentorLanguage(): Prisma.MentorLanguageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mentorCategory`: Exposes CRUD operations for the **MentorCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MentorCategories
    * const mentorCategories = await prisma.mentorCategory.findMany()
    * ```
    */
  get mentorCategory(): Prisma.MentorCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mentorSkill`: Exposes CRUD operations for the **MentorSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MentorSkills
    * const mentorSkills = await prisma.mentorSkill.findMany()
    * ```
    */
  get mentorSkill(): Prisma.MentorSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.menteeServiceFocus`: Exposes CRUD operations for the **MenteeServiceFocus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MenteeServiceFoci
    * const menteeServiceFoci = await prisma.menteeServiceFocus.findMany()
    * ```
    */
  get menteeServiceFocus(): Prisma.MenteeServiceFocusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.menteeLanguageRef`: Exposes CRUD operations for the **MenteeLanguageRef** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MenteeLanguageRefs
    * const menteeLanguageRefs = await prisma.menteeLanguageRef.findMany()
    * ```
    */
  get menteeLanguageRef(): Prisma.MenteeLanguageRefDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.menteeDisciplineRef`: Exposes CRUD operations for the **MenteeDisciplineRef** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MenteeDisciplineRefs
    * const menteeDisciplineRefs = await prisma.menteeDisciplineRef.findMany()
    * ```
    */
  get menteeDisciplineRef(): Prisma.MenteeDisciplineRefDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.menteePreferenceRef`: Exposes CRUD operations for the **MenteePreferenceRef** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MenteePreferenceRefs
    * const menteePreferenceRefs = await prisma.menteePreferenceRef.findMany()
    * ```
    */
  get menteePreferenceRef(): Prisma.MenteePreferenceRefDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mentorCompanyMembership`: Exposes CRUD operations for the **MentorCompanyMembership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MentorCompanyMemberships
    * const mentorCompanyMemberships = await prisma.mentorCompanyMembership.findMany()
    * ```
    */
  get mentorCompanyMembership(): Prisma.MentorCompanyMembershipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userConsent`: Exposes CRUD operations for the **UserConsent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserConsents
    * const userConsents = await prisma.userConsent.findMany()
    * ```
    */
  get userConsent(): Prisma.UserConsentDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Mentee: 'Mentee',
    Mentor: 'Mentor',
    ServiceFocusRef: 'ServiceFocusRef',
    LanguageRef: 'LanguageRef',
    DisciplineRef: 'DisciplineRef',
    PreferenceRef: 'PreferenceRef',
    MenteeLanguage: 'MenteeLanguage',
    MenteeInterest: 'MenteeInterest',
    MenteePriority: 'MenteePriority',
    MentorLanguage: 'MentorLanguage',
    MentorCategory: 'MentorCategory',
    MentorSkill: 'MentorSkill',
    MenteeServiceFocus: 'MenteeServiceFocus',
    MenteeLanguageRef: 'MenteeLanguageRef',
    MenteeDisciplineRef: 'MenteeDisciplineRef',
    MenteePreferenceRef: 'MenteePreferenceRef',
    Company: 'Company',
    MentorCompanyMembership: 'MentorCompanyMembership',
    UserConsent: 'UserConsent'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "mentee" | "mentor" | "serviceFocusRef" | "languageRef" | "disciplineRef" | "preferenceRef" | "menteeLanguage" | "menteeInterest" | "menteePriority" | "mentorLanguage" | "mentorCategory" | "mentorSkill" | "menteeServiceFocus" | "menteeLanguageRef" | "menteeDisciplineRef" | "menteePreferenceRef" | "company" | "mentorCompanyMembership" | "userConsent"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Mentee: {
        payload: Prisma.$MenteePayload<ExtArgs>
        fields: Prisma.MenteeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenteeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenteeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePayload>
          }
          findFirst: {
            args: Prisma.MenteeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenteeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePayload>
          }
          findMany: {
            args: Prisma.MenteeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePayload>[]
          }
          create: {
            args: Prisma.MenteeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePayload>
          }
          createMany: {
            args: Prisma.MenteeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenteeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePayload>[]
          }
          delete: {
            args: Prisma.MenteeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePayload>
          }
          update: {
            args: Prisma.MenteeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePayload>
          }
          deleteMany: {
            args: Prisma.MenteeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenteeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MenteeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePayload>[]
          }
          upsert: {
            args: Prisma.MenteeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePayload>
          }
          aggregate: {
            args: Prisma.MenteeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMentee>
          }
          groupBy: {
            args: Prisma.MenteeGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenteeGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenteeCountArgs<ExtArgs>
            result: $Utils.Optional<MenteeCountAggregateOutputType> | number
          }
        }
      }
      Mentor: {
        payload: Prisma.$MentorPayload<ExtArgs>
        fields: Prisma.MentorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MentorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MentorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayload>
          }
          findFirst: {
            args: Prisma.MentorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MentorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayload>
          }
          findMany: {
            args: Prisma.MentorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayload>[]
          }
          create: {
            args: Prisma.MentorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayload>
          }
          createMany: {
            args: Prisma.MentorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MentorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayload>[]
          }
          delete: {
            args: Prisma.MentorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayload>
          }
          update: {
            args: Prisma.MentorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayload>
          }
          deleteMany: {
            args: Prisma.MentorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MentorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MentorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayload>[]
          }
          upsert: {
            args: Prisma.MentorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayload>
          }
          aggregate: {
            args: Prisma.MentorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMentor>
          }
          groupBy: {
            args: Prisma.MentorGroupByArgs<ExtArgs>
            result: $Utils.Optional<MentorGroupByOutputType>[]
          }
          count: {
            args: Prisma.MentorCountArgs<ExtArgs>
            result: $Utils.Optional<MentorCountAggregateOutputType> | number
          }
        }
      }
      ServiceFocusRef: {
        payload: Prisma.$ServiceFocusRefPayload<ExtArgs>
        fields: Prisma.ServiceFocusRefFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFocusRefFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFocusRefPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFocusRefFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFocusRefPayload>
          }
          findFirst: {
            args: Prisma.ServiceFocusRefFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFocusRefPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFocusRefFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFocusRefPayload>
          }
          findMany: {
            args: Prisma.ServiceFocusRefFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFocusRefPayload>[]
          }
          create: {
            args: Prisma.ServiceFocusRefCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFocusRefPayload>
          }
          createMany: {
            args: Prisma.ServiceFocusRefCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceFocusRefCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFocusRefPayload>[]
          }
          delete: {
            args: Prisma.ServiceFocusRefDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFocusRefPayload>
          }
          update: {
            args: Prisma.ServiceFocusRefUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFocusRefPayload>
          }
          deleteMany: {
            args: Prisma.ServiceFocusRefDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceFocusRefUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceFocusRefUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFocusRefPayload>[]
          }
          upsert: {
            args: Prisma.ServiceFocusRefUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFocusRefPayload>
          }
          aggregate: {
            args: Prisma.ServiceFocusRefAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceFocusRef>
          }
          groupBy: {
            args: Prisma.ServiceFocusRefGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceFocusRefGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceFocusRefCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceFocusRefCountAggregateOutputType> | number
          }
        }
      }
      LanguageRef: {
        payload: Prisma.$LanguageRefPayload<ExtArgs>
        fields: Prisma.LanguageRefFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LanguageRefFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageRefPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LanguageRefFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageRefPayload>
          }
          findFirst: {
            args: Prisma.LanguageRefFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageRefPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LanguageRefFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageRefPayload>
          }
          findMany: {
            args: Prisma.LanguageRefFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageRefPayload>[]
          }
          create: {
            args: Prisma.LanguageRefCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageRefPayload>
          }
          createMany: {
            args: Prisma.LanguageRefCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LanguageRefCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageRefPayload>[]
          }
          delete: {
            args: Prisma.LanguageRefDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageRefPayload>
          }
          update: {
            args: Prisma.LanguageRefUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageRefPayload>
          }
          deleteMany: {
            args: Prisma.LanguageRefDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LanguageRefUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LanguageRefUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageRefPayload>[]
          }
          upsert: {
            args: Prisma.LanguageRefUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageRefPayload>
          }
          aggregate: {
            args: Prisma.LanguageRefAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLanguageRef>
          }
          groupBy: {
            args: Prisma.LanguageRefGroupByArgs<ExtArgs>
            result: $Utils.Optional<LanguageRefGroupByOutputType>[]
          }
          count: {
            args: Prisma.LanguageRefCountArgs<ExtArgs>
            result: $Utils.Optional<LanguageRefCountAggregateOutputType> | number
          }
        }
      }
      DisciplineRef: {
        payload: Prisma.$DisciplineRefPayload<ExtArgs>
        fields: Prisma.DisciplineRefFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DisciplineRefFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplineRefPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DisciplineRefFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplineRefPayload>
          }
          findFirst: {
            args: Prisma.DisciplineRefFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplineRefPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DisciplineRefFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplineRefPayload>
          }
          findMany: {
            args: Prisma.DisciplineRefFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplineRefPayload>[]
          }
          create: {
            args: Prisma.DisciplineRefCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplineRefPayload>
          }
          createMany: {
            args: Prisma.DisciplineRefCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DisciplineRefCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplineRefPayload>[]
          }
          delete: {
            args: Prisma.DisciplineRefDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplineRefPayload>
          }
          update: {
            args: Prisma.DisciplineRefUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplineRefPayload>
          }
          deleteMany: {
            args: Prisma.DisciplineRefDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DisciplineRefUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DisciplineRefUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplineRefPayload>[]
          }
          upsert: {
            args: Prisma.DisciplineRefUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplineRefPayload>
          }
          aggregate: {
            args: Prisma.DisciplineRefAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDisciplineRef>
          }
          groupBy: {
            args: Prisma.DisciplineRefGroupByArgs<ExtArgs>
            result: $Utils.Optional<DisciplineRefGroupByOutputType>[]
          }
          count: {
            args: Prisma.DisciplineRefCountArgs<ExtArgs>
            result: $Utils.Optional<DisciplineRefCountAggregateOutputType> | number
          }
        }
      }
      PreferenceRef: {
        payload: Prisma.$PreferenceRefPayload<ExtArgs>
        fields: Prisma.PreferenceRefFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PreferenceRefFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreferenceRefPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PreferenceRefFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreferenceRefPayload>
          }
          findFirst: {
            args: Prisma.PreferenceRefFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreferenceRefPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PreferenceRefFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreferenceRefPayload>
          }
          findMany: {
            args: Prisma.PreferenceRefFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreferenceRefPayload>[]
          }
          create: {
            args: Prisma.PreferenceRefCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreferenceRefPayload>
          }
          createMany: {
            args: Prisma.PreferenceRefCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PreferenceRefCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreferenceRefPayload>[]
          }
          delete: {
            args: Prisma.PreferenceRefDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreferenceRefPayload>
          }
          update: {
            args: Prisma.PreferenceRefUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreferenceRefPayload>
          }
          deleteMany: {
            args: Prisma.PreferenceRefDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PreferenceRefUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PreferenceRefUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreferenceRefPayload>[]
          }
          upsert: {
            args: Prisma.PreferenceRefUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreferenceRefPayload>
          }
          aggregate: {
            args: Prisma.PreferenceRefAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePreferenceRef>
          }
          groupBy: {
            args: Prisma.PreferenceRefGroupByArgs<ExtArgs>
            result: $Utils.Optional<PreferenceRefGroupByOutputType>[]
          }
          count: {
            args: Prisma.PreferenceRefCountArgs<ExtArgs>
            result: $Utils.Optional<PreferenceRefCountAggregateOutputType> | number
          }
        }
      }
      MenteeLanguage: {
        payload: Prisma.$MenteeLanguagePayload<ExtArgs>
        fields: Prisma.MenteeLanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenteeLanguageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeLanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenteeLanguageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeLanguagePayload>
          }
          findFirst: {
            args: Prisma.MenteeLanguageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeLanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenteeLanguageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeLanguagePayload>
          }
          findMany: {
            args: Prisma.MenteeLanguageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeLanguagePayload>[]
          }
          create: {
            args: Prisma.MenteeLanguageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeLanguagePayload>
          }
          createMany: {
            args: Prisma.MenteeLanguageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenteeLanguageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeLanguagePayload>[]
          }
          delete: {
            args: Prisma.MenteeLanguageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeLanguagePayload>
          }
          update: {
            args: Prisma.MenteeLanguageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeLanguagePayload>
          }
          deleteMany: {
            args: Prisma.MenteeLanguageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenteeLanguageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MenteeLanguageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeLanguagePayload>[]
          }
          upsert: {
            args: Prisma.MenteeLanguageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeLanguagePayload>
          }
          aggregate: {
            args: Prisma.MenteeLanguageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenteeLanguage>
          }
          groupBy: {
            args: Prisma.MenteeLanguageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenteeLanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenteeLanguageCountArgs<ExtArgs>
            result: $Utils.Optional<MenteeLanguageCountAggregateOutputType> | number
          }
        }
      }
      MenteeInterest: {
        payload: Prisma.$MenteeInterestPayload<ExtArgs>
        fields: Prisma.MenteeInterestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenteeInterestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeInterestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenteeInterestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeInterestPayload>
          }
          findFirst: {
            args: Prisma.MenteeInterestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeInterestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenteeInterestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeInterestPayload>
          }
          findMany: {
            args: Prisma.MenteeInterestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeInterestPayload>[]
          }
          create: {
            args: Prisma.MenteeInterestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeInterestPayload>
          }
          createMany: {
            args: Prisma.MenteeInterestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenteeInterestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeInterestPayload>[]
          }
          delete: {
            args: Prisma.MenteeInterestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeInterestPayload>
          }
          update: {
            args: Prisma.MenteeInterestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeInterestPayload>
          }
          deleteMany: {
            args: Prisma.MenteeInterestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenteeInterestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MenteeInterestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeInterestPayload>[]
          }
          upsert: {
            args: Prisma.MenteeInterestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeInterestPayload>
          }
          aggregate: {
            args: Prisma.MenteeInterestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenteeInterest>
          }
          groupBy: {
            args: Prisma.MenteeInterestGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenteeInterestGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenteeInterestCountArgs<ExtArgs>
            result: $Utils.Optional<MenteeInterestCountAggregateOutputType> | number
          }
        }
      }
      MenteePriority: {
        payload: Prisma.$MenteePriorityPayload<ExtArgs>
        fields: Prisma.MenteePriorityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenteePriorityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePriorityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenteePriorityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePriorityPayload>
          }
          findFirst: {
            args: Prisma.MenteePriorityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePriorityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenteePriorityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePriorityPayload>
          }
          findMany: {
            args: Prisma.MenteePriorityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePriorityPayload>[]
          }
          create: {
            args: Prisma.MenteePriorityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePriorityPayload>
          }
          createMany: {
            args: Prisma.MenteePriorityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenteePriorityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePriorityPayload>[]
          }
          delete: {
            args: Prisma.MenteePriorityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePriorityPayload>
          }
          update: {
            args: Prisma.MenteePriorityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePriorityPayload>
          }
          deleteMany: {
            args: Prisma.MenteePriorityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenteePriorityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MenteePriorityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePriorityPayload>[]
          }
          upsert: {
            args: Prisma.MenteePriorityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePriorityPayload>
          }
          aggregate: {
            args: Prisma.MenteePriorityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenteePriority>
          }
          groupBy: {
            args: Prisma.MenteePriorityGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenteePriorityGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenteePriorityCountArgs<ExtArgs>
            result: $Utils.Optional<MenteePriorityCountAggregateOutputType> | number
          }
        }
      }
      MentorLanguage: {
        payload: Prisma.$MentorLanguagePayload<ExtArgs>
        fields: Prisma.MentorLanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MentorLanguageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorLanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MentorLanguageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorLanguagePayload>
          }
          findFirst: {
            args: Prisma.MentorLanguageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorLanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MentorLanguageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorLanguagePayload>
          }
          findMany: {
            args: Prisma.MentorLanguageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorLanguagePayload>[]
          }
          create: {
            args: Prisma.MentorLanguageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorLanguagePayload>
          }
          createMany: {
            args: Prisma.MentorLanguageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MentorLanguageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorLanguagePayload>[]
          }
          delete: {
            args: Prisma.MentorLanguageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorLanguagePayload>
          }
          update: {
            args: Prisma.MentorLanguageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorLanguagePayload>
          }
          deleteMany: {
            args: Prisma.MentorLanguageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MentorLanguageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MentorLanguageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorLanguagePayload>[]
          }
          upsert: {
            args: Prisma.MentorLanguageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorLanguagePayload>
          }
          aggregate: {
            args: Prisma.MentorLanguageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMentorLanguage>
          }
          groupBy: {
            args: Prisma.MentorLanguageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MentorLanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MentorLanguageCountArgs<ExtArgs>
            result: $Utils.Optional<MentorLanguageCountAggregateOutputType> | number
          }
        }
      }
      MentorCategory: {
        payload: Prisma.$MentorCategoryPayload<ExtArgs>
        fields: Prisma.MentorCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MentorCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MentorCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorCategoryPayload>
          }
          findFirst: {
            args: Prisma.MentorCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MentorCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorCategoryPayload>
          }
          findMany: {
            args: Prisma.MentorCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorCategoryPayload>[]
          }
          create: {
            args: Prisma.MentorCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorCategoryPayload>
          }
          createMany: {
            args: Prisma.MentorCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MentorCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorCategoryPayload>[]
          }
          delete: {
            args: Prisma.MentorCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorCategoryPayload>
          }
          update: {
            args: Prisma.MentorCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorCategoryPayload>
          }
          deleteMany: {
            args: Prisma.MentorCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MentorCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MentorCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorCategoryPayload>[]
          }
          upsert: {
            args: Prisma.MentorCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorCategoryPayload>
          }
          aggregate: {
            args: Prisma.MentorCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMentorCategory>
          }
          groupBy: {
            args: Prisma.MentorCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<MentorCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.MentorCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<MentorCategoryCountAggregateOutputType> | number
          }
        }
      }
      MentorSkill: {
        payload: Prisma.$MentorSkillPayload<ExtArgs>
        fields: Prisma.MentorSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MentorSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MentorSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorSkillPayload>
          }
          findFirst: {
            args: Prisma.MentorSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MentorSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorSkillPayload>
          }
          findMany: {
            args: Prisma.MentorSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorSkillPayload>[]
          }
          create: {
            args: Prisma.MentorSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorSkillPayload>
          }
          createMany: {
            args: Prisma.MentorSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MentorSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorSkillPayload>[]
          }
          delete: {
            args: Prisma.MentorSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorSkillPayload>
          }
          update: {
            args: Prisma.MentorSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorSkillPayload>
          }
          deleteMany: {
            args: Prisma.MentorSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MentorSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MentorSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorSkillPayload>[]
          }
          upsert: {
            args: Prisma.MentorSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorSkillPayload>
          }
          aggregate: {
            args: Prisma.MentorSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMentorSkill>
          }
          groupBy: {
            args: Prisma.MentorSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<MentorSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.MentorSkillCountArgs<ExtArgs>
            result: $Utils.Optional<MentorSkillCountAggregateOutputType> | number
          }
        }
      }
      MenteeServiceFocus: {
        payload: Prisma.$MenteeServiceFocusPayload<ExtArgs>
        fields: Prisma.MenteeServiceFocusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenteeServiceFocusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeServiceFocusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenteeServiceFocusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeServiceFocusPayload>
          }
          findFirst: {
            args: Prisma.MenteeServiceFocusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeServiceFocusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenteeServiceFocusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeServiceFocusPayload>
          }
          findMany: {
            args: Prisma.MenteeServiceFocusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeServiceFocusPayload>[]
          }
          create: {
            args: Prisma.MenteeServiceFocusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeServiceFocusPayload>
          }
          createMany: {
            args: Prisma.MenteeServiceFocusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenteeServiceFocusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeServiceFocusPayload>[]
          }
          delete: {
            args: Prisma.MenteeServiceFocusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeServiceFocusPayload>
          }
          update: {
            args: Prisma.MenteeServiceFocusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeServiceFocusPayload>
          }
          deleteMany: {
            args: Prisma.MenteeServiceFocusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenteeServiceFocusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MenteeServiceFocusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeServiceFocusPayload>[]
          }
          upsert: {
            args: Prisma.MenteeServiceFocusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeServiceFocusPayload>
          }
          aggregate: {
            args: Prisma.MenteeServiceFocusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenteeServiceFocus>
          }
          groupBy: {
            args: Prisma.MenteeServiceFocusGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenteeServiceFocusGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenteeServiceFocusCountArgs<ExtArgs>
            result: $Utils.Optional<MenteeServiceFocusCountAggregateOutputType> | number
          }
        }
      }
      MenteeLanguageRef: {
        payload: Prisma.$MenteeLanguageRefPayload<ExtArgs>
        fields: Prisma.MenteeLanguageRefFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenteeLanguageRefFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeLanguageRefPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenteeLanguageRefFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeLanguageRefPayload>
          }
          findFirst: {
            args: Prisma.MenteeLanguageRefFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeLanguageRefPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenteeLanguageRefFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeLanguageRefPayload>
          }
          findMany: {
            args: Prisma.MenteeLanguageRefFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeLanguageRefPayload>[]
          }
          create: {
            args: Prisma.MenteeLanguageRefCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeLanguageRefPayload>
          }
          createMany: {
            args: Prisma.MenteeLanguageRefCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenteeLanguageRefCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeLanguageRefPayload>[]
          }
          delete: {
            args: Prisma.MenteeLanguageRefDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeLanguageRefPayload>
          }
          update: {
            args: Prisma.MenteeLanguageRefUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeLanguageRefPayload>
          }
          deleteMany: {
            args: Prisma.MenteeLanguageRefDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenteeLanguageRefUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MenteeLanguageRefUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeLanguageRefPayload>[]
          }
          upsert: {
            args: Prisma.MenteeLanguageRefUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeLanguageRefPayload>
          }
          aggregate: {
            args: Prisma.MenteeLanguageRefAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenteeLanguageRef>
          }
          groupBy: {
            args: Prisma.MenteeLanguageRefGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenteeLanguageRefGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenteeLanguageRefCountArgs<ExtArgs>
            result: $Utils.Optional<MenteeLanguageRefCountAggregateOutputType> | number
          }
        }
      }
      MenteeDisciplineRef: {
        payload: Prisma.$MenteeDisciplineRefPayload<ExtArgs>
        fields: Prisma.MenteeDisciplineRefFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenteeDisciplineRefFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeDisciplineRefPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenteeDisciplineRefFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeDisciplineRefPayload>
          }
          findFirst: {
            args: Prisma.MenteeDisciplineRefFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeDisciplineRefPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenteeDisciplineRefFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeDisciplineRefPayload>
          }
          findMany: {
            args: Prisma.MenteeDisciplineRefFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeDisciplineRefPayload>[]
          }
          create: {
            args: Prisma.MenteeDisciplineRefCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeDisciplineRefPayload>
          }
          createMany: {
            args: Prisma.MenteeDisciplineRefCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenteeDisciplineRefCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeDisciplineRefPayload>[]
          }
          delete: {
            args: Prisma.MenteeDisciplineRefDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeDisciplineRefPayload>
          }
          update: {
            args: Prisma.MenteeDisciplineRefUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeDisciplineRefPayload>
          }
          deleteMany: {
            args: Prisma.MenteeDisciplineRefDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenteeDisciplineRefUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MenteeDisciplineRefUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeDisciplineRefPayload>[]
          }
          upsert: {
            args: Prisma.MenteeDisciplineRefUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteeDisciplineRefPayload>
          }
          aggregate: {
            args: Prisma.MenteeDisciplineRefAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenteeDisciplineRef>
          }
          groupBy: {
            args: Prisma.MenteeDisciplineRefGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenteeDisciplineRefGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenteeDisciplineRefCountArgs<ExtArgs>
            result: $Utils.Optional<MenteeDisciplineRefCountAggregateOutputType> | number
          }
        }
      }
      MenteePreferenceRef: {
        payload: Prisma.$MenteePreferenceRefPayload<ExtArgs>
        fields: Prisma.MenteePreferenceRefFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenteePreferenceRefFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePreferenceRefPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenteePreferenceRefFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePreferenceRefPayload>
          }
          findFirst: {
            args: Prisma.MenteePreferenceRefFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePreferenceRefPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenteePreferenceRefFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePreferenceRefPayload>
          }
          findMany: {
            args: Prisma.MenteePreferenceRefFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePreferenceRefPayload>[]
          }
          create: {
            args: Prisma.MenteePreferenceRefCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePreferenceRefPayload>
          }
          createMany: {
            args: Prisma.MenteePreferenceRefCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenteePreferenceRefCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePreferenceRefPayload>[]
          }
          delete: {
            args: Prisma.MenteePreferenceRefDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePreferenceRefPayload>
          }
          update: {
            args: Prisma.MenteePreferenceRefUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePreferenceRefPayload>
          }
          deleteMany: {
            args: Prisma.MenteePreferenceRefDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenteePreferenceRefUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MenteePreferenceRefUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePreferenceRefPayload>[]
          }
          upsert: {
            args: Prisma.MenteePreferenceRefUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenteePreferenceRefPayload>
          }
          aggregate: {
            args: Prisma.MenteePreferenceRefAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenteePreferenceRef>
          }
          groupBy: {
            args: Prisma.MenteePreferenceRefGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenteePreferenceRefGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenteePreferenceRefCountArgs<ExtArgs>
            result: $Utils.Optional<MenteePreferenceRefCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      MentorCompanyMembership: {
        payload: Prisma.$MentorCompanyMembershipPayload<ExtArgs>
        fields: Prisma.MentorCompanyMembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MentorCompanyMembershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorCompanyMembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MentorCompanyMembershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorCompanyMembershipPayload>
          }
          findFirst: {
            args: Prisma.MentorCompanyMembershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorCompanyMembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MentorCompanyMembershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorCompanyMembershipPayload>
          }
          findMany: {
            args: Prisma.MentorCompanyMembershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorCompanyMembershipPayload>[]
          }
          create: {
            args: Prisma.MentorCompanyMembershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorCompanyMembershipPayload>
          }
          createMany: {
            args: Prisma.MentorCompanyMembershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MentorCompanyMembershipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorCompanyMembershipPayload>[]
          }
          delete: {
            args: Prisma.MentorCompanyMembershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorCompanyMembershipPayload>
          }
          update: {
            args: Prisma.MentorCompanyMembershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorCompanyMembershipPayload>
          }
          deleteMany: {
            args: Prisma.MentorCompanyMembershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MentorCompanyMembershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MentorCompanyMembershipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorCompanyMembershipPayload>[]
          }
          upsert: {
            args: Prisma.MentorCompanyMembershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorCompanyMembershipPayload>
          }
          aggregate: {
            args: Prisma.MentorCompanyMembershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMentorCompanyMembership>
          }
          groupBy: {
            args: Prisma.MentorCompanyMembershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<MentorCompanyMembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.MentorCompanyMembershipCountArgs<ExtArgs>
            result: $Utils.Optional<MentorCompanyMembershipCountAggregateOutputType> | number
          }
        }
      }
      UserConsent: {
        payload: Prisma.$UserConsentPayload<ExtArgs>
        fields: Prisma.UserConsentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserConsentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserConsentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          findFirst: {
            args: Prisma.UserConsentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserConsentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          findMany: {
            args: Prisma.UserConsentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>[]
          }
          create: {
            args: Prisma.UserConsentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          createMany: {
            args: Prisma.UserConsentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserConsentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>[]
          }
          delete: {
            args: Prisma.UserConsentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          update: {
            args: Prisma.UserConsentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          deleteMany: {
            args: Prisma.UserConsentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserConsentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserConsentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>[]
          }
          upsert: {
            args: Prisma.UserConsentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          aggregate: {
            args: Prisma.UserConsentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserConsent>
          }
          groupBy: {
            args: Prisma.UserConsentGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserConsentGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserConsentCountArgs<ExtArgs>
            result: $Utils.Optional<UserConsentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    mentee?: MenteeOmit
    mentor?: MentorOmit
    serviceFocusRef?: ServiceFocusRefOmit
    languageRef?: LanguageRefOmit
    disciplineRef?: DisciplineRefOmit
    preferenceRef?: PreferenceRefOmit
    menteeLanguage?: MenteeLanguageOmit
    menteeInterest?: MenteeInterestOmit
    menteePriority?: MenteePriorityOmit
    mentorLanguage?: MentorLanguageOmit
    mentorCategory?: MentorCategoryOmit
    mentorSkill?: MentorSkillOmit
    menteeServiceFocus?: MenteeServiceFocusOmit
    menteeLanguageRef?: MenteeLanguageRefOmit
    menteeDisciplineRef?: MenteeDisciplineRefOmit
    menteePreferenceRef?: MenteePreferenceRefOmit
    company?: CompanyOmit
    mentorCompanyMembership?: MentorCompanyMembershipOmit
    userConsent?: UserConsentOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    mentee_languages: number
    mentee_interests: number
    mentee_priorities: number
    mentor_languages: number
    mentor_categories: number
    mentor_skills: number
    mentee_service_focus: number
    mentee_languages_ref: number
    mentee_disciplines_ref: number
    mentee_preferences_ref: number
    mentor_company_membership: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentee_languages?: boolean | UserCountOutputTypeCountMentee_languagesArgs
    mentee_interests?: boolean | UserCountOutputTypeCountMentee_interestsArgs
    mentee_priorities?: boolean | UserCountOutputTypeCountMentee_prioritiesArgs
    mentor_languages?: boolean | UserCountOutputTypeCountMentor_languagesArgs
    mentor_categories?: boolean | UserCountOutputTypeCountMentor_categoriesArgs
    mentor_skills?: boolean | UserCountOutputTypeCountMentor_skillsArgs
    mentee_service_focus?: boolean | UserCountOutputTypeCountMentee_service_focusArgs
    mentee_languages_ref?: boolean | UserCountOutputTypeCountMentee_languages_refArgs
    mentee_disciplines_ref?: boolean | UserCountOutputTypeCountMentee_disciplines_refArgs
    mentee_preferences_ref?: boolean | UserCountOutputTypeCountMentee_preferences_refArgs
    mentor_company_membership?: boolean | UserCountOutputTypeCountMentor_company_membershipArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMentee_languagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenteeLanguageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMentee_interestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenteeInterestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMentee_prioritiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenteePriorityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMentor_languagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorLanguageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMentor_categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorCategoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMentor_skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorSkillWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMentee_service_focusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenteeServiceFocusWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMentee_languages_refArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenteeLanguageRefWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMentee_disciplines_refArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenteeDisciplineRefWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMentee_preferences_refArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenteePreferenceRefWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMentor_company_membershipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorCompanyMembershipWhereInput
  }


  /**
   * Count Type ServiceFocusRefCountOutputType
   */

  export type ServiceFocusRefCountOutputType = {
    mentee_service_focus: number
  }

  export type ServiceFocusRefCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentee_service_focus?: boolean | ServiceFocusRefCountOutputTypeCountMentee_service_focusArgs
  }

  // Custom InputTypes
  /**
   * ServiceFocusRefCountOutputType without action
   */
  export type ServiceFocusRefCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceFocusRefCountOutputType
     */
    select?: ServiceFocusRefCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceFocusRefCountOutputType without action
   */
  export type ServiceFocusRefCountOutputTypeCountMentee_service_focusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenteeServiceFocusWhereInput
  }


  /**
   * Count Type LanguageRefCountOutputType
   */

  export type LanguageRefCountOutputType = {
    mentee_languages_ref: number
  }

  export type LanguageRefCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentee_languages_ref?: boolean | LanguageRefCountOutputTypeCountMentee_languages_refArgs
  }

  // Custom InputTypes
  /**
   * LanguageRefCountOutputType without action
   */
  export type LanguageRefCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageRefCountOutputType
     */
    select?: LanguageRefCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LanguageRefCountOutputType without action
   */
  export type LanguageRefCountOutputTypeCountMentee_languages_refArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenteeLanguageRefWhereInput
  }


  /**
   * Count Type DisciplineRefCountOutputType
   */

  export type DisciplineRefCountOutputType = {
    mentee_disciplines_ref: number
  }

  export type DisciplineRefCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentee_disciplines_ref?: boolean | DisciplineRefCountOutputTypeCountMentee_disciplines_refArgs
  }

  // Custom InputTypes
  /**
   * DisciplineRefCountOutputType without action
   */
  export type DisciplineRefCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplineRefCountOutputType
     */
    select?: DisciplineRefCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DisciplineRefCountOutputType without action
   */
  export type DisciplineRefCountOutputTypeCountMentee_disciplines_refArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenteeDisciplineRefWhereInput
  }


  /**
   * Count Type PreferenceRefCountOutputType
   */

  export type PreferenceRefCountOutputType = {
    mentee_preferences_ref: number
  }

  export type PreferenceRefCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentee_preferences_ref?: boolean | PreferenceRefCountOutputTypeCountMentee_preferences_refArgs
  }

  // Custom InputTypes
  /**
   * PreferenceRefCountOutputType without action
   */
  export type PreferenceRefCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferenceRefCountOutputType
     */
    select?: PreferenceRefCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PreferenceRefCountOutputType without action
   */
  export type PreferenceRefCountOutputTypeCountMentee_preferences_refArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenteePreferenceRefWhereInput
  }


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    mentor_company_membership: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentor_company_membership?: boolean | CompanyCountOutputTypeCountMentor_company_membershipArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountMentor_company_membershipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorCompanyMembershipWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    full_name: string | null
    role: $Enums.UserRole | null
    password_hash: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    full_name: string | null
    role: $Enums.UserRole | null
    password_hash: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    full_name: number
    role: number
    password_hash: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    full_name?: true
    role?: true
    password_hash?: true
    created_at?: true
    updated_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    full_name?: true
    role?: true
    password_hash?: true
    created_at?: true
    updated_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    full_name?: true
    role?: true
    password_hash?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at: Date
    updated_at: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    full_name?: boolean
    role?: boolean
    password_hash?: boolean
    created_at?: boolean
    updated_at?: boolean
    mentee_profile?: boolean | User$mentee_profileArgs<ExtArgs>
    mentor_profile?: boolean | User$mentor_profileArgs<ExtArgs>
    user_consent?: boolean | User$user_consentArgs<ExtArgs>
    mentee_languages?: boolean | User$mentee_languagesArgs<ExtArgs>
    mentee_interests?: boolean | User$mentee_interestsArgs<ExtArgs>
    mentee_priorities?: boolean | User$mentee_prioritiesArgs<ExtArgs>
    mentor_languages?: boolean | User$mentor_languagesArgs<ExtArgs>
    mentor_categories?: boolean | User$mentor_categoriesArgs<ExtArgs>
    mentor_skills?: boolean | User$mentor_skillsArgs<ExtArgs>
    mentee_service_focus?: boolean | User$mentee_service_focusArgs<ExtArgs>
    mentee_languages_ref?: boolean | User$mentee_languages_refArgs<ExtArgs>
    mentee_disciplines_ref?: boolean | User$mentee_disciplines_refArgs<ExtArgs>
    mentee_preferences_ref?: boolean | User$mentee_preferences_refArgs<ExtArgs>
    mentor_company_membership?: boolean | User$mentor_company_membershipArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    full_name?: boolean
    role?: boolean
    password_hash?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    full_name?: boolean
    role?: boolean
    password_hash?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    full_name?: boolean
    role?: boolean
    password_hash?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "full_name" | "role" | "password_hash" | "created_at" | "updated_at", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentee_profile?: boolean | User$mentee_profileArgs<ExtArgs>
    mentor_profile?: boolean | User$mentor_profileArgs<ExtArgs>
    user_consent?: boolean | User$user_consentArgs<ExtArgs>
    mentee_languages?: boolean | User$mentee_languagesArgs<ExtArgs>
    mentee_interests?: boolean | User$mentee_interestsArgs<ExtArgs>
    mentee_priorities?: boolean | User$mentee_prioritiesArgs<ExtArgs>
    mentor_languages?: boolean | User$mentor_languagesArgs<ExtArgs>
    mentor_categories?: boolean | User$mentor_categoriesArgs<ExtArgs>
    mentor_skills?: boolean | User$mentor_skillsArgs<ExtArgs>
    mentee_service_focus?: boolean | User$mentee_service_focusArgs<ExtArgs>
    mentee_languages_ref?: boolean | User$mentee_languages_refArgs<ExtArgs>
    mentee_disciplines_ref?: boolean | User$mentee_disciplines_refArgs<ExtArgs>
    mentee_preferences_ref?: boolean | User$mentee_preferences_refArgs<ExtArgs>
    mentor_company_membership?: boolean | User$mentor_company_membershipArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      mentee_profile: Prisma.$MenteePayload<ExtArgs> | null
      mentor_profile: Prisma.$MentorPayload<ExtArgs> | null
      user_consent: Prisma.$UserConsentPayload<ExtArgs> | null
      mentee_languages: Prisma.$MenteeLanguagePayload<ExtArgs>[]
      mentee_interests: Prisma.$MenteeInterestPayload<ExtArgs>[]
      mentee_priorities: Prisma.$MenteePriorityPayload<ExtArgs>[]
      mentor_languages: Prisma.$MentorLanguagePayload<ExtArgs>[]
      mentor_categories: Prisma.$MentorCategoryPayload<ExtArgs>[]
      mentor_skills: Prisma.$MentorSkillPayload<ExtArgs>[]
      mentee_service_focus: Prisma.$MenteeServiceFocusPayload<ExtArgs>[]
      mentee_languages_ref: Prisma.$MenteeLanguageRefPayload<ExtArgs>[]
      mentee_disciplines_ref: Prisma.$MenteeDisciplineRefPayload<ExtArgs>[]
      mentee_preferences_ref: Prisma.$MenteePreferenceRefPayload<ExtArgs>[]
      mentor_company_membership: Prisma.$MentorCompanyMembershipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      full_name: string
      role: $Enums.UserRole
      password_hash: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mentee_profile<T extends User$mentee_profileArgs<ExtArgs> = {}>(args?: Subset<T, User$mentee_profileArgs<ExtArgs>>): Prisma__MenteeClient<$Result.GetResult<Prisma.$MenteePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mentor_profile<T extends User$mentor_profileArgs<ExtArgs> = {}>(args?: Subset<T, User$mentor_profileArgs<ExtArgs>>): Prisma__MentorClient<$Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user_consent<T extends User$user_consentArgs<ExtArgs> = {}>(args?: Subset<T, User$user_consentArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mentee_languages<T extends User$mentee_languagesArgs<ExtArgs> = {}>(args?: Subset<T, User$mentee_languagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteeLanguagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mentee_interests<T extends User$mentee_interestsArgs<ExtArgs> = {}>(args?: Subset<T, User$mentee_interestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteeInterestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mentee_priorities<T extends User$mentee_prioritiesArgs<ExtArgs> = {}>(args?: Subset<T, User$mentee_prioritiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteePriorityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mentor_languages<T extends User$mentor_languagesArgs<ExtArgs> = {}>(args?: Subset<T, User$mentor_languagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorLanguagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mentor_categories<T extends User$mentor_categoriesArgs<ExtArgs> = {}>(args?: Subset<T, User$mentor_categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mentor_skills<T extends User$mentor_skillsArgs<ExtArgs> = {}>(args?: Subset<T, User$mentor_skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mentee_service_focus<T extends User$mentee_service_focusArgs<ExtArgs> = {}>(args?: Subset<T, User$mentee_service_focusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteeServiceFocusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mentee_languages_ref<T extends User$mentee_languages_refArgs<ExtArgs> = {}>(args?: Subset<T, User$mentee_languages_refArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteeLanguageRefPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mentee_disciplines_ref<T extends User$mentee_disciplines_refArgs<ExtArgs> = {}>(args?: Subset<T, User$mentee_disciplines_refArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteeDisciplineRefPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mentee_preferences_ref<T extends User$mentee_preferences_refArgs<ExtArgs> = {}>(args?: Subset<T, User$mentee_preferences_refArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteePreferenceRefPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mentor_company_membership<T extends User$mentor_company_membershipArgs<ExtArgs> = {}>(args?: Subset<T, User$mentor_company_membershipArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorCompanyMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly full_name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly password_hash: FieldRef<"User", 'String'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly updated_at: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.mentee_profile
   */
  export type User$mentee_profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentee
     */
    select?: MenteeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentee
     */
    omit?: MenteeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeInclude<ExtArgs> | null
    where?: MenteeWhereInput
  }

  /**
   * User.mentor_profile
   */
  export type User$mentor_profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentor
     */
    omit?: MentorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null
    where?: MentorWhereInput
  }

  /**
   * User.user_consent
   */
  export type User$user_consentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    where?: UserConsentWhereInput
  }

  /**
   * User.mentee_languages
   */
  export type User$mentee_languagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeLanguage
     */
    select?: MenteeLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeLanguage
     */
    omit?: MenteeLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeLanguageInclude<ExtArgs> | null
    where?: MenteeLanguageWhereInput
    orderBy?: MenteeLanguageOrderByWithRelationInput | MenteeLanguageOrderByWithRelationInput[]
    cursor?: MenteeLanguageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenteeLanguageScalarFieldEnum | MenteeLanguageScalarFieldEnum[]
  }

  /**
   * User.mentee_interests
   */
  export type User$mentee_interestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeInterest
     */
    select?: MenteeInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeInterest
     */
    omit?: MenteeInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeInterestInclude<ExtArgs> | null
    where?: MenteeInterestWhereInput
    orderBy?: MenteeInterestOrderByWithRelationInput | MenteeInterestOrderByWithRelationInput[]
    cursor?: MenteeInterestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenteeInterestScalarFieldEnum | MenteeInterestScalarFieldEnum[]
  }

  /**
   * User.mentee_priorities
   */
  export type User$mentee_prioritiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteePriority
     */
    select?: MenteePrioritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteePriority
     */
    omit?: MenteePriorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteePriorityInclude<ExtArgs> | null
    where?: MenteePriorityWhereInput
    orderBy?: MenteePriorityOrderByWithRelationInput | MenteePriorityOrderByWithRelationInput[]
    cursor?: MenteePriorityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenteePriorityScalarFieldEnum | MenteePriorityScalarFieldEnum[]
  }

  /**
   * User.mentor_languages
   */
  export type User$mentor_languagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorLanguage
     */
    select?: MentorLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorLanguage
     */
    omit?: MentorLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorLanguageInclude<ExtArgs> | null
    where?: MentorLanguageWhereInput
    orderBy?: MentorLanguageOrderByWithRelationInput | MentorLanguageOrderByWithRelationInput[]
    cursor?: MentorLanguageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentorLanguageScalarFieldEnum | MentorLanguageScalarFieldEnum[]
  }

  /**
   * User.mentor_categories
   */
  export type User$mentor_categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorCategory
     */
    select?: MentorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorCategory
     */
    omit?: MentorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorCategoryInclude<ExtArgs> | null
    where?: MentorCategoryWhereInput
    orderBy?: MentorCategoryOrderByWithRelationInput | MentorCategoryOrderByWithRelationInput[]
    cursor?: MentorCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentorCategoryScalarFieldEnum | MentorCategoryScalarFieldEnum[]
  }

  /**
   * User.mentor_skills
   */
  export type User$mentor_skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorSkill
     */
    select?: MentorSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorSkill
     */
    omit?: MentorSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSkillInclude<ExtArgs> | null
    where?: MentorSkillWhereInput
    orderBy?: MentorSkillOrderByWithRelationInput | MentorSkillOrderByWithRelationInput[]
    cursor?: MentorSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentorSkillScalarFieldEnum | MentorSkillScalarFieldEnum[]
  }

  /**
   * User.mentee_service_focus
   */
  export type User$mentee_service_focusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeServiceFocus
     */
    select?: MenteeServiceFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeServiceFocus
     */
    omit?: MenteeServiceFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeServiceFocusInclude<ExtArgs> | null
    where?: MenteeServiceFocusWhereInput
    orderBy?: MenteeServiceFocusOrderByWithRelationInput | MenteeServiceFocusOrderByWithRelationInput[]
    cursor?: MenteeServiceFocusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenteeServiceFocusScalarFieldEnum | MenteeServiceFocusScalarFieldEnum[]
  }

  /**
   * User.mentee_languages_ref
   */
  export type User$mentee_languages_refArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeLanguageRef
     */
    select?: MenteeLanguageRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeLanguageRef
     */
    omit?: MenteeLanguageRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeLanguageRefInclude<ExtArgs> | null
    where?: MenteeLanguageRefWhereInput
    orderBy?: MenteeLanguageRefOrderByWithRelationInput | MenteeLanguageRefOrderByWithRelationInput[]
    cursor?: MenteeLanguageRefWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenteeLanguageRefScalarFieldEnum | MenteeLanguageRefScalarFieldEnum[]
  }

  /**
   * User.mentee_disciplines_ref
   */
  export type User$mentee_disciplines_refArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeDisciplineRef
     */
    select?: MenteeDisciplineRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeDisciplineRef
     */
    omit?: MenteeDisciplineRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeDisciplineRefInclude<ExtArgs> | null
    where?: MenteeDisciplineRefWhereInput
    orderBy?: MenteeDisciplineRefOrderByWithRelationInput | MenteeDisciplineRefOrderByWithRelationInput[]
    cursor?: MenteeDisciplineRefWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenteeDisciplineRefScalarFieldEnum | MenteeDisciplineRefScalarFieldEnum[]
  }

  /**
   * User.mentee_preferences_ref
   */
  export type User$mentee_preferences_refArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteePreferenceRef
     */
    select?: MenteePreferenceRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteePreferenceRef
     */
    omit?: MenteePreferenceRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteePreferenceRefInclude<ExtArgs> | null
    where?: MenteePreferenceRefWhereInput
    orderBy?: MenteePreferenceRefOrderByWithRelationInput | MenteePreferenceRefOrderByWithRelationInput[]
    cursor?: MenteePreferenceRefWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenteePreferenceRefScalarFieldEnum | MenteePreferenceRefScalarFieldEnum[]
  }

  /**
   * User.mentor_company_membership
   */
  export type User$mentor_company_membershipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorCompanyMembership
     */
    select?: MentorCompanyMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorCompanyMembership
     */
    omit?: MentorCompanyMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorCompanyMembershipInclude<ExtArgs> | null
    where?: MentorCompanyMembershipWhereInput
    orderBy?: MentorCompanyMembershipOrderByWithRelationInput | MentorCompanyMembershipOrderByWithRelationInput[]
    cursor?: MentorCompanyMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentorCompanyMembershipScalarFieldEnum | MentorCompanyMembershipScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Mentee
   */

  export type AggregateMentee = {
    _count: MenteeCountAggregateOutputType | null
    _min: MenteeMinAggregateOutputType | null
    _max: MenteeMaxAggregateOutputType | null
  }

  export type MenteeMinAggregateOutputType = {
    user_id: string | null
    short_goal: string | null
    target_track: string | null
    budget: string | null
    time_preference: string | null
    city: string | null
    country: string | null
    goal_type: string | null
    service_focus: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MenteeMaxAggregateOutputType = {
    user_id: string | null
    short_goal: string | null
    target_track: string | null
    budget: string | null
    time_preference: string | null
    city: string | null
    country: string | null
    goal_type: string | null
    service_focus: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MenteeCountAggregateOutputType = {
    user_id: number
    short_goal: number
    target_track: number
    budget: number
    time_preference: number
    city: number
    country: number
    goal_type: number
    service_focus: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type MenteeMinAggregateInputType = {
    user_id?: true
    short_goal?: true
    target_track?: true
    budget?: true
    time_preference?: true
    city?: true
    country?: true
    goal_type?: true
    service_focus?: true
    created_at?: true
    updated_at?: true
  }

  export type MenteeMaxAggregateInputType = {
    user_id?: true
    short_goal?: true
    target_track?: true
    budget?: true
    time_preference?: true
    city?: true
    country?: true
    goal_type?: true
    service_focus?: true
    created_at?: true
    updated_at?: true
  }

  export type MenteeCountAggregateInputType = {
    user_id?: true
    short_goal?: true
    target_track?: true
    budget?: true
    time_preference?: true
    city?: true
    country?: true
    goal_type?: true
    service_focus?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type MenteeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mentee to aggregate.
     */
    where?: MenteeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentees to fetch.
     */
    orderBy?: MenteeOrderByWithRelationInput | MenteeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenteeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mentees
    **/
    _count?: true | MenteeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenteeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenteeMaxAggregateInputType
  }

  export type GetMenteeAggregateType<T extends MenteeAggregateArgs> = {
        [P in keyof T & keyof AggregateMentee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMentee[P]>
      : GetScalarType<T[P], AggregateMentee[P]>
  }




  export type MenteeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenteeWhereInput
    orderBy?: MenteeOrderByWithAggregationInput | MenteeOrderByWithAggregationInput[]
    by: MenteeScalarFieldEnum[] | MenteeScalarFieldEnum
    having?: MenteeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenteeCountAggregateInputType | true
    _min?: MenteeMinAggregateInputType
    _max?: MenteeMaxAggregateInputType
  }

  export type MenteeGroupByOutputType = {
    user_id: string
    short_goal: string
    target_track: string
    budget: string
    time_preference: string
    city: string | null
    country: string
    goal_type: string | null
    service_focus: string | null
    created_at: Date
    updated_at: Date
    _count: MenteeCountAggregateOutputType | null
    _min: MenteeMinAggregateOutputType | null
    _max: MenteeMaxAggregateOutputType | null
  }

  type GetMenteeGroupByPayload<T extends MenteeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenteeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenteeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenteeGroupByOutputType[P]>
            : GetScalarType<T[P], MenteeGroupByOutputType[P]>
        }
      >
    >


  export type MenteeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    short_goal?: boolean
    target_track?: boolean
    budget?: boolean
    time_preference?: boolean
    city?: boolean
    country?: boolean
    goal_type?: boolean
    service_focus?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentee"]>

  export type MenteeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    short_goal?: boolean
    target_track?: boolean
    budget?: boolean
    time_preference?: boolean
    city?: boolean
    country?: boolean
    goal_type?: boolean
    service_focus?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentee"]>

  export type MenteeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    short_goal?: boolean
    target_track?: boolean
    budget?: boolean
    time_preference?: boolean
    city?: boolean
    country?: boolean
    goal_type?: boolean
    service_focus?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentee"]>

  export type MenteeSelectScalar = {
    user_id?: boolean
    short_goal?: boolean
    target_track?: boolean
    budget?: boolean
    time_preference?: boolean
    city?: boolean
    country?: boolean
    goal_type?: boolean
    service_focus?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type MenteeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "short_goal" | "target_track" | "budget" | "time_preference" | "city" | "country" | "goal_type" | "service_focus" | "created_at" | "updated_at", ExtArgs["result"]["mentee"]>
  export type MenteeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MenteeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MenteeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MenteePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mentee"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: string
      short_goal: string
      target_track: string
      budget: string
      time_preference: string
      city: string | null
      country: string
      goal_type: string | null
      service_focus: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["mentee"]>
    composites: {}
  }

  type MenteeGetPayload<S extends boolean | null | undefined | MenteeDefaultArgs> = $Result.GetResult<Prisma.$MenteePayload, S>

  type MenteeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MenteeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MenteeCountAggregateInputType | true
    }

  export interface MenteeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mentee'], meta: { name: 'Mentee' } }
    /**
     * Find zero or one Mentee that matches the filter.
     * @param {MenteeFindUniqueArgs} args - Arguments to find a Mentee
     * @example
     * // Get one Mentee
     * const mentee = await prisma.mentee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenteeFindUniqueArgs>(args: SelectSubset<T, MenteeFindUniqueArgs<ExtArgs>>): Prisma__MenteeClient<$Result.GetResult<Prisma.$MenteePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mentee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MenteeFindUniqueOrThrowArgs} args - Arguments to find a Mentee
     * @example
     * // Get one Mentee
     * const mentee = await prisma.mentee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenteeFindUniqueOrThrowArgs>(args: SelectSubset<T, MenteeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MenteeClient<$Result.GetResult<Prisma.$MenteePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mentee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeFindFirstArgs} args - Arguments to find a Mentee
     * @example
     * // Get one Mentee
     * const mentee = await prisma.mentee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenteeFindFirstArgs>(args?: SelectSubset<T, MenteeFindFirstArgs<ExtArgs>>): Prisma__MenteeClient<$Result.GetResult<Prisma.$MenteePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mentee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeFindFirstOrThrowArgs} args - Arguments to find a Mentee
     * @example
     * // Get one Mentee
     * const mentee = await prisma.mentee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenteeFindFirstOrThrowArgs>(args?: SelectSubset<T, MenteeFindFirstOrThrowArgs<ExtArgs>>): Prisma__MenteeClient<$Result.GetResult<Prisma.$MenteePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mentees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mentees
     * const mentees = await prisma.mentee.findMany()
     * 
     * // Get first 10 Mentees
     * const mentees = await prisma.mentee.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const menteeWithUser_idOnly = await prisma.mentee.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends MenteeFindManyArgs>(args?: SelectSubset<T, MenteeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mentee.
     * @param {MenteeCreateArgs} args - Arguments to create a Mentee.
     * @example
     * // Create one Mentee
     * const Mentee = await prisma.mentee.create({
     *   data: {
     *     // ... data to create a Mentee
     *   }
     * })
     * 
     */
    create<T extends MenteeCreateArgs>(args: SelectSubset<T, MenteeCreateArgs<ExtArgs>>): Prisma__MenteeClient<$Result.GetResult<Prisma.$MenteePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mentees.
     * @param {MenteeCreateManyArgs} args - Arguments to create many Mentees.
     * @example
     * // Create many Mentees
     * const mentee = await prisma.mentee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MenteeCreateManyArgs>(args?: SelectSubset<T, MenteeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mentees and returns the data saved in the database.
     * @param {MenteeCreateManyAndReturnArgs} args - Arguments to create many Mentees.
     * @example
     * // Create many Mentees
     * const mentee = await prisma.mentee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mentees and only return the `user_id`
     * const menteeWithUser_idOnly = await prisma.mentee.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MenteeCreateManyAndReturnArgs>(args?: SelectSubset<T, MenteeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Mentee.
     * @param {MenteeDeleteArgs} args - Arguments to delete one Mentee.
     * @example
     * // Delete one Mentee
     * const Mentee = await prisma.mentee.delete({
     *   where: {
     *     // ... filter to delete one Mentee
     *   }
     * })
     * 
     */
    delete<T extends MenteeDeleteArgs>(args: SelectSubset<T, MenteeDeleteArgs<ExtArgs>>): Prisma__MenteeClient<$Result.GetResult<Prisma.$MenteePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mentee.
     * @param {MenteeUpdateArgs} args - Arguments to update one Mentee.
     * @example
     * // Update one Mentee
     * const mentee = await prisma.mentee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MenteeUpdateArgs>(args: SelectSubset<T, MenteeUpdateArgs<ExtArgs>>): Prisma__MenteeClient<$Result.GetResult<Prisma.$MenteePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mentees.
     * @param {MenteeDeleteManyArgs} args - Arguments to filter Mentees to delete.
     * @example
     * // Delete a few Mentees
     * const { count } = await prisma.mentee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MenteeDeleteManyArgs>(args?: SelectSubset<T, MenteeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mentees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mentees
     * const mentee = await prisma.mentee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MenteeUpdateManyArgs>(args: SelectSubset<T, MenteeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mentees and returns the data updated in the database.
     * @param {MenteeUpdateManyAndReturnArgs} args - Arguments to update many Mentees.
     * @example
     * // Update many Mentees
     * const mentee = await prisma.mentee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Mentees and only return the `user_id`
     * const menteeWithUser_idOnly = await prisma.mentee.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MenteeUpdateManyAndReturnArgs>(args: SelectSubset<T, MenteeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Mentee.
     * @param {MenteeUpsertArgs} args - Arguments to update or create a Mentee.
     * @example
     * // Update or create a Mentee
     * const mentee = await prisma.mentee.upsert({
     *   create: {
     *     // ... data to create a Mentee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mentee we want to update
     *   }
     * })
     */
    upsert<T extends MenteeUpsertArgs>(args: SelectSubset<T, MenteeUpsertArgs<ExtArgs>>): Prisma__MenteeClient<$Result.GetResult<Prisma.$MenteePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Mentees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeCountArgs} args - Arguments to filter Mentees to count.
     * @example
     * // Count the number of Mentees
     * const count = await prisma.mentee.count({
     *   where: {
     *     // ... the filter for the Mentees we want to count
     *   }
     * })
    **/
    count<T extends MenteeCountArgs>(
      args?: Subset<T, MenteeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenteeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mentee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenteeAggregateArgs>(args: Subset<T, MenteeAggregateArgs>): Prisma.PrismaPromise<GetMenteeAggregateType<T>>

    /**
     * Group by Mentee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenteeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenteeGroupByArgs['orderBy'] }
        : { orderBy?: MenteeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenteeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenteeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mentee model
   */
  readonly fields: MenteeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mentee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenteeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mentee model
   */
  interface MenteeFieldRefs {
    readonly user_id: FieldRef<"Mentee", 'String'>
    readonly short_goal: FieldRef<"Mentee", 'String'>
    readonly target_track: FieldRef<"Mentee", 'String'>
    readonly budget: FieldRef<"Mentee", 'String'>
    readonly time_preference: FieldRef<"Mentee", 'String'>
    readonly city: FieldRef<"Mentee", 'String'>
    readonly country: FieldRef<"Mentee", 'String'>
    readonly goal_type: FieldRef<"Mentee", 'String'>
    readonly service_focus: FieldRef<"Mentee", 'String'>
    readonly created_at: FieldRef<"Mentee", 'DateTime'>
    readonly updated_at: FieldRef<"Mentee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Mentee findUnique
   */
  export type MenteeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentee
     */
    select?: MenteeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentee
     */
    omit?: MenteeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeInclude<ExtArgs> | null
    /**
     * Filter, which Mentee to fetch.
     */
    where: MenteeWhereUniqueInput
  }

  /**
   * Mentee findUniqueOrThrow
   */
  export type MenteeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentee
     */
    select?: MenteeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentee
     */
    omit?: MenteeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeInclude<ExtArgs> | null
    /**
     * Filter, which Mentee to fetch.
     */
    where: MenteeWhereUniqueInput
  }

  /**
   * Mentee findFirst
   */
  export type MenteeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentee
     */
    select?: MenteeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentee
     */
    omit?: MenteeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeInclude<ExtArgs> | null
    /**
     * Filter, which Mentee to fetch.
     */
    where?: MenteeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentees to fetch.
     */
    orderBy?: MenteeOrderByWithRelationInput | MenteeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mentees.
     */
    cursor?: MenteeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mentees.
     */
    distinct?: MenteeScalarFieldEnum | MenteeScalarFieldEnum[]
  }

  /**
   * Mentee findFirstOrThrow
   */
  export type MenteeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentee
     */
    select?: MenteeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentee
     */
    omit?: MenteeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeInclude<ExtArgs> | null
    /**
     * Filter, which Mentee to fetch.
     */
    where?: MenteeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentees to fetch.
     */
    orderBy?: MenteeOrderByWithRelationInput | MenteeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mentees.
     */
    cursor?: MenteeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mentees.
     */
    distinct?: MenteeScalarFieldEnum | MenteeScalarFieldEnum[]
  }

  /**
   * Mentee findMany
   */
  export type MenteeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentee
     */
    select?: MenteeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentee
     */
    omit?: MenteeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeInclude<ExtArgs> | null
    /**
     * Filter, which Mentees to fetch.
     */
    where?: MenteeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentees to fetch.
     */
    orderBy?: MenteeOrderByWithRelationInput | MenteeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mentees.
     */
    cursor?: MenteeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentees.
     */
    skip?: number
    distinct?: MenteeScalarFieldEnum | MenteeScalarFieldEnum[]
  }

  /**
   * Mentee create
   */
  export type MenteeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentee
     */
    select?: MenteeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentee
     */
    omit?: MenteeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeInclude<ExtArgs> | null
    /**
     * The data needed to create a Mentee.
     */
    data: XOR<MenteeCreateInput, MenteeUncheckedCreateInput>
  }

  /**
   * Mentee createMany
   */
  export type MenteeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mentees.
     */
    data: MenteeCreateManyInput | MenteeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mentee createManyAndReturn
   */
  export type MenteeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentee
     */
    select?: MenteeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Mentee
     */
    omit?: MenteeOmit<ExtArgs> | null
    /**
     * The data used to create many Mentees.
     */
    data: MenteeCreateManyInput | MenteeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Mentee update
   */
  export type MenteeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentee
     */
    select?: MenteeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentee
     */
    omit?: MenteeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeInclude<ExtArgs> | null
    /**
     * The data needed to update a Mentee.
     */
    data: XOR<MenteeUpdateInput, MenteeUncheckedUpdateInput>
    /**
     * Choose, which Mentee to update.
     */
    where: MenteeWhereUniqueInput
  }

  /**
   * Mentee updateMany
   */
  export type MenteeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mentees.
     */
    data: XOR<MenteeUpdateManyMutationInput, MenteeUncheckedUpdateManyInput>
    /**
     * Filter which Mentees to update
     */
    where?: MenteeWhereInput
    /**
     * Limit how many Mentees to update.
     */
    limit?: number
  }

  /**
   * Mentee updateManyAndReturn
   */
  export type MenteeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentee
     */
    select?: MenteeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Mentee
     */
    omit?: MenteeOmit<ExtArgs> | null
    /**
     * The data used to update Mentees.
     */
    data: XOR<MenteeUpdateManyMutationInput, MenteeUncheckedUpdateManyInput>
    /**
     * Filter which Mentees to update
     */
    where?: MenteeWhereInput
    /**
     * Limit how many Mentees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Mentee upsert
   */
  export type MenteeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentee
     */
    select?: MenteeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentee
     */
    omit?: MenteeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeInclude<ExtArgs> | null
    /**
     * The filter to search for the Mentee to update in case it exists.
     */
    where: MenteeWhereUniqueInput
    /**
     * In case the Mentee found by the `where` argument doesn't exist, create a new Mentee with this data.
     */
    create: XOR<MenteeCreateInput, MenteeUncheckedCreateInput>
    /**
     * In case the Mentee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenteeUpdateInput, MenteeUncheckedUpdateInput>
  }

  /**
   * Mentee delete
   */
  export type MenteeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentee
     */
    select?: MenteeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentee
     */
    omit?: MenteeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeInclude<ExtArgs> | null
    /**
     * Filter which Mentee to delete.
     */
    where: MenteeWhereUniqueInput
  }

  /**
   * Mentee deleteMany
   */
  export type MenteeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mentees to delete
     */
    where?: MenteeWhereInput
    /**
     * Limit how many Mentees to delete.
     */
    limit?: number
  }

  /**
   * Mentee without action
   */
  export type MenteeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentee
     */
    select?: MenteeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentee
     */
    omit?: MenteeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeInclude<ExtArgs> | null
  }


  /**
   * Model Mentor
   */

  export type AggregateMentor = {
    _count: MentorCountAggregateOutputType | null
    _avg: MentorAvgAggregateOutputType | null
    _sum: MentorSumAggregateOutputType | null
    _min: MentorMinAggregateOutputType | null
    _max: MentorMaxAggregateOutputType | null
  }

  export type MentorAvgAggregateOutputType = {
    years_experience: number | null
    hourly_rate_cents: number | null
    rating_avg: Decimal | null
    total_reviews: number | null
  }

  export type MentorSumAggregateOutputType = {
    years_experience: number | null
    hourly_rate_cents: number | null
    rating_avg: Decimal | null
    total_reviews: number | null
  }

  export type MentorMinAggregateOutputType = {
    user_id: string | null
    mentor_type: $Enums.MentorType | null
    display_name: string | null
    title: string | null
    years_experience: number | null
    hourly_rate_cents: number | null
    meeting_preference: string | null
    bio_short: string | null
    bio_long: string | null
    city: string | null
    country: string | null
    rating_avg: Decimal | null
    total_reviews: number | null
    status: $Enums.MentorStatus | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MentorMaxAggregateOutputType = {
    user_id: string | null
    mentor_type: $Enums.MentorType | null
    display_name: string | null
    title: string | null
    years_experience: number | null
    hourly_rate_cents: number | null
    meeting_preference: string | null
    bio_short: string | null
    bio_long: string | null
    city: string | null
    country: string | null
    rating_avg: Decimal | null
    total_reviews: number | null
    status: $Enums.MentorStatus | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MentorCountAggregateOutputType = {
    user_id: number
    mentor_type: number
    display_name: number
    title: number
    years_experience: number
    hourly_rate_cents: number
    meeting_preference: number
    bio_short: number
    bio_long: number
    city: number
    country: number
    rating_avg: number
    total_reviews: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type MentorAvgAggregateInputType = {
    years_experience?: true
    hourly_rate_cents?: true
    rating_avg?: true
    total_reviews?: true
  }

  export type MentorSumAggregateInputType = {
    years_experience?: true
    hourly_rate_cents?: true
    rating_avg?: true
    total_reviews?: true
  }

  export type MentorMinAggregateInputType = {
    user_id?: true
    mentor_type?: true
    display_name?: true
    title?: true
    years_experience?: true
    hourly_rate_cents?: true
    meeting_preference?: true
    bio_short?: true
    bio_long?: true
    city?: true
    country?: true
    rating_avg?: true
    total_reviews?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type MentorMaxAggregateInputType = {
    user_id?: true
    mentor_type?: true
    display_name?: true
    title?: true
    years_experience?: true
    hourly_rate_cents?: true
    meeting_preference?: true
    bio_short?: true
    bio_long?: true
    city?: true
    country?: true
    rating_avg?: true
    total_reviews?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type MentorCountAggregateInputType = {
    user_id?: true
    mentor_type?: true
    display_name?: true
    title?: true
    years_experience?: true
    hourly_rate_cents?: true
    meeting_preference?: true
    bio_short?: true
    bio_long?: true
    city?: true
    country?: true
    rating_avg?: true
    total_reviews?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type MentorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mentor to aggregate.
     */
    where?: MentorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentors to fetch.
     */
    orderBy?: MentorOrderByWithRelationInput | MentorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MentorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mentors
    **/
    _count?: true | MentorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MentorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MentorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MentorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MentorMaxAggregateInputType
  }

  export type GetMentorAggregateType<T extends MentorAggregateArgs> = {
        [P in keyof T & keyof AggregateMentor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMentor[P]>
      : GetScalarType<T[P], AggregateMentor[P]>
  }




  export type MentorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorWhereInput
    orderBy?: MentorOrderByWithAggregationInput | MentorOrderByWithAggregationInput[]
    by: MentorScalarFieldEnum[] | MentorScalarFieldEnum
    having?: MentorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MentorCountAggregateInputType | true
    _avg?: MentorAvgAggregateInputType
    _sum?: MentorSumAggregateInputType
    _min?: MentorMinAggregateInputType
    _max?: MentorMaxAggregateInputType
  }

  export type MentorGroupByOutputType = {
    user_id: string
    mentor_type: $Enums.MentorType
    display_name: string
    title: string
    years_experience: number
    hourly_rate_cents: number
    meeting_preference: string
    bio_short: string
    bio_long: string
    city: string | null
    country: string
    rating_avg: Decimal
    total_reviews: number
    status: $Enums.MentorStatus
    created_at: Date
    updated_at: Date
    _count: MentorCountAggregateOutputType | null
    _avg: MentorAvgAggregateOutputType | null
    _sum: MentorSumAggregateOutputType | null
    _min: MentorMinAggregateOutputType | null
    _max: MentorMaxAggregateOutputType | null
  }

  type GetMentorGroupByPayload<T extends MentorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MentorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MentorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MentorGroupByOutputType[P]>
            : GetScalarType<T[P], MentorGroupByOutputType[P]>
        }
      >
    >


  export type MentorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    mentor_type?: boolean
    display_name?: boolean
    title?: boolean
    years_experience?: boolean
    hourly_rate_cents?: boolean
    meeting_preference?: boolean
    bio_short?: boolean
    bio_long?: boolean
    city?: boolean
    country?: boolean
    rating_avg?: boolean
    total_reviews?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentor"]>

  export type MentorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    mentor_type?: boolean
    display_name?: boolean
    title?: boolean
    years_experience?: boolean
    hourly_rate_cents?: boolean
    meeting_preference?: boolean
    bio_short?: boolean
    bio_long?: boolean
    city?: boolean
    country?: boolean
    rating_avg?: boolean
    total_reviews?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentor"]>

  export type MentorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    mentor_type?: boolean
    display_name?: boolean
    title?: boolean
    years_experience?: boolean
    hourly_rate_cents?: boolean
    meeting_preference?: boolean
    bio_short?: boolean
    bio_long?: boolean
    city?: boolean
    country?: boolean
    rating_avg?: boolean
    total_reviews?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentor"]>

  export type MentorSelectScalar = {
    user_id?: boolean
    mentor_type?: boolean
    display_name?: boolean
    title?: boolean
    years_experience?: boolean
    hourly_rate_cents?: boolean
    meeting_preference?: boolean
    bio_short?: boolean
    bio_long?: boolean
    city?: boolean
    country?: boolean
    rating_avg?: boolean
    total_reviews?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type MentorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "mentor_type" | "display_name" | "title" | "years_experience" | "hourly_rate_cents" | "meeting_preference" | "bio_short" | "bio_long" | "city" | "country" | "rating_avg" | "total_reviews" | "status" | "created_at" | "updated_at", ExtArgs["result"]["mentor"]>
  export type MentorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MentorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MentorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MentorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mentor"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: string
      mentor_type: $Enums.MentorType
      display_name: string
      title: string
      years_experience: number
      hourly_rate_cents: number
      meeting_preference: string
      bio_short: string
      bio_long: string
      city: string | null
      country: string
      rating_avg: Prisma.Decimal
      total_reviews: number
      status: $Enums.MentorStatus
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["mentor"]>
    composites: {}
  }

  type MentorGetPayload<S extends boolean | null | undefined | MentorDefaultArgs> = $Result.GetResult<Prisma.$MentorPayload, S>

  type MentorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MentorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MentorCountAggregateInputType | true
    }

  export interface MentorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mentor'], meta: { name: 'Mentor' } }
    /**
     * Find zero or one Mentor that matches the filter.
     * @param {MentorFindUniqueArgs} args - Arguments to find a Mentor
     * @example
     * // Get one Mentor
     * const mentor = await prisma.mentor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MentorFindUniqueArgs>(args: SelectSubset<T, MentorFindUniqueArgs<ExtArgs>>): Prisma__MentorClient<$Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mentor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MentorFindUniqueOrThrowArgs} args - Arguments to find a Mentor
     * @example
     * // Get one Mentor
     * const mentor = await prisma.mentor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MentorFindUniqueOrThrowArgs>(args: SelectSubset<T, MentorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MentorClient<$Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mentor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorFindFirstArgs} args - Arguments to find a Mentor
     * @example
     * // Get one Mentor
     * const mentor = await prisma.mentor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MentorFindFirstArgs>(args?: SelectSubset<T, MentorFindFirstArgs<ExtArgs>>): Prisma__MentorClient<$Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mentor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorFindFirstOrThrowArgs} args - Arguments to find a Mentor
     * @example
     * // Get one Mentor
     * const mentor = await prisma.mentor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MentorFindFirstOrThrowArgs>(args?: SelectSubset<T, MentorFindFirstOrThrowArgs<ExtArgs>>): Prisma__MentorClient<$Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mentors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mentors
     * const mentors = await prisma.mentor.findMany()
     * 
     * // Get first 10 Mentors
     * const mentors = await prisma.mentor.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const mentorWithUser_idOnly = await prisma.mentor.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends MentorFindManyArgs>(args?: SelectSubset<T, MentorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mentor.
     * @param {MentorCreateArgs} args - Arguments to create a Mentor.
     * @example
     * // Create one Mentor
     * const Mentor = await prisma.mentor.create({
     *   data: {
     *     // ... data to create a Mentor
     *   }
     * })
     * 
     */
    create<T extends MentorCreateArgs>(args: SelectSubset<T, MentorCreateArgs<ExtArgs>>): Prisma__MentorClient<$Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mentors.
     * @param {MentorCreateManyArgs} args - Arguments to create many Mentors.
     * @example
     * // Create many Mentors
     * const mentor = await prisma.mentor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MentorCreateManyArgs>(args?: SelectSubset<T, MentorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mentors and returns the data saved in the database.
     * @param {MentorCreateManyAndReturnArgs} args - Arguments to create many Mentors.
     * @example
     * // Create many Mentors
     * const mentor = await prisma.mentor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mentors and only return the `user_id`
     * const mentorWithUser_idOnly = await prisma.mentor.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MentorCreateManyAndReturnArgs>(args?: SelectSubset<T, MentorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Mentor.
     * @param {MentorDeleteArgs} args - Arguments to delete one Mentor.
     * @example
     * // Delete one Mentor
     * const Mentor = await prisma.mentor.delete({
     *   where: {
     *     // ... filter to delete one Mentor
     *   }
     * })
     * 
     */
    delete<T extends MentorDeleteArgs>(args: SelectSubset<T, MentorDeleteArgs<ExtArgs>>): Prisma__MentorClient<$Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mentor.
     * @param {MentorUpdateArgs} args - Arguments to update one Mentor.
     * @example
     * // Update one Mentor
     * const mentor = await prisma.mentor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MentorUpdateArgs>(args: SelectSubset<T, MentorUpdateArgs<ExtArgs>>): Prisma__MentorClient<$Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mentors.
     * @param {MentorDeleteManyArgs} args - Arguments to filter Mentors to delete.
     * @example
     * // Delete a few Mentors
     * const { count } = await prisma.mentor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MentorDeleteManyArgs>(args?: SelectSubset<T, MentorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mentors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mentors
     * const mentor = await prisma.mentor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MentorUpdateManyArgs>(args: SelectSubset<T, MentorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mentors and returns the data updated in the database.
     * @param {MentorUpdateManyAndReturnArgs} args - Arguments to update many Mentors.
     * @example
     * // Update many Mentors
     * const mentor = await prisma.mentor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Mentors and only return the `user_id`
     * const mentorWithUser_idOnly = await prisma.mentor.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MentorUpdateManyAndReturnArgs>(args: SelectSubset<T, MentorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Mentor.
     * @param {MentorUpsertArgs} args - Arguments to update or create a Mentor.
     * @example
     * // Update or create a Mentor
     * const mentor = await prisma.mentor.upsert({
     *   create: {
     *     // ... data to create a Mentor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mentor we want to update
     *   }
     * })
     */
    upsert<T extends MentorUpsertArgs>(args: SelectSubset<T, MentorUpsertArgs<ExtArgs>>): Prisma__MentorClient<$Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Mentors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorCountArgs} args - Arguments to filter Mentors to count.
     * @example
     * // Count the number of Mentors
     * const count = await prisma.mentor.count({
     *   where: {
     *     // ... the filter for the Mentors we want to count
     *   }
     * })
    **/
    count<T extends MentorCountArgs>(
      args?: Subset<T, MentorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MentorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mentor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MentorAggregateArgs>(args: Subset<T, MentorAggregateArgs>): Prisma.PrismaPromise<GetMentorAggregateType<T>>

    /**
     * Group by Mentor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MentorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MentorGroupByArgs['orderBy'] }
        : { orderBy?: MentorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MentorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMentorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mentor model
   */
  readonly fields: MentorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mentor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MentorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mentor model
   */
  interface MentorFieldRefs {
    readonly user_id: FieldRef<"Mentor", 'String'>
    readonly mentor_type: FieldRef<"Mentor", 'MentorType'>
    readonly display_name: FieldRef<"Mentor", 'String'>
    readonly title: FieldRef<"Mentor", 'String'>
    readonly years_experience: FieldRef<"Mentor", 'Int'>
    readonly hourly_rate_cents: FieldRef<"Mentor", 'Int'>
    readonly meeting_preference: FieldRef<"Mentor", 'String'>
    readonly bio_short: FieldRef<"Mentor", 'String'>
    readonly bio_long: FieldRef<"Mentor", 'String'>
    readonly city: FieldRef<"Mentor", 'String'>
    readonly country: FieldRef<"Mentor", 'String'>
    readonly rating_avg: FieldRef<"Mentor", 'Decimal'>
    readonly total_reviews: FieldRef<"Mentor", 'Int'>
    readonly status: FieldRef<"Mentor", 'MentorStatus'>
    readonly created_at: FieldRef<"Mentor", 'DateTime'>
    readonly updated_at: FieldRef<"Mentor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Mentor findUnique
   */
  export type MentorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentor
     */
    omit?: MentorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null
    /**
     * Filter, which Mentor to fetch.
     */
    where: MentorWhereUniqueInput
  }

  /**
   * Mentor findUniqueOrThrow
   */
  export type MentorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentor
     */
    omit?: MentorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null
    /**
     * Filter, which Mentor to fetch.
     */
    where: MentorWhereUniqueInput
  }

  /**
   * Mentor findFirst
   */
  export type MentorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentor
     */
    omit?: MentorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null
    /**
     * Filter, which Mentor to fetch.
     */
    where?: MentorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentors to fetch.
     */
    orderBy?: MentorOrderByWithRelationInput | MentorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mentors.
     */
    cursor?: MentorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mentors.
     */
    distinct?: MentorScalarFieldEnum | MentorScalarFieldEnum[]
  }

  /**
   * Mentor findFirstOrThrow
   */
  export type MentorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentor
     */
    omit?: MentorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null
    /**
     * Filter, which Mentor to fetch.
     */
    where?: MentorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentors to fetch.
     */
    orderBy?: MentorOrderByWithRelationInput | MentorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mentors.
     */
    cursor?: MentorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mentors.
     */
    distinct?: MentorScalarFieldEnum | MentorScalarFieldEnum[]
  }

  /**
   * Mentor findMany
   */
  export type MentorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentor
     */
    omit?: MentorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null
    /**
     * Filter, which Mentors to fetch.
     */
    where?: MentorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentors to fetch.
     */
    orderBy?: MentorOrderByWithRelationInput | MentorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mentors.
     */
    cursor?: MentorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentors.
     */
    skip?: number
    distinct?: MentorScalarFieldEnum | MentorScalarFieldEnum[]
  }

  /**
   * Mentor create
   */
  export type MentorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentor
     */
    omit?: MentorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null
    /**
     * The data needed to create a Mentor.
     */
    data: XOR<MentorCreateInput, MentorUncheckedCreateInput>
  }

  /**
   * Mentor createMany
   */
  export type MentorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mentors.
     */
    data: MentorCreateManyInput | MentorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mentor createManyAndReturn
   */
  export type MentorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Mentor
     */
    omit?: MentorOmit<ExtArgs> | null
    /**
     * The data used to create many Mentors.
     */
    data: MentorCreateManyInput | MentorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Mentor update
   */
  export type MentorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentor
     */
    omit?: MentorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null
    /**
     * The data needed to update a Mentor.
     */
    data: XOR<MentorUpdateInput, MentorUncheckedUpdateInput>
    /**
     * Choose, which Mentor to update.
     */
    where: MentorWhereUniqueInput
  }

  /**
   * Mentor updateMany
   */
  export type MentorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mentors.
     */
    data: XOR<MentorUpdateManyMutationInput, MentorUncheckedUpdateManyInput>
    /**
     * Filter which Mentors to update
     */
    where?: MentorWhereInput
    /**
     * Limit how many Mentors to update.
     */
    limit?: number
  }

  /**
   * Mentor updateManyAndReturn
   */
  export type MentorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Mentor
     */
    omit?: MentorOmit<ExtArgs> | null
    /**
     * The data used to update Mentors.
     */
    data: XOR<MentorUpdateManyMutationInput, MentorUncheckedUpdateManyInput>
    /**
     * Filter which Mentors to update
     */
    where?: MentorWhereInput
    /**
     * Limit how many Mentors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Mentor upsert
   */
  export type MentorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentor
     */
    omit?: MentorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null
    /**
     * The filter to search for the Mentor to update in case it exists.
     */
    where: MentorWhereUniqueInput
    /**
     * In case the Mentor found by the `where` argument doesn't exist, create a new Mentor with this data.
     */
    create: XOR<MentorCreateInput, MentorUncheckedCreateInput>
    /**
     * In case the Mentor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MentorUpdateInput, MentorUncheckedUpdateInput>
  }

  /**
   * Mentor delete
   */
  export type MentorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentor
     */
    omit?: MentorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null
    /**
     * Filter which Mentor to delete.
     */
    where: MentorWhereUniqueInput
  }

  /**
   * Mentor deleteMany
   */
  export type MentorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mentors to delete
     */
    where?: MentorWhereInput
    /**
     * Limit how many Mentors to delete.
     */
    limit?: number
  }

  /**
   * Mentor without action
   */
  export type MentorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mentor
     */
    omit?: MentorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null
  }


  /**
   * Model ServiceFocusRef
   */

  export type AggregateServiceFocusRef = {
    _count: ServiceFocusRefCountAggregateOutputType | null
    _avg: ServiceFocusRefAvgAggregateOutputType | null
    _sum: ServiceFocusRefSumAggregateOutputType | null
    _min: ServiceFocusRefMinAggregateOutputType | null
    _max: ServiceFocusRefMaxAggregateOutputType | null
  }

  export type ServiceFocusRefAvgAggregateOutputType = {
    sort_order: number | null
  }

  export type ServiceFocusRefSumAggregateOutputType = {
    sort_order: number | null
  }

  export type ServiceFocusRefMinAggregateOutputType = {
    id: string | null
    label: string | null
    active: boolean | null
    sort_order: number | null
  }

  export type ServiceFocusRefMaxAggregateOutputType = {
    id: string | null
    label: string | null
    active: boolean | null
    sort_order: number | null
  }

  export type ServiceFocusRefCountAggregateOutputType = {
    id: number
    label: number
    active: number
    sort_order: number
    _all: number
  }


  export type ServiceFocusRefAvgAggregateInputType = {
    sort_order?: true
  }

  export type ServiceFocusRefSumAggregateInputType = {
    sort_order?: true
  }

  export type ServiceFocusRefMinAggregateInputType = {
    id?: true
    label?: true
    active?: true
    sort_order?: true
  }

  export type ServiceFocusRefMaxAggregateInputType = {
    id?: true
    label?: true
    active?: true
    sort_order?: true
  }

  export type ServiceFocusRefCountAggregateInputType = {
    id?: true
    label?: true
    active?: true
    sort_order?: true
    _all?: true
  }

  export type ServiceFocusRefAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceFocusRef to aggregate.
     */
    where?: ServiceFocusRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceFocusRefs to fetch.
     */
    orderBy?: ServiceFocusRefOrderByWithRelationInput | ServiceFocusRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceFocusRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceFocusRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceFocusRefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceFocusRefs
    **/
    _count?: true | ServiceFocusRefCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceFocusRefAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceFocusRefSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceFocusRefMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceFocusRefMaxAggregateInputType
  }

  export type GetServiceFocusRefAggregateType<T extends ServiceFocusRefAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceFocusRef]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceFocusRef[P]>
      : GetScalarType<T[P], AggregateServiceFocusRef[P]>
  }




  export type ServiceFocusRefGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceFocusRefWhereInput
    orderBy?: ServiceFocusRefOrderByWithAggregationInput | ServiceFocusRefOrderByWithAggregationInput[]
    by: ServiceFocusRefScalarFieldEnum[] | ServiceFocusRefScalarFieldEnum
    having?: ServiceFocusRefScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceFocusRefCountAggregateInputType | true
    _avg?: ServiceFocusRefAvgAggregateInputType
    _sum?: ServiceFocusRefSumAggregateInputType
    _min?: ServiceFocusRefMinAggregateInputType
    _max?: ServiceFocusRefMaxAggregateInputType
  }

  export type ServiceFocusRefGroupByOutputType = {
    id: string
    label: string
    active: boolean
    sort_order: number
    _count: ServiceFocusRefCountAggregateOutputType | null
    _avg: ServiceFocusRefAvgAggregateOutputType | null
    _sum: ServiceFocusRefSumAggregateOutputType | null
    _min: ServiceFocusRefMinAggregateOutputType | null
    _max: ServiceFocusRefMaxAggregateOutputType | null
  }

  type GetServiceFocusRefGroupByPayload<T extends ServiceFocusRefGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceFocusRefGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceFocusRefGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceFocusRefGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceFocusRefGroupByOutputType[P]>
        }
      >
    >


  export type ServiceFocusRefSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    active?: boolean
    sort_order?: boolean
    mentee_service_focus?: boolean | ServiceFocusRef$mentee_service_focusArgs<ExtArgs>
    _count?: boolean | ServiceFocusRefCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceFocusRef"]>

  export type ServiceFocusRefSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    active?: boolean
    sort_order?: boolean
  }, ExtArgs["result"]["serviceFocusRef"]>

  export type ServiceFocusRefSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    active?: boolean
    sort_order?: boolean
  }, ExtArgs["result"]["serviceFocusRef"]>

  export type ServiceFocusRefSelectScalar = {
    id?: boolean
    label?: boolean
    active?: boolean
    sort_order?: boolean
  }

  export type ServiceFocusRefOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "active" | "sort_order", ExtArgs["result"]["serviceFocusRef"]>
  export type ServiceFocusRefInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentee_service_focus?: boolean | ServiceFocusRef$mentee_service_focusArgs<ExtArgs>
    _count?: boolean | ServiceFocusRefCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceFocusRefIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ServiceFocusRefIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServiceFocusRefPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceFocusRef"
    objects: {
      mentee_service_focus: Prisma.$MenteeServiceFocusPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      label: string
      active: boolean
      sort_order: number
    }, ExtArgs["result"]["serviceFocusRef"]>
    composites: {}
  }

  type ServiceFocusRefGetPayload<S extends boolean | null | undefined | ServiceFocusRefDefaultArgs> = $Result.GetResult<Prisma.$ServiceFocusRefPayload, S>

  type ServiceFocusRefCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFocusRefFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceFocusRefCountAggregateInputType | true
    }

  export interface ServiceFocusRefDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceFocusRef'], meta: { name: 'ServiceFocusRef' } }
    /**
     * Find zero or one ServiceFocusRef that matches the filter.
     * @param {ServiceFocusRefFindUniqueArgs} args - Arguments to find a ServiceFocusRef
     * @example
     * // Get one ServiceFocusRef
     * const serviceFocusRef = await prisma.serviceFocusRef.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFocusRefFindUniqueArgs>(args: SelectSubset<T, ServiceFocusRefFindUniqueArgs<ExtArgs>>): Prisma__ServiceFocusRefClient<$Result.GetResult<Prisma.$ServiceFocusRefPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceFocusRef that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFocusRefFindUniqueOrThrowArgs} args - Arguments to find a ServiceFocusRef
     * @example
     * // Get one ServiceFocusRef
     * const serviceFocusRef = await prisma.serviceFocusRef.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFocusRefFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFocusRefFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceFocusRefClient<$Result.GetResult<Prisma.$ServiceFocusRefPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceFocusRef that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFocusRefFindFirstArgs} args - Arguments to find a ServiceFocusRef
     * @example
     * // Get one ServiceFocusRef
     * const serviceFocusRef = await prisma.serviceFocusRef.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFocusRefFindFirstArgs>(args?: SelectSubset<T, ServiceFocusRefFindFirstArgs<ExtArgs>>): Prisma__ServiceFocusRefClient<$Result.GetResult<Prisma.$ServiceFocusRefPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceFocusRef that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFocusRefFindFirstOrThrowArgs} args - Arguments to find a ServiceFocusRef
     * @example
     * // Get one ServiceFocusRef
     * const serviceFocusRef = await prisma.serviceFocusRef.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFocusRefFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFocusRefFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceFocusRefClient<$Result.GetResult<Prisma.$ServiceFocusRefPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceFocusRefs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFocusRefFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceFocusRefs
     * const serviceFocusRefs = await prisma.serviceFocusRef.findMany()
     * 
     * // Get first 10 ServiceFocusRefs
     * const serviceFocusRefs = await prisma.serviceFocusRef.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceFocusRefWithIdOnly = await prisma.serviceFocusRef.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFocusRefFindManyArgs>(args?: SelectSubset<T, ServiceFocusRefFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceFocusRefPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceFocusRef.
     * @param {ServiceFocusRefCreateArgs} args - Arguments to create a ServiceFocusRef.
     * @example
     * // Create one ServiceFocusRef
     * const ServiceFocusRef = await prisma.serviceFocusRef.create({
     *   data: {
     *     // ... data to create a ServiceFocusRef
     *   }
     * })
     * 
     */
    create<T extends ServiceFocusRefCreateArgs>(args: SelectSubset<T, ServiceFocusRefCreateArgs<ExtArgs>>): Prisma__ServiceFocusRefClient<$Result.GetResult<Prisma.$ServiceFocusRefPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceFocusRefs.
     * @param {ServiceFocusRefCreateManyArgs} args - Arguments to create many ServiceFocusRefs.
     * @example
     * // Create many ServiceFocusRefs
     * const serviceFocusRef = await prisma.serviceFocusRef.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceFocusRefCreateManyArgs>(args?: SelectSubset<T, ServiceFocusRefCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceFocusRefs and returns the data saved in the database.
     * @param {ServiceFocusRefCreateManyAndReturnArgs} args - Arguments to create many ServiceFocusRefs.
     * @example
     * // Create many ServiceFocusRefs
     * const serviceFocusRef = await prisma.serviceFocusRef.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceFocusRefs and only return the `id`
     * const serviceFocusRefWithIdOnly = await prisma.serviceFocusRef.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceFocusRefCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceFocusRefCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceFocusRefPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceFocusRef.
     * @param {ServiceFocusRefDeleteArgs} args - Arguments to delete one ServiceFocusRef.
     * @example
     * // Delete one ServiceFocusRef
     * const ServiceFocusRef = await prisma.serviceFocusRef.delete({
     *   where: {
     *     // ... filter to delete one ServiceFocusRef
     *   }
     * })
     * 
     */
    delete<T extends ServiceFocusRefDeleteArgs>(args: SelectSubset<T, ServiceFocusRefDeleteArgs<ExtArgs>>): Prisma__ServiceFocusRefClient<$Result.GetResult<Prisma.$ServiceFocusRefPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceFocusRef.
     * @param {ServiceFocusRefUpdateArgs} args - Arguments to update one ServiceFocusRef.
     * @example
     * // Update one ServiceFocusRef
     * const serviceFocusRef = await prisma.serviceFocusRef.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceFocusRefUpdateArgs>(args: SelectSubset<T, ServiceFocusRefUpdateArgs<ExtArgs>>): Prisma__ServiceFocusRefClient<$Result.GetResult<Prisma.$ServiceFocusRefPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceFocusRefs.
     * @param {ServiceFocusRefDeleteManyArgs} args - Arguments to filter ServiceFocusRefs to delete.
     * @example
     * // Delete a few ServiceFocusRefs
     * const { count } = await prisma.serviceFocusRef.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceFocusRefDeleteManyArgs>(args?: SelectSubset<T, ServiceFocusRefDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceFocusRefs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFocusRefUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceFocusRefs
     * const serviceFocusRef = await prisma.serviceFocusRef.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceFocusRefUpdateManyArgs>(args: SelectSubset<T, ServiceFocusRefUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceFocusRefs and returns the data updated in the database.
     * @param {ServiceFocusRefUpdateManyAndReturnArgs} args - Arguments to update many ServiceFocusRefs.
     * @example
     * // Update many ServiceFocusRefs
     * const serviceFocusRef = await prisma.serviceFocusRef.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceFocusRefs and only return the `id`
     * const serviceFocusRefWithIdOnly = await prisma.serviceFocusRef.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceFocusRefUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceFocusRefUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceFocusRefPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceFocusRef.
     * @param {ServiceFocusRefUpsertArgs} args - Arguments to update or create a ServiceFocusRef.
     * @example
     * // Update or create a ServiceFocusRef
     * const serviceFocusRef = await prisma.serviceFocusRef.upsert({
     *   create: {
     *     // ... data to create a ServiceFocusRef
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceFocusRef we want to update
     *   }
     * })
     */
    upsert<T extends ServiceFocusRefUpsertArgs>(args: SelectSubset<T, ServiceFocusRefUpsertArgs<ExtArgs>>): Prisma__ServiceFocusRefClient<$Result.GetResult<Prisma.$ServiceFocusRefPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceFocusRefs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFocusRefCountArgs} args - Arguments to filter ServiceFocusRefs to count.
     * @example
     * // Count the number of ServiceFocusRefs
     * const count = await prisma.serviceFocusRef.count({
     *   where: {
     *     // ... the filter for the ServiceFocusRefs we want to count
     *   }
     * })
    **/
    count<T extends ServiceFocusRefCountArgs>(
      args?: Subset<T, ServiceFocusRefCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceFocusRefCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceFocusRef.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFocusRefAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceFocusRefAggregateArgs>(args: Subset<T, ServiceFocusRefAggregateArgs>): Prisma.PrismaPromise<GetServiceFocusRefAggregateType<T>>

    /**
     * Group by ServiceFocusRef.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFocusRefGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceFocusRefGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceFocusRefGroupByArgs['orderBy'] }
        : { orderBy?: ServiceFocusRefGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceFocusRefGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceFocusRefGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceFocusRef model
   */
  readonly fields: ServiceFocusRefFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceFocusRef.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceFocusRefClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mentee_service_focus<T extends ServiceFocusRef$mentee_service_focusArgs<ExtArgs> = {}>(args?: Subset<T, ServiceFocusRef$mentee_service_focusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteeServiceFocusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceFocusRef model
   */
  interface ServiceFocusRefFieldRefs {
    readonly id: FieldRef<"ServiceFocusRef", 'String'>
    readonly label: FieldRef<"ServiceFocusRef", 'String'>
    readonly active: FieldRef<"ServiceFocusRef", 'Boolean'>
    readonly sort_order: FieldRef<"ServiceFocusRef", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ServiceFocusRef findUnique
   */
  export type ServiceFocusRefFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceFocusRef
     */
    select?: ServiceFocusRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceFocusRef
     */
    omit?: ServiceFocusRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFocusRefInclude<ExtArgs> | null
    /**
     * Filter, which ServiceFocusRef to fetch.
     */
    where: ServiceFocusRefWhereUniqueInput
  }

  /**
   * ServiceFocusRef findUniqueOrThrow
   */
  export type ServiceFocusRefFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceFocusRef
     */
    select?: ServiceFocusRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceFocusRef
     */
    omit?: ServiceFocusRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFocusRefInclude<ExtArgs> | null
    /**
     * Filter, which ServiceFocusRef to fetch.
     */
    where: ServiceFocusRefWhereUniqueInput
  }

  /**
   * ServiceFocusRef findFirst
   */
  export type ServiceFocusRefFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceFocusRef
     */
    select?: ServiceFocusRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceFocusRef
     */
    omit?: ServiceFocusRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFocusRefInclude<ExtArgs> | null
    /**
     * Filter, which ServiceFocusRef to fetch.
     */
    where?: ServiceFocusRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceFocusRefs to fetch.
     */
    orderBy?: ServiceFocusRefOrderByWithRelationInput | ServiceFocusRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceFocusRefs.
     */
    cursor?: ServiceFocusRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceFocusRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceFocusRefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceFocusRefs.
     */
    distinct?: ServiceFocusRefScalarFieldEnum | ServiceFocusRefScalarFieldEnum[]
  }

  /**
   * ServiceFocusRef findFirstOrThrow
   */
  export type ServiceFocusRefFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceFocusRef
     */
    select?: ServiceFocusRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceFocusRef
     */
    omit?: ServiceFocusRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFocusRefInclude<ExtArgs> | null
    /**
     * Filter, which ServiceFocusRef to fetch.
     */
    where?: ServiceFocusRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceFocusRefs to fetch.
     */
    orderBy?: ServiceFocusRefOrderByWithRelationInput | ServiceFocusRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceFocusRefs.
     */
    cursor?: ServiceFocusRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceFocusRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceFocusRefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceFocusRefs.
     */
    distinct?: ServiceFocusRefScalarFieldEnum | ServiceFocusRefScalarFieldEnum[]
  }

  /**
   * ServiceFocusRef findMany
   */
  export type ServiceFocusRefFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceFocusRef
     */
    select?: ServiceFocusRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceFocusRef
     */
    omit?: ServiceFocusRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFocusRefInclude<ExtArgs> | null
    /**
     * Filter, which ServiceFocusRefs to fetch.
     */
    where?: ServiceFocusRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceFocusRefs to fetch.
     */
    orderBy?: ServiceFocusRefOrderByWithRelationInput | ServiceFocusRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceFocusRefs.
     */
    cursor?: ServiceFocusRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceFocusRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceFocusRefs.
     */
    skip?: number
    distinct?: ServiceFocusRefScalarFieldEnum | ServiceFocusRefScalarFieldEnum[]
  }

  /**
   * ServiceFocusRef create
   */
  export type ServiceFocusRefCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceFocusRef
     */
    select?: ServiceFocusRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceFocusRef
     */
    omit?: ServiceFocusRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFocusRefInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceFocusRef.
     */
    data: XOR<ServiceFocusRefCreateInput, ServiceFocusRefUncheckedCreateInput>
  }

  /**
   * ServiceFocusRef createMany
   */
  export type ServiceFocusRefCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceFocusRefs.
     */
    data: ServiceFocusRefCreateManyInput | ServiceFocusRefCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceFocusRef createManyAndReturn
   */
  export type ServiceFocusRefCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceFocusRef
     */
    select?: ServiceFocusRefSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceFocusRef
     */
    omit?: ServiceFocusRefOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceFocusRefs.
     */
    data: ServiceFocusRefCreateManyInput | ServiceFocusRefCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceFocusRef update
   */
  export type ServiceFocusRefUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceFocusRef
     */
    select?: ServiceFocusRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceFocusRef
     */
    omit?: ServiceFocusRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFocusRefInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceFocusRef.
     */
    data: XOR<ServiceFocusRefUpdateInput, ServiceFocusRefUncheckedUpdateInput>
    /**
     * Choose, which ServiceFocusRef to update.
     */
    where: ServiceFocusRefWhereUniqueInput
  }

  /**
   * ServiceFocusRef updateMany
   */
  export type ServiceFocusRefUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceFocusRefs.
     */
    data: XOR<ServiceFocusRefUpdateManyMutationInput, ServiceFocusRefUncheckedUpdateManyInput>
    /**
     * Filter which ServiceFocusRefs to update
     */
    where?: ServiceFocusRefWhereInput
    /**
     * Limit how many ServiceFocusRefs to update.
     */
    limit?: number
  }

  /**
   * ServiceFocusRef updateManyAndReturn
   */
  export type ServiceFocusRefUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceFocusRef
     */
    select?: ServiceFocusRefSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceFocusRef
     */
    omit?: ServiceFocusRefOmit<ExtArgs> | null
    /**
     * The data used to update ServiceFocusRefs.
     */
    data: XOR<ServiceFocusRefUpdateManyMutationInput, ServiceFocusRefUncheckedUpdateManyInput>
    /**
     * Filter which ServiceFocusRefs to update
     */
    where?: ServiceFocusRefWhereInput
    /**
     * Limit how many ServiceFocusRefs to update.
     */
    limit?: number
  }

  /**
   * ServiceFocusRef upsert
   */
  export type ServiceFocusRefUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceFocusRef
     */
    select?: ServiceFocusRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceFocusRef
     */
    omit?: ServiceFocusRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFocusRefInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceFocusRef to update in case it exists.
     */
    where: ServiceFocusRefWhereUniqueInput
    /**
     * In case the ServiceFocusRef found by the `where` argument doesn't exist, create a new ServiceFocusRef with this data.
     */
    create: XOR<ServiceFocusRefCreateInput, ServiceFocusRefUncheckedCreateInput>
    /**
     * In case the ServiceFocusRef was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceFocusRefUpdateInput, ServiceFocusRefUncheckedUpdateInput>
  }

  /**
   * ServiceFocusRef delete
   */
  export type ServiceFocusRefDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceFocusRef
     */
    select?: ServiceFocusRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceFocusRef
     */
    omit?: ServiceFocusRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFocusRefInclude<ExtArgs> | null
    /**
     * Filter which ServiceFocusRef to delete.
     */
    where: ServiceFocusRefWhereUniqueInput
  }

  /**
   * ServiceFocusRef deleteMany
   */
  export type ServiceFocusRefDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceFocusRefs to delete
     */
    where?: ServiceFocusRefWhereInput
    /**
     * Limit how many ServiceFocusRefs to delete.
     */
    limit?: number
  }

  /**
   * ServiceFocusRef.mentee_service_focus
   */
  export type ServiceFocusRef$mentee_service_focusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeServiceFocus
     */
    select?: MenteeServiceFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeServiceFocus
     */
    omit?: MenteeServiceFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeServiceFocusInclude<ExtArgs> | null
    where?: MenteeServiceFocusWhereInput
    orderBy?: MenteeServiceFocusOrderByWithRelationInput | MenteeServiceFocusOrderByWithRelationInput[]
    cursor?: MenteeServiceFocusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenteeServiceFocusScalarFieldEnum | MenteeServiceFocusScalarFieldEnum[]
  }

  /**
   * ServiceFocusRef without action
   */
  export type ServiceFocusRefDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceFocusRef
     */
    select?: ServiceFocusRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceFocusRef
     */
    omit?: ServiceFocusRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFocusRefInclude<ExtArgs> | null
  }


  /**
   * Model LanguageRef
   */

  export type AggregateLanguageRef = {
    _count: LanguageRefCountAggregateOutputType | null
    _avg: LanguageRefAvgAggregateOutputType | null
    _sum: LanguageRefSumAggregateOutputType | null
    _min: LanguageRefMinAggregateOutputType | null
    _max: LanguageRefMaxAggregateOutputType | null
  }

  export type LanguageRefAvgAggregateOutputType = {
    sort_order: number | null
  }

  export type LanguageRefSumAggregateOutputType = {
    sort_order: number | null
  }

  export type LanguageRefMinAggregateOutputType = {
    id: string | null
    label: string | null
    active: boolean | null
    sort_order: number | null
  }

  export type LanguageRefMaxAggregateOutputType = {
    id: string | null
    label: string | null
    active: boolean | null
    sort_order: number | null
  }

  export type LanguageRefCountAggregateOutputType = {
    id: number
    label: number
    active: number
    sort_order: number
    _all: number
  }


  export type LanguageRefAvgAggregateInputType = {
    sort_order?: true
  }

  export type LanguageRefSumAggregateInputType = {
    sort_order?: true
  }

  export type LanguageRefMinAggregateInputType = {
    id?: true
    label?: true
    active?: true
    sort_order?: true
  }

  export type LanguageRefMaxAggregateInputType = {
    id?: true
    label?: true
    active?: true
    sort_order?: true
  }

  export type LanguageRefCountAggregateInputType = {
    id?: true
    label?: true
    active?: true
    sort_order?: true
    _all?: true
  }

  export type LanguageRefAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LanguageRef to aggregate.
     */
    where?: LanguageRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LanguageRefs to fetch.
     */
    orderBy?: LanguageRefOrderByWithRelationInput | LanguageRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LanguageRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LanguageRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LanguageRefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LanguageRefs
    **/
    _count?: true | LanguageRefCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LanguageRefAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LanguageRefSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LanguageRefMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LanguageRefMaxAggregateInputType
  }

  export type GetLanguageRefAggregateType<T extends LanguageRefAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguageRef]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguageRef[P]>
      : GetScalarType<T[P], AggregateLanguageRef[P]>
  }




  export type LanguageRefGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguageRefWhereInput
    orderBy?: LanguageRefOrderByWithAggregationInput | LanguageRefOrderByWithAggregationInput[]
    by: LanguageRefScalarFieldEnum[] | LanguageRefScalarFieldEnum
    having?: LanguageRefScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LanguageRefCountAggregateInputType | true
    _avg?: LanguageRefAvgAggregateInputType
    _sum?: LanguageRefSumAggregateInputType
    _min?: LanguageRefMinAggregateInputType
    _max?: LanguageRefMaxAggregateInputType
  }

  export type LanguageRefGroupByOutputType = {
    id: string
    label: string
    active: boolean
    sort_order: number
    _count: LanguageRefCountAggregateOutputType | null
    _avg: LanguageRefAvgAggregateOutputType | null
    _sum: LanguageRefSumAggregateOutputType | null
    _min: LanguageRefMinAggregateOutputType | null
    _max: LanguageRefMaxAggregateOutputType | null
  }

  type GetLanguageRefGroupByPayload<T extends LanguageRefGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LanguageRefGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LanguageRefGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguageRefGroupByOutputType[P]>
            : GetScalarType<T[P], LanguageRefGroupByOutputType[P]>
        }
      >
    >


  export type LanguageRefSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    active?: boolean
    sort_order?: boolean
    mentee_languages_ref?: boolean | LanguageRef$mentee_languages_refArgs<ExtArgs>
    _count?: boolean | LanguageRefCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["languageRef"]>

  export type LanguageRefSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    active?: boolean
    sort_order?: boolean
  }, ExtArgs["result"]["languageRef"]>

  export type LanguageRefSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    active?: boolean
    sort_order?: boolean
  }, ExtArgs["result"]["languageRef"]>

  export type LanguageRefSelectScalar = {
    id?: boolean
    label?: boolean
    active?: boolean
    sort_order?: boolean
  }

  export type LanguageRefOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "active" | "sort_order", ExtArgs["result"]["languageRef"]>
  export type LanguageRefInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentee_languages_ref?: boolean | LanguageRef$mentee_languages_refArgs<ExtArgs>
    _count?: boolean | LanguageRefCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LanguageRefIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LanguageRefIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LanguageRefPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LanguageRef"
    objects: {
      mentee_languages_ref: Prisma.$MenteeLanguageRefPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      label: string
      active: boolean
      sort_order: number
    }, ExtArgs["result"]["languageRef"]>
    composites: {}
  }

  type LanguageRefGetPayload<S extends boolean | null | undefined | LanguageRefDefaultArgs> = $Result.GetResult<Prisma.$LanguageRefPayload, S>

  type LanguageRefCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LanguageRefFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LanguageRefCountAggregateInputType | true
    }

  export interface LanguageRefDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LanguageRef'], meta: { name: 'LanguageRef' } }
    /**
     * Find zero or one LanguageRef that matches the filter.
     * @param {LanguageRefFindUniqueArgs} args - Arguments to find a LanguageRef
     * @example
     * // Get one LanguageRef
     * const languageRef = await prisma.languageRef.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LanguageRefFindUniqueArgs>(args: SelectSubset<T, LanguageRefFindUniqueArgs<ExtArgs>>): Prisma__LanguageRefClient<$Result.GetResult<Prisma.$LanguageRefPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LanguageRef that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LanguageRefFindUniqueOrThrowArgs} args - Arguments to find a LanguageRef
     * @example
     * // Get one LanguageRef
     * const languageRef = await prisma.languageRef.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LanguageRefFindUniqueOrThrowArgs>(args: SelectSubset<T, LanguageRefFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LanguageRefClient<$Result.GetResult<Prisma.$LanguageRefPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LanguageRef that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageRefFindFirstArgs} args - Arguments to find a LanguageRef
     * @example
     * // Get one LanguageRef
     * const languageRef = await prisma.languageRef.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LanguageRefFindFirstArgs>(args?: SelectSubset<T, LanguageRefFindFirstArgs<ExtArgs>>): Prisma__LanguageRefClient<$Result.GetResult<Prisma.$LanguageRefPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LanguageRef that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageRefFindFirstOrThrowArgs} args - Arguments to find a LanguageRef
     * @example
     * // Get one LanguageRef
     * const languageRef = await prisma.languageRef.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LanguageRefFindFirstOrThrowArgs>(args?: SelectSubset<T, LanguageRefFindFirstOrThrowArgs<ExtArgs>>): Prisma__LanguageRefClient<$Result.GetResult<Prisma.$LanguageRefPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LanguageRefs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageRefFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LanguageRefs
     * const languageRefs = await prisma.languageRef.findMany()
     * 
     * // Get first 10 LanguageRefs
     * const languageRefs = await prisma.languageRef.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const languageRefWithIdOnly = await prisma.languageRef.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LanguageRefFindManyArgs>(args?: SelectSubset<T, LanguageRefFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguageRefPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LanguageRef.
     * @param {LanguageRefCreateArgs} args - Arguments to create a LanguageRef.
     * @example
     * // Create one LanguageRef
     * const LanguageRef = await prisma.languageRef.create({
     *   data: {
     *     // ... data to create a LanguageRef
     *   }
     * })
     * 
     */
    create<T extends LanguageRefCreateArgs>(args: SelectSubset<T, LanguageRefCreateArgs<ExtArgs>>): Prisma__LanguageRefClient<$Result.GetResult<Prisma.$LanguageRefPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LanguageRefs.
     * @param {LanguageRefCreateManyArgs} args - Arguments to create many LanguageRefs.
     * @example
     * // Create many LanguageRefs
     * const languageRef = await prisma.languageRef.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LanguageRefCreateManyArgs>(args?: SelectSubset<T, LanguageRefCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LanguageRefs and returns the data saved in the database.
     * @param {LanguageRefCreateManyAndReturnArgs} args - Arguments to create many LanguageRefs.
     * @example
     * // Create many LanguageRefs
     * const languageRef = await prisma.languageRef.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LanguageRefs and only return the `id`
     * const languageRefWithIdOnly = await prisma.languageRef.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LanguageRefCreateManyAndReturnArgs>(args?: SelectSubset<T, LanguageRefCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguageRefPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LanguageRef.
     * @param {LanguageRefDeleteArgs} args - Arguments to delete one LanguageRef.
     * @example
     * // Delete one LanguageRef
     * const LanguageRef = await prisma.languageRef.delete({
     *   where: {
     *     // ... filter to delete one LanguageRef
     *   }
     * })
     * 
     */
    delete<T extends LanguageRefDeleteArgs>(args: SelectSubset<T, LanguageRefDeleteArgs<ExtArgs>>): Prisma__LanguageRefClient<$Result.GetResult<Prisma.$LanguageRefPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LanguageRef.
     * @param {LanguageRefUpdateArgs} args - Arguments to update one LanguageRef.
     * @example
     * // Update one LanguageRef
     * const languageRef = await prisma.languageRef.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LanguageRefUpdateArgs>(args: SelectSubset<T, LanguageRefUpdateArgs<ExtArgs>>): Prisma__LanguageRefClient<$Result.GetResult<Prisma.$LanguageRefPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LanguageRefs.
     * @param {LanguageRefDeleteManyArgs} args - Arguments to filter LanguageRefs to delete.
     * @example
     * // Delete a few LanguageRefs
     * const { count } = await prisma.languageRef.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LanguageRefDeleteManyArgs>(args?: SelectSubset<T, LanguageRefDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LanguageRefs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageRefUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LanguageRefs
     * const languageRef = await prisma.languageRef.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LanguageRefUpdateManyArgs>(args: SelectSubset<T, LanguageRefUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LanguageRefs and returns the data updated in the database.
     * @param {LanguageRefUpdateManyAndReturnArgs} args - Arguments to update many LanguageRefs.
     * @example
     * // Update many LanguageRefs
     * const languageRef = await prisma.languageRef.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LanguageRefs and only return the `id`
     * const languageRefWithIdOnly = await prisma.languageRef.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LanguageRefUpdateManyAndReturnArgs>(args: SelectSubset<T, LanguageRefUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguageRefPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LanguageRef.
     * @param {LanguageRefUpsertArgs} args - Arguments to update or create a LanguageRef.
     * @example
     * // Update or create a LanguageRef
     * const languageRef = await prisma.languageRef.upsert({
     *   create: {
     *     // ... data to create a LanguageRef
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LanguageRef we want to update
     *   }
     * })
     */
    upsert<T extends LanguageRefUpsertArgs>(args: SelectSubset<T, LanguageRefUpsertArgs<ExtArgs>>): Prisma__LanguageRefClient<$Result.GetResult<Prisma.$LanguageRefPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LanguageRefs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageRefCountArgs} args - Arguments to filter LanguageRefs to count.
     * @example
     * // Count the number of LanguageRefs
     * const count = await prisma.languageRef.count({
     *   where: {
     *     // ... the filter for the LanguageRefs we want to count
     *   }
     * })
    **/
    count<T extends LanguageRefCountArgs>(
      args?: Subset<T, LanguageRefCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguageRefCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LanguageRef.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageRefAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguageRefAggregateArgs>(args: Subset<T, LanguageRefAggregateArgs>): Prisma.PrismaPromise<GetLanguageRefAggregateType<T>>

    /**
     * Group by LanguageRef.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageRefGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LanguageRefGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LanguageRefGroupByArgs['orderBy'] }
        : { orderBy?: LanguageRefGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LanguageRefGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguageRefGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LanguageRef model
   */
  readonly fields: LanguageRefFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LanguageRef.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LanguageRefClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mentee_languages_ref<T extends LanguageRef$mentee_languages_refArgs<ExtArgs> = {}>(args?: Subset<T, LanguageRef$mentee_languages_refArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteeLanguageRefPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LanguageRef model
   */
  interface LanguageRefFieldRefs {
    readonly id: FieldRef<"LanguageRef", 'String'>
    readonly label: FieldRef<"LanguageRef", 'String'>
    readonly active: FieldRef<"LanguageRef", 'Boolean'>
    readonly sort_order: FieldRef<"LanguageRef", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LanguageRef findUnique
   */
  export type LanguageRefFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageRef
     */
    select?: LanguageRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageRef
     */
    omit?: LanguageRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageRefInclude<ExtArgs> | null
    /**
     * Filter, which LanguageRef to fetch.
     */
    where: LanguageRefWhereUniqueInput
  }

  /**
   * LanguageRef findUniqueOrThrow
   */
  export type LanguageRefFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageRef
     */
    select?: LanguageRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageRef
     */
    omit?: LanguageRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageRefInclude<ExtArgs> | null
    /**
     * Filter, which LanguageRef to fetch.
     */
    where: LanguageRefWhereUniqueInput
  }

  /**
   * LanguageRef findFirst
   */
  export type LanguageRefFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageRef
     */
    select?: LanguageRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageRef
     */
    omit?: LanguageRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageRefInclude<ExtArgs> | null
    /**
     * Filter, which LanguageRef to fetch.
     */
    where?: LanguageRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LanguageRefs to fetch.
     */
    orderBy?: LanguageRefOrderByWithRelationInput | LanguageRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LanguageRefs.
     */
    cursor?: LanguageRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LanguageRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LanguageRefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LanguageRefs.
     */
    distinct?: LanguageRefScalarFieldEnum | LanguageRefScalarFieldEnum[]
  }

  /**
   * LanguageRef findFirstOrThrow
   */
  export type LanguageRefFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageRef
     */
    select?: LanguageRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageRef
     */
    omit?: LanguageRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageRefInclude<ExtArgs> | null
    /**
     * Filter, which LanguageRef to fetch.
     */
    where?: LanguageRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LanguageRefs to fetch.
     */
    orderBy?: LanguageRefOrderByWithRelationInput | LanguageRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LanguageRefs.
     */
    cursor?: LanguageRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LanguageRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LanguageRefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LanguageRefs.
     */
    distinct?: LanguageRefScalarFieldEnum | LanguageRefScalarFieldEnum[]
  }

  /**
   * LanguageRef findMany
   */
  export type LanguageRefFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageRef
     */
    select?: LanguageRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageRef
     */
    omit?: LanguageRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageRefInclude<ExtArgs> | null
    /**
     * Filter, which LanguageRefs to fetch.
     */
    where?: LanguageRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LanguageRefs to fetch.
     */
    orderBy?: LanguageRefOrderByWithRelationInput | LanguageRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LanguageRefs.
     */
    cursor?: LanguageRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LanguageRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LanguageRefs.
     */
    skip?: number
    distinct?: LanguageRefScalarFieldEnum | LanguageRefScalarFieldEnum[]
  }

  /**
   * LanguageRef create
   */
  export type LanguageRefCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageRef
     */
    select?: LanguageRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageRef
     */
    omit?: LanguageRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageRefInclude<ExtArgs> | null
    /**
     * The data needed to create a LanguageRef.
     */
    data: XOR<LanguageRefCreateInput, LanguageRefUncheckedCreateInput>
  }

  /**
   * LanguageRef createMany
   */
  export type LanguageRefCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LanguageRefs.
     */
    data: LanguageRefCreateManyInput | LanguageRefCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LanguageRef createManyAndReturn
   */
  export type LanguageRefCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageRef
     */
    select?: LanguageRefSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageRef
     */
    omit?: LanguageRefOmit<ExtArgs> | null
    /**
     * The data used to create many LanguageRefs.
     */
    data: LanguageRefCreateManyInput | LanguageRefCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LanguageRef update
   */
  export type LanguageRefUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageRef
     */
    select?: LanguageRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageRef
     */
    omit?: LanguageRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageRefInclude<ExtArgs> | null
    /**
     * The data needed to update a LanguageRef.
     */
    data: XOR<LanguageRefUpdateInput, LanguageRefUncheckedUpdateInput>
    /**
     * Choose, which LanguageRef to update.
     */
    where: LanguageRefWhereUniqueInput
  }

  /**
   * LanguageRef updateMany
   */
  export type LanguageRefUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LanguageRefs.
     */
    data: XOR<LanguageRefUpdateManyMutationInput, LanguageRefUncheckedUpdateManyInput>
    /**
     * Filter which LanguageRefs to update
     */
    where?: LanguageRefWhereInput
    /**
     * Limit how many LanguageRefs to update.
     */
    limit?: number
  }

  /**
   * LanguageRef updateManyAndReturn
   */
  export type LanguageRefUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageRef
     */
    select?: LanguageRefSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageRef
     */
    omit?: LanguageRefOmit<ExtArgs> | null
    /**
     * The data used to update LanguageRefs.
     */
    data: XOR<LanguageRefUpdateManyMutationInput, LanguageRefUncheckedUpdateManyInput>
    /**
     * Filter which LanguageRefs to update
     */
    where?: LanguageRefWhereInput
    /**
     * Limit how many LanguageRefs to update.
     */
    limit?: number
  }

  /**
   * LanguageRef upsert
   */
  export type LanguageRefUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageRef
     */
    select?: LanguageRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageRef
     */
    omit?: LanguageRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageRefInclude<ExtArgs> | null
    /**
     * The filter to search for the LanguageRef to update in case it exists.
     */
    where: LanguageRefWhereUniqueInput
    /**
     * In case the LanguageRef found by the `where` argument doesn't exist, create a new LanguageRef with this data.
     */
    create: XOR<LanguageRefCreateInput, LanguageRefUncheckedCreateInput>
    /**
     * In case the LanguageRef was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LanguageRefUpdateInput, LanguageRefUncheckedUpdateInput>
  }

  /**
   * LanguageRef delete
   */
  export type LanguageRefDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageRef
     */
    select?: LanguageRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageRef
     */
    omit?: LanguageRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageRefInclude<ExtArgs> | null
    /**
     * Filter which LanguageRef to delete.
     */
    where: LanguageRefWhereUniqueInput
  }

  /**
   * LanguageRef deleteMany
   */
  export type LanguageRefDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LanguageRefs to delete
     */
    where?: LanguageRefWhereInput
    /**
     * Limit how many LanguageRefs to delete.
     */
    limit?: number
  }

  /**
   * LanguageRef.mentee_languages_ref
   */
  export type LanguageRef$mentee_languages_refArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeLanguageRef
     */
    select?: MenteeLanguageRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeLanguageRef
     */
    omit?: MenteeLanguageRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeLanguageRefInclude<ExtArgs> | null
    where?: MenteeLanguageRefWhereInput
    orderBy?: MenteeLanguageRefOrderByWithRelationInput | MenteeLanguageRefOrderByWithRelationInput[]
    cursor?: MenteeLanguageRefWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenteeLanguageRefScalarFieldEnum | MenteeLanguageRefScalarFieldEnum[]
  }

  /**
   * LanguageRef without action
   */
  export type LanguageRefDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageRef
     */
    select?: LanguageRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageRef
     */
    omit?: LanguageRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageRefInclude<ExtArgs> | null
  }


  /**
   * Model DisciplineRef
   */

  export type AggregateDisciplineRef = {
    _count: DisciplineRefCountAggregateOutputType | null
    _avg: DisciplineRefAvgAggregateOutputType | null
    _sum: DisciplineRefSumAggregateOutputType | null
    _min: DisciplineRefMinAggregateOutputType | null
    _max: DisciplineRefMaxAggregateOutputType | null
  }

  export type DisciplineRefAvgAggregateOutputType = {
    sort_order: number | null
  }

  export type DisciplineRefSumAggregateOutputType = {
    sort_order: number | null
  }

  export type DisciplineRefMinAggregateOutputType = {
    id: string | null
    label: string | null
    active: boolean | null
    sort_order: number | null
  }

  export type DisciplineRefMaxAggregateOutputType = {
    id: string | null
    label: string | null
    active: boolean | null
    sort_order: number | null
  }

  export type DisciplineRefCountAggregateOutputType = {
    id: number
    label: number
    active: number
    sort_order: number
    _all: number
  }


  export type DisciplineRefAvgAggregateInputType = {
    sort_order?: true
  }

  export type DisciplineRefSumAggregateInputType = {
    sort_order?: true
  }

  export type DisciplineRefMinAggregateInputType = {
    id?: true
    label?: true
    active?: true
    sort_order?: true
  }

  export type DisciplineRefMaxAggregateInputType = {
    id?: true
    label?: true
    active?: true
    sort_order?: true
  }

  export type DisciplineRefCountAggregateInputType = {
    id?: true
    label?: true
    active?: true
    sort_order?: true
    _all?: true
  }

  export type DisciplineRefAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisciplineRef to aggregate.
     */
    where?: DisciplineRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisciplineRefs to fetch.
     */
    orderBy?: DisciplineRefOrderByWithRelationInput | DisciplineRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DisciplineRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisciplineRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisciplineRefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DisciplineRefs
    **/
    _count?: true | DisciplineRefCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DisciplineRefAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DisciplineRefSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisciplineRefMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisciplineRefMaxAggregateInputType
  }

  export type GetDisciplineRefAggregateType<T extends DisciplineRefAggregateArgs> = {
        [P in keyof T & keyof AggregateDisciplineRef]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDisciplineRef[P]>
      : GetScalarType<T[P], AggregateDisciplineRef[P]>
  }




  export type DisciplineRefGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisciplineRefWhereInput
    orderBy?: DisciplineRefOrderByWithAggregationInput | DisciplineRefOrderByWithAggregationInput[]
    by: DisciplineRefScalarFieldEnum[] | DisciplineRefScalarFieldEnum
    having?: DisciplineRefScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisciplineRefCountAggregateInputType | true
    _avg?: DisciplineRefAvgAggregateInputType
    _sum?: DisciplineRefSumAggregateInputType
    _min?: DisciplineRefMinAggregateInputType
    _max?: DisciplineRefMaxAggregateInputType
  }

  export type DisciplineRefGroupByOutputType = {
    id: string
    label: string
    active: boolean
    sort_order: number
    _count: DisciplineRefCountAggregateOutputType | null
    _avg: DisciplineRefAvgAggregateOutputType | null
    _sum: DisciplineRefSumAggregateOutputType | null
    _min: DisciplineRefMinAggregateOutputType | null
    _max: DisciplineRefMaxAggregateOutputType | null
  }

  type GetDisciplineRefGroupByPayload<T extends DisciplineRefGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DisciplineRefGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisciplineRefGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisciplineRefGroupByOutputType[P]>
            : GetScalarType<T[P], DisciplineRefGroupByOutputType[P]>
        }
      >
    >


  export type DisciplineRefSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    active?: boolean
    sort_order?: boolean
    mentee_disciplines_ref?: boolean | DisciplineRef$mentee_disciplines_refArgs<ExtArgs>
    _count?: boolean | DisciplineRefCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disciplineRef"]>

  export type DisciplineRefSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    active?: boolean
    sort_order?: boolean
  }, ExtArgs["result"]["disciplineRef"]>

  export type DisciplineRefSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    active?: boolean
    sort_order?: boolean
  }, ExtArgs["result"]["disciplineRef"]>

  export type DisciplineRefSelectScalar = {
    id?: boolean
    label?: boolean
    active?: boolean
    sort_order?: boolean
  }

  export type DisciplineRefOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "active" | "sort_order", ExtArgs["result"]["disciplineRef"]>
  export type DisciplineRefInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentee_disciplines_ref?: boolean | DisciplineRef$mentee_disciplines_refArgs<ExtArgs>
    _count?: boolean | DisciplineRefCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DisciplineRefIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DisciplineRefIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DisciplineRefPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DisciplineRef"
    objects: {
      mentee_disciplines_ref: Prisma.$MenteeDisciplineRefPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      label: string
      active: boolean
      sort_order: number
    }, ExtArgs["result"]["disciplineRef"]>
    composites: {}
  }

  type DisciplineRefGetPayload<S extends boolean | null | undefined | DisciplineRefDefaultArgs> = $Result.GetResult<Prisma.$DisciplineRefPayload, S>

  type DisciplineRefCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DisciplineRefFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DisciplineRefCountAggregateInputType | true
    }

  export interface DisciplineRefDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DisciplineRef'], meta: { name: 'DisciplineRef' } }
    /**
     * Find zero or one DisciplineRef that matches the filter.
     * @param {DisciplineRefFindUniqueArgs} args - Arguments to find a DisciplineRef
     * @example
     * // Get one DisciplineRef
     * const disciplineRef = await prisma.disciplineRef.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DisciplineRefFindUniqueArgs>(args: SelectSubset<T, DisciplineRefFindUniqueArgs<ExtArgs>>): Prisma__DisciplineRefClient<$Result.GetResult<Prisma.$DisciplineRefPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DisciplineRef that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DisciplineRefFindUniqueOrThrowArgs} args - Arguments to find a DisciplineRef
     * @example
     * // Get one DisciplineRef
     * const disciplineRef = await prisma.disciplineRef.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DisciplineRefFindUniqueOrThrowArgs>(args: SelectSubset<T, DisciplineRefFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DisciplineRefClient<$Result.GetResult<Prisma.$DisciplineRefPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisciplineRef that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisciplineRefFindFirstArgs} args - Arguments to find a DisciplineRef
     * @example
     * // Get one DisciplineRef
     * const disciplineRef = await prisma.disciplineRef.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DisciplineRefFindFirstArgs>(args?: SelectSubset<T, DisciplineRefFindFirstArgs<ExtArgs>>): Prisma__DisciplineRefClient<$Result.GetResult<Prisma.$DisciplineRefPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisciplineRef that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisciplineRefFindFirstOrThrowArgs} args - Arguments to find a DisciplineRef
     * @example
     * // Get one DisciplineRef
     * const disciplineRef = await prisma.disciplineRef.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DisciplineRefFindFirstOrThrowArgs>(args?: SelectSubset<T, DisciplineRefFindFirstOrThrowArgs<ExtArgs>>): Prisma__DisciplineRefClient<$Result.GetResult<Prisma.$DisciplineRefPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DisciplineRefs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisciplineRefFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DisciplineRefs
     * const disciplineRefs = await prisma.disciplineRef.findMany()
     * 
     * // Get first 10 DisciplineRefs
     * const disciplineRefs = await prisma.disciplineRef.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const disciplineRefWithIdOnly = await prisma.disciplineRef.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DisciplineRefFindManyArgs>(args?: SelectSubset<T, DisciplineRefFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisciplineRefPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DisciplineRef.
     * @param {DisciplineRefCreateArgs} args - Arguments to create a DisciplineRef.
     * @example
     * // Create one DisciplineRef
     * const DisciplineRef = await prisma.disciplineRef.create({
     *   data: {
     *     // ... data to create a DisciplineRef
     *   }
     * })
     * 
     */
    create<T extends DisciplineRefCreateArgs>(args: SelectSubset<T, DisciplineRefCreateArgs<ExtArgs>>): Prisma__DisciplineRefClient<$Result.GetResult<Prisma.$DisciplineRefPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DisciplineRefs.
     * @param {DisciplineRefCreateManyArgs} args - Arguments to create many DisciplineRefs.
     * @example
     * // Create many DisciplineRefs
     * const disciplineRef = await prisma.disciplineRef.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DisciplineRefCreateManyArgs>(args?: SelectSubset<T, DisciplineRefCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DisciplineRefs and returns the data saved in the database.
     * @param {DisciplineRefCreateManyAndReturnArgs} args - Arguments to create many DisciplineRefs.
     * @example
     * // Create many DisciplineRefs
     * const disciplineRef = await prisma.disciplineRef.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DisciplineRefs and only return the `id`
     * const disciplineRefWithIdOnly = await prisma.disciplineRef.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DisciplineRefCreateManyAndReturnArgs>(args?: SelectSubset<T, DisciplineRefCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisciplineRefPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DisciplineRef.
     * @param {DisciplineRefDeleteArgs} args - Arguments to delete one DisciplineRef.
     * @example
     * // Delete one DisciplineRef
     * const DisciplineRef = await prisma.disciplineRef.delete({
     *   where: {
     *     // ... filter to delete one DisciplineRef
     *   }
     * })
     * 
     */
    delete<T extends DisciplineRefDeleteArgs>(args: SelectSubset<T, DisciplineRefDeleteArgs<ExtArgs>>): Prisma__DisciplineRefClient<$Result.GetResult<Prisma.$DisciplineRefPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DisciplineRef.
     * @param {DisciplineRefUpdateArgs} args - Arguments to update one DisciplineRef.
     * @example
     * // Update one DisciplineRef
     * const disciplineRef = await prisma.disciplineRef.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DisciplineRefUpdateArgs>(args: SelectSubset<T, DisciplineRefUpdateArgs<ExtArgs>>): Prisma__DisciplineRefClient<$Result.GetResult<Prisma.$DisciplineRefPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DisciplineRefs.
     * @param {DisciplineRefDeleteManyArgs} args - Arguments to filter DisciplineRefs to delete.
     * @example
     * // Delete a few DisciplineRefs
     * const { count } = await prisma.disciplineRef.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DisciplineRefDeleteManyArgs>(args?: SelectSubset<T, DisciplineRefDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisciplineRefs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisciplineRefUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DisciplineRefs
     * const disciplineRef = await prisma.disciplineRef.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DisciplineRefUpdateManyArgs>(args: SelectSubset<T, DisciplineRefUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisciplineRefs and returns the data updated in the database.
     * @param {DisciplineRefUpdateManyAndReturnArgs} args - Arguments to update many DisciplineRefs.
     * @example
     * // Update many DisciplineRefs
     * const disciplineRef = await prisma.disciplineRef.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DisciplineRefs and only return the `id`
     * const disciplineRefWithIdOnly = await prisma.disciplineRef.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DisciplineRefUpdateManyAndReturnArgs>(args: SelectSubset<T, DisciplineRefUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisciplineRefPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DisciplineRef.
     * @param {DisciplineRefUpsertArgs} args - Arguments to update or create a DisciplineRef.
     * @example
     * // Update or create a DisciplineRef
     * const disciplineRef = await prisma.disciplineRef.upsert({
     *   create: {
     *     // ... data to create a DisciplineRef
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DisciplineRef we want to update
     *   }
     * })
     */
    upsert<T extends DisciplineRefUpsertArgs>(args: SelectSubset<T, DisciplineRefUpsertArgs<ExtArgs>>): Prisma__DisciplineRefClient<$Result.GetResult<Prisma.$DisciplineRefPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DisciplineRefs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisciplineRefCountArgs} args - Arguments to filter DisciplineRefs to count.
     * @example
     * // Count the number of DisciplineRefs
     * const count = await prisma.disciplineRef.count({
     *   where: {
     *     // ... the filter for the DisciplineRefs we want to count
     *   }
     * })
    **/
    count<T extends DisciplineRefCountArgs>(
      args?: Subset<T, DisciplineRefCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisciplineRefCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DisciplineRef.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisciplineRefAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisciplineRefAggregateArgs>(args: Subset<T, DisciplineRefAggregateArgs>): Prisma.PrismaPromise<GetDisciplineRefAggregateType<T>>

    /**
     * Group by DisciplineRef.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisciplineRefGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DisciplineRefGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DisciplineRefGroupByArgs['orderBy'] }
        : { orderBy?: DisciplineRefGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DisciplineRefGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisciplineRefGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DisciplineRef model
   */
  readonly fields: DisciplineRefFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DisciplineRef.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DisciplineRefClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mentee_disciplines_ref<T extends DisciplineRef$mentee_disciplines_refArgs<ExtArgs> = {}>(args?: Subset<T, DisciplineRef$mentee_disciplines_refArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteeDisciplineRefPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DisciplineRef model
   */
  interface DisciplineRefFieldRefs {
    readonly id: FieldRef<"DisciplineRef", 'String'>
    readonly label: FieldRef<"DisciplineRef", 'String'>
    readonly active: FieldRef<"DisciplineRef", 'Boolean'>
    readonly sort_order: FieldRef<"DisciplineRef", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DisciplineRef findUnique
   */
  export type DisciplineRefFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplineRef
     */
    select?: DisciplineRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisciplineRef
     */
    omit?: DisciplineRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplineRefInclude<ExtArgs> | null
    /**
     * Filter, which DisciplineRef to fetch.
     */
    where: DisciplineRefWhereUniqueInput
  }

  /**
   * DisciplineRef findUniqueOrThrow
   */
  export type DisciplineRefFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplineRef
     */
    select?: DisciplineRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisciplineRef
     */
    omit?: DisciplineRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplineRefInclude<ExtArgs> | null
    /**
     * Filter, which DisciplineRef to fetch.
     */
    where: DisciplineRefWhereUniqueInput
  }

  /**
   * DisciplineRef findFirst
   */
  export type DisciplineRefFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplineRef
     */
    select?: DisciplineRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisciplineRef
     */
    omit?: DisciplineRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplineRefInclude<ExtArgs> | null
    /**
     * Filter, which DisciplineRef to fetch.
     */
    where?: DisciplineRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisciplineRefs to fetch.
     */
    orderBy?: DisciplineRefOrderByWithRelationInput | DisciplineRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisciplineRefs.
     */
    cursor?: DisciplineRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisciplineRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisciplineRefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisciplineRefs.
     */
    distinct?: DisciplineRefScalarFieldEnum | DisciplineRefScalarFieldEnum[]
  }

  /**
   * DisciplineRef findFirstOrThrow
   */
  export type DisciplineRefFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplineRef
     */
    select?: DisciplineRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisciplineRef
     */
    omit?: DisciplineRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplineRefInclude<ExtArgs> | null
    /**
     * Filter, which DisciplineRef to fetch.
     */
    where?: DisciplineRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisciplineRefs to fetch.
     */
    orderBy?: DisciplineRefOrderByWithRelationInput | DisciplineRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisciplineRefs.
     */
    cursor?: DisciplineRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisciplineRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisciplineRefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisciplineRefs.
     */
    distinct?: DisciplineRefScalarFieldEnum | DisciplineRefScalarFieldEnum[]
  }

  /**
   * DisciplineRef findMany
   */
  export type DisciplineRefFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplineRef
     */
    select?: DisciplineRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisciplineRef
     */
    omit?: DisciplineRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplineRefInclude<ExtArgs> | null
    /**
     * Filter, which DisciplineRefs to fetch.
     */
    where?: DisciplineRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisciplineRefs to fetch.
     */
    orderBy?: DisciplineRefOrderByWithRelationInput | DisciplineRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DisciplineRefs.
     */
    cursor?: DisciplineRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisciplineRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisciplineRefs.
     */
    skip?: number
    distinct?: DisciplineRefScalarFieldEnum | DisciplineRefScalarFieldEnum[]
  }

  /**
   * DisciplineRef create
   */
  export type DisciplineRefCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplineRef
     */
    select?: DisciplineRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisciplineRef
     */
    omit?: DisciplineRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplineRefInclude<ExtArgs> | null
    /**
     * The data needed to create a DisciplineRef.
     */
    data: XOR<DisciplineRefCreateInput, DisciplineRefUncheckedCreateInput>
  }

  /**
   * DisciplineRef createMany
   */
  export type DisciplineRefCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DisciplineRefs.
     */
    data: DisciplineRefCreateManyInput | DisciplineRefCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DisciplineRef createManyAndReturn
   */
  export type DisciplineRefCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplineRef
     */
    select?: DisciplineRefSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DisciplineRef
     */
    omit?: DisciplineRefOmit<ExtArgs> | null
    /**
     * The data used to create many DisciplineRefs.
     */
    data: DisciplineRefCreateManyInput | DisciplineRefCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DisciplineRef update
   */
  export type DisciplineRefUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplineRef
     */
    select?: DisciplineRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisciplineRef
     */
    omit?: DisciplineRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplineRefInclude<ExtArgs> | null
    /**
     * The data needed to update a DisciplineRef.
     */
    data: XOR<DisciplineRefUpdateInput, DisciplineRefUncheckedUpdateInput>
    /**
     * Choose, which DisciplineRef to update.
     */
    where: DisciplineRefWhereUniqueInput
  }

  /**
   * DisciplineRef updateMany
   */
  export type DisciplineRefUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DisciplineRefs.
     */
    data: XOR<DisciplineRefUpdateManyMutationInput, DisciplineRefUncheckedUpdateManyInput>
    /**
     * Filter which DisciplineRefs to update
     */
    where?: DisciplineRefWhereInput
    /**
     * Limit how many DisciplineRefs to update.
     */
    limit?: number
  }

  /**
   * DisciplineRef updateManyAndReturn
   */
  export type DisciplineRefUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplineRef
     */
    select?: DisciplineRefSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DisciplineRef
     */
    omit?: DisciplineRefOmit<ExtArgs> | null
    /**
     * The data used to update DisciplineRefs.
     */
    data: XOR<DisciplineRefUpdateManyMutationInput, DisciplineRefUncheckedUpdateManyInput>
    /**
     * Filter which DisciplineRefs to update
     */
    where?: DisciplineRefWhereInput
    /**
     * Limit how many DisciplineRefs to update.
     */
    limit?: number
  }

  /**
   * DisciplineRef upsert
   */
  export type DisciplineRefUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplineRef
     */
    select?: DisciplineRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisciplineRef
     */
    omit?: DisciplineRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplineRefInclude<ExtArgs> | null
    /**
     * The filter to search for the DisciplineRef to update in case it exists.
     */
    where: DisciplineRefWhereUniqueInput
    /**
     * In case the DisciplineRef found by the `where` argument doesn't exist, create a new DisciplineRef with this data.
     */
    create: XOR<DisciplineRefCreateInput, DisciplineRefUncheckedCreateInput>
    /**
     * In case the DisciplineRef was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DisciplineRefUpdateInput, DisciplineRefUncheckedUpdateInput>
  }

  /**
   * DisciplineRef delete
   */
  export type DisciplineRefDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplineRef
     */
    select?: DisciplineRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisciplineRef
     */
    omit?: DisciplineRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplineRefInclude<ExtArgs> | null
    /**
     * Filter which DisciplineRef to delete.
     */
    where: DisciplineRefWhereUniqueInput
  }

  /**
   * DisciplineRef deleteMany
   */
  export type DisciplineRefDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisciplineRefs to delete
     */
    where?: DisciplineRefWhereInput
    /**
     * Limit how many DisciplineRefs to delete.
     */
    limit?: number
  }

  /**
   * DisciplineRef.mentee_disciplines_ref
   */
  export type DisciplineRef$mentee_disciplines_refArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeDisciplineRef
     */
    select?: MenteeDisciplineRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeDisciplineRef
     */
    omit?: MenteeDisciplineRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeDisciplineRefInclude<ExtArgs> | null
    where?: MenteeDisciplineRefWhereInput
    orderBy?: MenteeDisciplineRefOrderByWithRelationInput | MenteeDisciplineRefOrderByWithRelationInput[]
    cursor?: MenteeDisciplineRefWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenteeDisciplineRefScalarFieldEnum | MenteeDisciplineRefScalarFieldEnum[]
  }

  /**
   * DisciplineRef without action
   */
  export type DisciplineRefDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplineRef
     */
    select?: DisciplineRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisciplineRef
     */
    omit?: DisciplineRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplineRefInclude<ExtArgs> | null
  }


  /**
   * Model PreferenceRef
   */

  export type AggregatePreferenceRef = {
    _count: PreferenceRefCountAggregateOutputType | null
    _avg: PreferenceRefAvgAggregateOutputType | null
    _sum: PreferenceRefSumAggregateOutputType | null
    _min: PreferenceRefMinAggregateOutputType | null
    _max: PreferenceRefMaxAggregateOutputType | null
  }

  export type PreferenceRefAvgAggregateOutputType = {
    sort_order: number | null
  }

  export type PreferenceRefSumAggregateOutputType = {
    sort_order: number | null
  }

  export type PreferenceRefMinAggregateOutputType = {
    id: string | null
    label: string | null
    active: boolean | null
    sort_order: number | null
  }

  export type PreferenceRefMaxAggregateOutputType = {
    id: string | null
    label: string | null
    active: boolean | null
    sort_order: number | null
  }

  export type PreferenceRefCountAggregateOutputType = {
    id: number
    label: number
    active: number
    sort_order: number
    _all: number
  }


  export type PreferenceRefAvgAggregateInputType = {
    sort_order?: true
  }

  export type PreferenceRefSumAggregateInputType = {
    sort_order?: true
  }

  export type PreferenceRefMinAggregateInputType = {
    id?: true
    label?: true
    active?: true
    sort_order?: true
  }

  export type PreferenceRefMaxAggregateInputType = {
    id?: true
    label?: true
    active?: true
    sort_order?: true
  }

  export type PreferenceRefCountAggregateInputType = {
    id?: true
    label?: true
    active?: true
    sort_order?: true
    _all?: true
  }

  export type PreferenceRefAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PreferenceRef to aggregate.
     */
    where?: PreferenceRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreferenceRefs to fetch.
     */
    orderBy?: PreferenceRefOrderByWithRelationInput | PreferenceRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PreferenceRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreferenceRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreferenceRefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PreferenceRefs
    **/
    _count?: true | PreferenceRefCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PreferenceRefAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PreferenceRefSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PreferenceRefMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PreferenceRefMaxAggregateInputType
  }

  export type GetPreferenceRefAggregateType<T extends PreferenceRefAggregateArgs> = {
        [P in keyof T & keyof AggregatePreferenceRef]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePreferenceRef[P]>
      : GetScalarType<T[P], AggregatePreferenceRef[P]>
  }




  export type PreferenceRefGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreferenceRefWhereInput
    orderBy?: PreferenceRefOrderByWithAggregationInput | PreferenceRefOrderByWithAggregationInput[]
    by: PreferenceRefScalarFieldEnum[] | PreferenceRefScalarFieldEnum
    having?: PreferenceRefScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PreferenceRefCountAggregateInputType | true
    _avg?: PreferenceRefAvgAggregateInputType
    _sum?: PreferenceRefSumAggregateInputType
    _min?: PreferenceRefMinAggregateInputType
    _max?: PreferenceRefMaxAggregateInputType
  }

  export type PreferenceRefGroupByOutputType = {
    id: string
    label: string
    active: boolean
    sort_order: number
    _count: PreferenceRefCountAggregateOutputType | null
    _avg: PreferenceRefAvgAggregateOutputType | null
    _sum: PreferenceRefSumAggregateOutputType | null
    _min: PreferenceRefMinAggregateOutputType | null
    _max: PreferenceRefMaxAggregateOutputType | null
  }

  type GetPreferenceRefGroupByPayload<T extends PreferenceRefGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PreferenceRefGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PreferenceRefGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PreferenceRefGroupByOutputType[P]>
            : GetScalarType<T[P], PreferenceRefGroupByOutputType[P]>
        }
      >
    >


  export type PreferenceRefSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    active?: boolean
    sort_order?: boolean
    mentee_preferences_ref?: boolean | PreferenceRef$mentee_preferences_refArgs<ExtArgs>
    _count?: boolean | PreferenceRefCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preferenceRef"]>

  export type PreferenceRefSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    active?: boolean
    sort_order?: boolean
  }, ExtArgs["result"]["preferenceRef"]>

  export type PreferenceRefSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    active?: boolean
    sort_order?: boolean
  }, ExtArgs["result"]["preferenceRef"]>

  export type PreferenceRefSelectScalar = {
    id?: boolean
    label?: boolean
    active?: boolean
    sort_order?: boolean
  }

  export type PreferenceRefOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "active" | "sort_order", ExtArgs["result"]["preferenceRef"]>
  export type PreferenceRefInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentee_preferences_ref?: boolean | PreferenceRef$mentee_preferences_refArgs<ExtArgs>
    _count?: boolean | PreferenceRefCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PreferenceRefIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PreferenceRefIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PreferenceRefPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PreferenceRef"
    objects: {
      mentee_preferences_ref: Prisma.$MenteePreferenceRefPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      label: string
      active: boolean
      sort_order: number
    }, ExtArgs["result"]["preferenceRef"]>
    composites: {}
  }

  type PreferenceRefGetPayload<S extends boolean | null | undefined | PreferenceRefDefaultArgs> = $Result.GetResult<Prisma.$PreferenceRefPayload, S>

  type PreferenceRefCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PreferenceRefFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PreferenceRefCountAggregateInputType | true
    }

  export interface PreferenceRefDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PreferenceRef'], meta: { name: 'PreferenceRef' } }
    /**
     * Find zero or one PreferenceRef that matches the filter.
     * @param {PreferenceRefFindUniqueArgs} args - Arguments to find a PreferenceRef
     * @example
     * // Get one PreferenceRef
     * const preferenceRef = await prisma.preferenceRef.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PreferenceRefFindUniqueArgs>(args: SelectSubset<T, PreferenceRefFindUniqueArgs<ExtArgs>>): Prisma__PreferenceRefClient<$Result.GetResult<Prisma.$PreferenceRefPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PreferenceRef that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PreferenceRefFindUniqueOrThrowArgs} args - Arguments to find a PreferenceRef
     * @example
     * // Get one PreferenceRef
     * const preferenceRef = await prisma.preferenceRef.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PreferenceRefFindUniqueOrThrowArgs>(args: SelectSubset<T, PreferenceRefFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PreferenceRefClient<$Result.GetResult<Prisma.$PreferenceRefPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PreferenceRef that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferenceRefFindFirstArgs} args - Arguments to find a PreferenceRef
     * @example
     * // Get one PreferenceRef
     * const preferenceRef = await prisma.preferenceRef.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PreferenceRefFindFirstArgs>(args?: SelectSubset<T, PreferenceRefFindFirstArgs<ExtArgs>>): Prisma__PreferenceRefClient<$Result.GetResult<Prisma.$PreferenceRefPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PreferenceRef that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferenceRefFindFirstOrThrowArgs} args - Arguments to find a PreferenceRef
     * @example
     * // Get one PreferenceRef
     * const preferenceRef = await prisma.preferenceRef.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PreferenceRefFindFirstOrThrowArgs>(args?: SelectSubset<T, PreferenceRefFindFirstOrThrowArgs<ExtArgs>>): Prisma__PreferenceRefClient<$Result.GetResult<Prisma.$PreferenceRefPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PreferenceRefs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferenceRefFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PreferenceRefs
     * const preferenceRefs = await prisma.preferenceRef.findMany()
     * 
     * // Get first 10 PreferenceRefs
     * const preferenceRefs = await prisma.preferenceRef.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const preferenceRefWithIdOnly = await prisma.preferenceRef.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PreferenceRefFindManyArgs>(args?: SelectSubset<T, PreferenceRefFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreferenceRefPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PreferenceRef.
     * @param {PreferenceRefCreateArgs} args - Arguments to create a PreferenceRef.
     * @example
     * // Create one PreferenceRef
     * const PreferenceRef = await prisma.preferenceRef.create({
     *   data: {
     *     // ... data to create a PreferenceRef
     *   }
     * })
     * 
     */
    create<T extends PreferenceRefCreateArgs>(args: SelectSubset<T, PreferenceRefCreateArgs<ExtArgs>>): Prisma__PreferenceRefClient<$Result.GetResult<Prisma.$PreferenceRefPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PreferenceRefs.
     * @param {PreferenceRefCreateManyArgs} args - Arguments to create many PreferenceRefs.
     * @example
     * // Create many PreferenceRefs
     * const preferenceRef = await prisma.preferenceRef.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PreferenceRefCreateManyArgs>(args?: SelectSubset<T, PreferenceRefCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PreferenceRefs and returns the data saved in the database.
     * @param {PreferenceRefCreateManyAndReturnArgs} args - Arguments to create many PreferenceRefs.
     * @example
     * // Create many PreferenceRefs
     * const preferenceRef = await prisma.preferenceRef.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PreferenceRefs and only return the `id`
     * const preferenceRefWithIdOnly = await prisma.preferenceRef.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PreferenceRefCreateManyAndReturnArgs>(args?: SelectSubset<T, PreferenceRefCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreferenceRefPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PreferenceRef.
     * @param {PreferenceRefDeleteArgs} args - Arguments to delete one PreferenceRef.
     * @example
     * // Delete one PreferenceRef
     * const PreferenceRef = await prisma.preferenceRef.delete({
     *   where: {
     *     // ... filter to delete one PreferenceRef
     *   }
     * })
     * 
     */
    delete<T extends PreferenceRefDeleteArgs>(args: SelectSubset<T, PreferenceRefDeleteArgs<ExtArgs>>): Prisma__PreferenceRefClient<$Result.GetResult<Prisma.$PreferenceRefPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PreferenceRef.
     * @param {PreferenceRefUpdateArgs} args - Arguments to update one PreferenceRef.
     * @example
     * // Update one PreferenceRef
     * const preferenceRef = await prisma.preferenceRef.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PreferenceRefUpdateArgs>(args: SelectSubset<T, PreferenceRefUpdateArgs<ExtArgs>>): Prisma__PreferenceRefClient<$Result.GetResult<Prisma.$PreferenceRefPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PreferenceRefs.
     * @param {PreferenceRefDeleteManyArgs} args - Arguments to filter PreferenceRefs to delete.
     * @example
     * // Delete a few PreferenceRefs
     * const { count } = await prisma.preferenceRef.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PreferenceRefDeleteManyArgs>(args?: SelectSubset<T, PreferenceRefDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PreferenceRefs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferenceRefUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PreferenceRefs
     * const preferenceRef = await prisma.preferenceRef.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PreferenceRefUpdateManyArgs>(args: SelectSubset<T, PreferenceRefUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PreferenceRefs and returns the data updated in the database.
     * @param {PreferenceRefUpdateManyAndReturnArgs} args - Arguments to update many PreferenceRefs.
     * @example
     * // Update many PreferenceRefs
     * const preferenceRef = await prisma.preferenceRef.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PreferenceRefs and only return the `id`
     * const preferenceRefWithIdOnly = await prisma.preferenceRef.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PreferenceRefUpdateManyAndReturnArgs>(args: SelectSubset<T, PreferenceRefUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreferenceRefPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PreferenceRef.
     * @param {PreferenceRefUpsertArgs} args - Arguments to update or create a PreferenceRef.
     * @example
     * // Update or create a PreferenceRef
     * const preferenceRef = await prisma.preferenceRef.upsert({
     *   create: {
     *     // ... data to create a PreferenceRef
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PreferenceRef we want to update
     *   }
     * })
     */
    upsert<T extends PreferenceRefUpsertArgs>(args: SelectSubset<T, PreferenceRefUpsertArgs<ExtArgs>>): Prisma__PreferenceRefClient<$Result.GetResult<Prisma.$PreferenceRefPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PreferenceRefs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferenceRefCountArgs} args - Arguments to filter PreferenceRefs to count.
     * @example
     * // Count the number of PreferenceRefs
     * const count = await prisma.preferenceRef.count({
     *   where: {
     *     // ... the filter for the PreferenceRefs we want to count
     *   }
     * })
    **/
    count<T extends PreferenceRefCountArgs>(
      args?: Subset<T, PreferenceRefCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PreferenceRefCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PreferenceRef.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferenceRefAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PreferenceRefAggregateArgs>(args: Subset<T, PreferenceRefAggregateArgs>): Prisma.PrismaPromise<GetPreferenceRefAggregateType<T>>

    /**
     * Group by PreferenceRef.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferenceRefGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PreferenceRefGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PreferenceRefGroupByArgs['orderBy'] }
        : { orderBy?: PreferenceRefGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PreferenceRefGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPreferenceRefGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PreferenceRef model
   */
  readonly fields: PreferenceRefFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PreferenceRef.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PreferenceRefClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mentee_preferences_ref<T extends PreferenceRef$mentee_preferences_refArgs<ExtArgs> = {}>(args?: Subset<T, PreferenceRef$mentee_preferences_refArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteePreferenceRefPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PreferenceRef model
   */
  interface PreferenceRefFieldRefs {
    readonly id: FieldRef<"PreferenceRef", 'String'>
    readonly label: FieldRef<"PreferenceRef", 'String'>
    readonly active: FieldRef<"PreferenceRef", 'Boolean'>
    readonly sort_order: FieldRef<"PreferenceRef", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PreferenceRef findUnique
   */
  export type PreferenceRefFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferenceRef
     */
    select?: PreferenceRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreferenceRef
     */
    omit?: PreferenceRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenceRefInclude<ExtArgs> | null
    /**
     * Filter, which PreferenceRef to fetch.
     */
    where: PreferenceRefWhereUniqueInput
  }

  /**
   * PreferenceRef findUniqueOrThrow
   */
  export type PreferenceRefFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferenceRef
     */
    select?: PreferenceRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreferenceRef
     */
    omit?: PreferenceRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenceRefInclude<ExtArgs> | null
    /**
     * Filter, which PreferenceRef to fetch.
     */
    where: PreferenceRefWhereUniqueInput
  }

  /**
   * PreferenceRef findFirst
   */
  export type PreferenceRefFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferenceRef
     */
    select?: PreferenceRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreferenceRef
     */
    omit?: PreferenceRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenceRefInclude<ExtArgs> | null
    /**
     * Filter, which PreferenceRef to fetch.
     */
    where?: PreferenceRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreferenceRefs to fetch.
     */
    orderBy?: PreferenceRefOrderByWithRelationInput | PreferenceRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PreferenceRefs.
     */
    cursor?: PreferenceRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreferenceRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreferenceRefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PreferenceRefs.
     */
    distinct?: PreferenceRefScalarFieldEnum | PreferenceRefScalarFieldEnum[]
  }

  /**
   * PreferenceRef findFirstOrThrow
   */
  export type PreferenceRefFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferenceRef
     */
    select?: PreferenceRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreferenceRef
     */
    omit?: PreferenceRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenceRefInclude<ExtArgs> | null
    /**
     * Filter, which PreferenceRef to fetch.
     */
    where?: PreferenceRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreferenceRefs to fetch.
     */
    orderBy?: PreferenceRefOrderByWithRelationInput | PreferenceRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PreferenceRefs.
     */
    cursor?: PreferenceRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreferenceRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreferenceRefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PreferenceRefs.
     */
    distinct?: PreferenceRefScalarFieldEnum | PreferenceRefScalarFieldEnum[]
  }

  /**
   * PreferenceRef findMany
   */
  export type PreferenceRefFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferenceRef
     */
    select?: PreferenceRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreferenceRef
     */
    omit?: PreferenceRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenceRefInclude<ExtArgs> | null
    /**
     * Filter, which PreferenceRefs to fetch.
     */
    where?: PreferenceRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreferenceRefs to fetch.
     */
    orderBy?: PreferenceRefOrderByWithRelationInput | PreferenceRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PreferenceRefs.
     */
    cursor?: PreferenceRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreferenceRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreferenceRefs.
     */
    skip?: number
    distinct?: PreferenceRefScalarFieldEnum | PreferenceRefScalarFieldEnum[]
  }

  /**
   * PreferenceRef create
   */
  export type PreferenceRefCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferenceRef
     */
    select?: PreferenceRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreferenceRef
     */
    omit?: PreferenceRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenceRefInclude<ExtArgs> | null
    /**
     * The data needed to create a PreferenceRef.
     */
    data: XOR<PreferenceRefCreateInput, PreferenceRefUncheckedCreateInput>
  }

  /**
   * PreferenceRef createMany
   */
  export type PreferenceRefCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PreferenceRefs.
     */
    data: PreferenceRefCreateManyInput | PreferenceRefCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PreferenceRef createManyAndReturn
   */
  export type PreferenceRefCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferenceRef
     */
    select?: PreferenceRefSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PreferenceRef
     */
    omit?: PreferenceRefOmit<ExtArgs> | null
    /**
     * The data used to create many PreferenceRefs.
     */
    data: PreferenceRefCreateManyInput | PreferenceRefCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PreferenceRef update
   */
  export type PreferenceRefUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferenceRef
     */
    select?: PreferenceRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreferenceRef
     */
    omit?: PreferenceRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenceRefInclude<ExtArgs> | null
    /**
     * The data needed to update a PreferenceRef.
     */
    data: XOR<PreferenceRefUpdateInput, PreferenceRefUncheckedUpdateInput>
    /**
     * Choose, which PreferenceRef to update.
     */
    where: PreferenceRefWhereUniqueInput
  }

  /**
   * PreferenceRef updateMany
   */
  export type PreferenceRefUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PreferenceRefs.
     */
    data: XOR<PreferenceRefUpdateManyMutationInput, PreferenceRefUncheckedUpdateManyInput>
    /**
     * Filter which PreferenceRefs to update
     */
    where?: PreferenceRefWhereInput
    /**
     * Limit how many PreferenceRefs to update.
     */
    limit?: number
  }

  /**
   * PreferenceRef updateManyAndReturn
   */
  export type PreferenceRefUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferenceRef
     */
    select?: PreferenceRefSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PreferenceRef
     */
    omit?: PreferenceRefOmit<ExtArgs> | null
    /**
     * The data used to update PreferenceRefs.
     */
    data: XOR<PreferenceRefUpdateManyMutationInput, PreferenceRefUncheckedUpdateManyInput>
    /**
     * Filter which PreferenceRefs to update
     */
    where?: PreferenceRefWhereInput
    /**
     * Limit how many PreferenceRefs to update.
     */
    limit?: number
  }

  /**
   * PreferenceRef upsert
   */
  export type PreferenceRefUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferenceRef
     */
    select?: PreferenceRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreferenceRef
     */
    omit?: PreferenceRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenceRefInclude<ExtArgs> | null
    /**
     * The filter to search for the PreferenceRef to update in case it exists.
     */
    where: PreferenceRefWhereUniqueInput
    /**
     * In case the PreferenceRef found by the `where` argument doesn't exist, create a new PreferenceRef with this data.
     */
    create: XOR<PreferenceRefCreateInput, PreferenceRefUncheckedCreateInput>
    /**
     * In case the PreferenceRef was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PreferenceRefUpdateInput, PreferenceRefUncheckedUpdateInput>
  }

  /**
   * PreferenceRef delete
   */
  export type PreferenceRefDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferenceRef
     */
    select?: PreferenceRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreferenceRef
     */
    omit?: PreferenceRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenceRefInclude<ExtArgs> | null
    /**
     * Filter which PreferenceRef to delete.
     */
    where: PreferenceRefWhereUniqueInput
  }

  /**
   * PreferenceRef deleteMany
   */
  export type PreferenceRefDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PreferenceRefs to delete
     */
    where?: PreferenceRefWhereInput
    /**
     * Limit how many PreferenceRefs to delete.
     */
    limit?: number
  }

  /**
   * PreferenceRef.mentee_preferences_ref
   */
  export type PreferenceRef$mentee_preferences_refArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteePreferenceRef
     */
    select?: MenteePreferenceRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteePreferenceRef
     */
    omit?: MenteePreferenceRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteePreferenceRefInclude<ExtArgs> | null
    where?: MenteePreferenceRefWhereInput
    orderBy?: MenteePreferenceRefOrderByWithRelationInput | MenteePreferenceRefOrderByWithRelationInput[]
    cursor?: MenteePreferenceRefWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenteePreferenceRefScalarFieldEnum | MenteePreferenceRefScalarFieldEnum[]
  }

  /**
   * PreferenceRef without action
   */
  export type PreferenceRefDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferenceRef
     */
    select?: PreferenceRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreferenceRef
     */
    omit?: PreferenceRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenceRefInclude<ExtArgs> | null
  }


  /**
   * Model MenteeLanguage
   */

  export type AggregateMenteeLanguage = {
    _count: MenteeLanguageCountAggregateOutputType | null
    _min: MenteeLanguageMinAggregateOutputType | null
    _max: MenteeLanguageMaxAggregateOutputType | null
  }

  export type MenteeLanguageMinAggregateOutputType = {
    user_id: string | null
    lang_code: string | null
  }

  export type MenteeLanguageMaxAggregateOutputType = {
    user_id: string | null
    lang_code: string | null
  }

  export type MenteeLanguageCountAggregateOutputType = {
    user_id: number
    lang_code: number
    _all: number
  }


  export type MenteeLanguageMinAggregateInputType = {
    user_id?: true
    lang_code?: true
  }

  export type MenteeLanguageMaxAggregateInputType = {
    user_id?: true
    lang_code?: true
  }

  export type MenteeLanguageCountAggregateInputType = {
    user_id?: true
    lang_code?: true
    _all?: true
  }

  export type MenteeLanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenteeLanguage to aggregate.
     */
    where?: MenteeLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteeLanguages to fetch.
     */
    orderBy?: MenteeLanguageOrderByWithRelationInput | MenteeLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenteeLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteeLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteeLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MenteeLanguages
    **/
    _count?: true | MenteeLanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenteeLanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenteeLanguageMaxAggregateInputType
  }

  export type GetMenteeLanguageAggregateType<T extends MenteeLanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateMenteeLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenteeLanguage[P]>
      : GetScalarType<T[P], AggregateMenteeLanguage[P]>
  }




  export type MenteeLanguageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenteeLanguageWhereInput
    orderBy?: MenteeLanguageOrderByWithAggregationInput | MenteeLanguageOrderByWithAggregationInput[]
    by: MenteeLanguageScalarFieldEnum[] | MenteeLanguageScalarFieldEnum
    having?: MenteeLanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenteeLanguageCountAggregateInputType | true
    _min?: MenteeLanguageMinAggregateInputType
    _max?: MenteeLanguageMaxAggregateInputType
  }

  export type MenteeLanguageGroupByOutputType = {
    user_id: string
    lang_code: string
    _count: MenteeLanguageCountAggregateOutputType | null
    _min: MenteeLanguageMinAggregateOutputType | null
    _max: MenteeLanguageMaxAggregateOutputType | null
  }

  type GetMenteeLanguageGroupByPayload<T extends MenteeLanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenteeLanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenteeLanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenteeLanguageGroupByOutputType[P]>
            : GetScalarType<T[P], MenteeLanguageGroupByOutputType[P]>
        }
      >
    >


  export type MenteeLanguageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    lang_code?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menteeLanguage"]>

  export type MenteeLanguageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    lang_code?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menteeLanguage"]>

  export type MenteeLanguageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    lang_code?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menteeLanguage"]>

  export type MenteeLanguageSelectScalar = {
    user_id?: boolean
    lang_code?: boolean
  }

  export type MenteeLanguageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "lang_code", ExtArgs["result"]["menteeLanguage"]>
  export type MenteeLanguageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MenteeLanguageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MenteeLanguageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MenteeLanguagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MenteeLanguage"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: string
      lang_code: string
    }, ExtArgs["result"]["menteeLanguage"]>
    composites: {}
  }

  type MenteeLanguageGetPayload<S extends boolean | null | undefined | MenteeLanguageDefaultArgs> = $Result.GetResult<Prisma.$MenteeLanguagePayload, S>

  type MenteeLanguageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MenteeLanguageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MenteeLanguageCountAggregateInputType | true
    }

  export interface MenteeLanguageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MenteeLanguage'], meta: { name: 'MenteeLanguage' } }
    /**
     * Find zero or one MenteeLanguage that matches the filter.
     * @param {MenteeLanguageFindUniqueArgs} args - Arguments to find a MenteeLanguage
     * @example
     * // Get one MenteeLanguage
     * const menteeLanguage = await prisma.menteeLanguage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenteeLanguageFindUniqueArgs>(args: SelectSubset<T, MenteeLanguageFindUniqueArgs<ExtArgs>>): Prisma__MenteeLanguageClient<$Result.GetResult<Prisma.$MenteeLanguagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MenteeLanguage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MenteeLanguageFindUniqueOrThrowArgs} args - Arguments to find a MenteeLanguage
     * @example
     * // Get one MenteeLanguage
     * const menteeLanguage = await prisma.menteeLanguage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenteeLanguageFindUniqueOrThrowArgs>(args: SelectSubset<T, MenteeLanguageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MenteeLanguageClient<$Result.GetResult<Prisma.$MenteeLanguagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenteeLanguage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeLanguageFindFirstArgs} args - Arguments to find a MenteeLanguage
     * @example
     * // Get one MenteeLanguage
     * const menteeLanguage = await prisma.menteeLanguage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenteeLanguageFindFirstArgs>(args?: SelectSubset<T, MenteeLanguageFindFirstArgs<ExtArgs>>): Prisma__MenteeLanguageClient<$Result.GetResult<Prisma.$MenteeLanguagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenteeLanguage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeLanguageFindFirstOrThrowArgs} args - Arguments to find a MenteeLanguage
     * @example
     * // Get one MenteeLanguage
     * const menteeLanguage = await prisma.menteeLanguage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenteeLanguageFindFirstOrThrowArgs>(args?: SelectSubset<T, MenteeLanguageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MenteeLanguageClient<$Result.GetResult<Prisma.$MenteeLanguagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MenteeLanguages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeLanguageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MenteeLanguages
     * const menteeLanguages = await prisma.menteeLanguage.findMany()
     * 
     * // Get first 10 MenteeLanguages
     * const menteeLanguages = await prisma.menteeLanguage.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const menteeLanguageWithUser_idOnly = await prisma.menteeLanguage.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends MenteeLanguageFindManyArgs>(args?: SelectSubset<T, MenteeLanguageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteeLanguagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MenteeLanguage.
     * @param {MenteeLanguageCreateArgs} args - Arguments to create a MenteeLanguage.
     * @example
     * // Create one MenteeLanguage
     * const MenteeLanguage = await prisma.menteeLanguage.create({
     *   data: {
     *     // ... data to create a MenteeLanguage
     *   }
     * })
     * 
     */
    create<T extends MenteeLanguageCreateArgs>(args: SelectSubset<T, MenteeLanguageCreateArgs<ExtArgs>>): Prisma__MenteeLanguageClient<$Result.GetResult<Prisma.$MenteeLanguagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MenteeLanguages.
     * @param {MenteeLanguageCreateManyArgs} args - Arguments to create many MenteeLanguages.
     * @example
     * // Create many MenteeLanguages
     * const menteeLanguage = await prisma.menteeLanguage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MenteeLanguageCreateManyArgs>(args?: SelectSubset<T, MenteeLanguageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MenteeLanguages and returns the data saved in the database.
     * @param {MenteeLanguageCreateManyAndReturnArgs} args - Arguments to create many MenteeLanguages.
     * @example
     * // Create many MenteeLanguages
     * const menteeLanguage = await prisma.menteeLanguage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MenteeLanguages and only return the `user_id`
     * const menteeLanguageWithUser_idOnly = await prisma.menteeLanguage.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MenteeLanguageCreateManyAndReturnArgs>(args?: SelectSubset<T, MenteeLanguageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteeLanguagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MenteeLanguage.
     * @param {MenteeLanguageDeleteArgs} args - Arguments to delete one MenteeLanguage.
     * @example
     * // Delete one MenteeLanguage
     * const MenteeLanguage = await prisma.menteeLanguage.delete({
     *   where: {
     *     // ... filter to delete one MenteeLanguage
     *   }
     * })
     * 
     */
    delete<T extends MenteeLanguageDeleteArgs>(args: SelectSubset<T, MenteeLanguageDeleteArgs<ExtArgs>>): Prisma__MenteeLanguageClient<$Result.GetResult<Prisma.$MenteeLanguagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MenteeLanguage.
     * @param {MenteeLanguageUpdateArgs} args - Arguments to update one MenteeLanguage.
     * @example
     * // Update one MenteeLanguage
     * const menteeLanguage = await prisma.menteeLanguage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MenteeLanguageUpdateArgs>(args: SelectSubset<T, MenteeLanguageUpdateArgs<ExtArgs>>): Prisma__MenteeLanguageClient<$Result.GetResult<Prisma.$MenteeLanguagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MenteeLanguages.
     * @param {MenteeLanguageDeleteManyArgs} args - Arguments to filter MenteeLanguages to delete.
     * @example
     * // Delete a few MenteeLanguages
     * const { count } = await prisma.menteeLanguage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MenteeLanguageDeleteManyArgs>(args?: SelectSubset<T, MenteeLanguageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenteeLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeLanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MenteeLanguages
     * const menteeLanguage = await prisma.menteeLanguage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MenteeLanguageUpdateManyArgs>(args: SelectSubset<T, MenteeLanguageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenteeLanguages and returns the data updated in the database.
     * @param {MenteeLanguageUpdateManyAndReturnArgs} args - Arguments to update many MenteeLanguages.
     * @example
     * // Update many MenteeLanguages
     * const menteeLanguage = await prisma.menteeLanguage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MenteeLanguages and only return the `user_id`
     * const menteeLanguageWithUser_idOnly = await prisma.menteeLanguage.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MenteeLanguageUpdateManyAndReturnArgs>(args: SelectSubset<T, MenteeLanguageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteeLanguagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MenteeLanguage.
     * @param {MenteeLanguageUpsertArgs} args - Arguments to update or create a MenteeLanguage.
     * @example
     * // Update or create a MenteeLanguage
     * const menteeLanguage = await prisma.menteeLanguage.upsert({
     *   create: {
     *     // ... data to create a MenteeLanguage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MenteeLanguage we want to update
     *   }
     * })
     */
    upsert<T extends MenteeLanguageUpsertArgs>(args: SelectSubset<T, MenteeLanguageUpsertArgs<ExtArgs>>): Prisma__MenteeLanguageClient<$Result.GetResult<Prisma.$MenteeLanguagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MenteeLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeLanguageCountArgs} args - Arguments to filter MenteeLanguages to count.
     * @example
     * // Count the number of MenteeLanguages
     * const count = await prisma.menteeLanguage.count({
     *   where: {
     *     // ... the filter for the MenteeLanguages we want to count
     *   }
     * })
    **/
    count<T extends MenteeLanguageCountArgs>(
      args?: Subset<T, MenteeLanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenteeLanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MenteeLanguage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeLanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenteeLanguageAggregateArgs>(args: Subset<T, MenteeLanguageAggregateArgs>): Prisma.PrismaPromise<GetMenteeLanguageAggregateType<T>>

    /**
     * Group by MenteeLanguage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeLanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenteeLanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenteeLanguageGroupByArgs['orderBy'] }
        : { orderBy?: MenteeLanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenteeLanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenteeLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MenteeLanguage model
   */
  readonly fields: MenteeLanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MenteeLanguage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenteeLanguageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MenteeLanguage model
   */
  interface MenteeLanguageFieldRefs {
    readonly user_id: FieldRef<"MenteeLanguage", 'String'>
    readonly lang_code: FieldRef<"MenteeLanguage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MenteeLanguage findUnique
   */
  export type MenteeLanguageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeLanguage
     */
    select?: MenteeLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeLanguage
     */
    omit?: MenteeLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeLanguageInclude<ExtArgs> | null
    /**
     * Filter, which MenteeLanguage to fetch.
     */
    where: MenteeLanguageWhereUniqueInput
  }

  /**
   * MenteeLanguage findUniqueOrThrow
   */
  export type MenteeLanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeLanguage
     */
    select?: MenteeLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeLanguage
     */
    omit?: MenteeLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeLanguageInclude<ExtArgs> | null
    /**
     * Filter, which MenteeLanguage to fetch.
     */
    where: MenteeLanguageWhereUniqueInput
  }

  /**
   * MenteeLanguage findFirst
   */
  export type MenteeLanguageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeLanguage
     */
    select?: MenteeLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeLanguage
     */
    omit?: MenteeLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeLanguageInclude<ExtArgs> | null
    /**
     * Filter, which MenteeLanguage to fetch.
     */
    where?: MenteeLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteeLanguages to fetch.
     */
    orderBy?: MenteeLanguageOrderByWithRelationInput | MenteeLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenteeLanguages.
     */
    cursor?: MenteeLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteeLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteeLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenteeLanguages.
     */
    distinct?: MenteeLanguageScalarFieldEnum | MenteeLanguageScalarFieldEnum[]
  }

  /**
   * MenteeLanguage findFirstOrThrow
   */
  export type MenteeLanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeLanguage
     */
    select?: MenteeLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeLanguage
     */
    omit?: MenteeLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeLanguageInclude<ExtArgs> | null
    /**
     * Filter, which MenteeLanguage to fetch.
     */
    where?: MenteeLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteeLanguages to fetch.
     */
    orderBy?: MenteeLanguageOrderByWithRelationInput | MenteeLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenteeLanguages.
     */
    cursor?: MenteeLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteeLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteeLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenteeLanguages.
     */
    distinct?: MenteeLanguageScalarFieldEnum | MenteeLanguageScalarFieldEnum[]
  }

  /**
   * MenteeLanguage findMany
   */
  export type MenteeLanguageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeLanguage
     */
    select?: MenteeLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeLanguage
     */
    omit?: MenteeLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeLanguageInclude<ExtArgs> | null
    /**
     * Filter, which MenteeLanguages to fetch.
     */
    where?: MenteeLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteeLanguages to fetch.
     */
    orderBy?: MenteeLanguageOrderByWithRelationInput | MenteeLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MenteeLanguages.
     */
    cursor?: MenteeLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteeLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteeLanguages.
     */
    skip?: number
    distinct?: MenteeLanguageScalarFieldEnum | MenteeLanguageScalarFieldEnum[]
  }

  /**
   * MenteeLanguage create
   */
  export type MenteeLanguageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeLanguage
     */
    select?: MenteeLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeLanguage
     */
    omit?: MenteeLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeLanguageInclude<ExtArgs> | null
    /**
     * The data needed to create a MenteeLanguage.
     */
    data: XOR<MenteeLanguageCreateInput, MenteeLanguageUncheckedCreateInput>
  }

  /**
   * MenteeLanguage createMany
   */
  export type MenteeLanguageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MenteeLanguages.
     */
    data: MenteeLanguageCreateManyInput | MenteeLanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MenteeLanguage createManyAndReturn
   */
  export type MenteeLanguageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeLanguage
     */
    select?: MenteeLanguageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeLanguage
     */
    omit?: MenteeLanguageOmit<ExtArgs> | null
    /**
     * The data used to create many MenteeLanguages.
     */
    data: MenteeLanguageCreateManyInput | MenteeLanguageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeLanguageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenteeLanguage update
   */
  export type MenteeLanguageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeLanguage
     */
    select?: MenteeLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeLanguage
     */
    omit?: MenteeLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeLanguageInclude<ExtArgs> | null
    /**
     * The data needed to update a MenteeLanguage.
     */
    data: XOR<MenteeLanguageUpdateInput, MenteeLanguageUncheckedUpdateInput>
    /**
     * Choose, which MenteeLanguage to update.
     */
    where: MenteeLanguageWhereUniqueInput
  }

  /**
   * MenteeLanguage updateMany
   */
  export type MenteeLanguageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MenteeLanguages.
     */
    data: XOR<MenteeLanguageUpdateManyMutationInput, MenteeLanguageUncheckedUpdateManyInput>
    /**
     * Filter which MenteeLanguages to update
     */
    where?: MenteeLanguageWhereInput
    /**
     * Limit how many MenteeLanguages to update.
     */
    limit?: number
  }

  /**
   * MenteeLanguage updateManyAndReturn
   */
  export type MenteeLanguageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeLanguage
     */
    select?: MenteeLanguageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeLanguage
     */
    omit?: MenteeLanguageOmit<ExtArgs> | null
    /**
     * The data used to update MenteeLanguages.
     */
    data: XOR<MenteeLanguageUpdateManyMutationInput, MenteeLanguageUncheckedUpdateManyInput>
    /**
     * Filter which MenteeLanguages to update
     */
    where?: MenteeLanguageWhereInput
    /**
     * Limit how many MenteeLanguages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeLanguageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenteeLanguage upsert
   */
  export type MenteeLanguageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeLanguage
     */
    select?: MenteeLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeLanguage
     */
    omit?: MenteeLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeLanguageInclude<ExtArgs> | null
    /**
     * The filter to search for the MenteeLanguage to update in case it exists.
     */
    where: MenteeLanguageWhereUniqueInput
    /**
     * In case the MenteeLanguage found by the `where` argument doesn't exist, create a new MenteeLanguage with this data.
     */
    create: XOR<MenteeLanguageCreateInput, MenteeLanguageUncheckedCreateInput>
    /**
     * In case the MenteeLanguage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenteeLanguageUpdateInput, MenteeLanguageUncheckedUpdateInput>
  }

  /**
   * MenteeLanguage delete
   */
  export type MenteeLanguageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeLanguage
     */
    select?: MenteeLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeLanguage
     */
    omit?: MenteeLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeLanguageInclude<ExtArgs> | null
    /**
     * Filter which MenteeLanguage to delete.
     */
    where: MenteeLanguageWhereUniqueInput
  }

  /**
   * MenteeLanguage deleteMany
   */
  export type MenteeLanguageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenteeLanguages to delete
     */
    where?: MenteeLanguageWhereInput
    /**
     * Limit how many MenteeLanguages to delete.
     */
    limit?: number
  }

  /**
   * MenteeLanguage without action
   */
  export type MenteeLanguageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeLanguage
     */
    select?: MenteeLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeLanguage
     */
    omit?: MenteeLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeLanguageInclude<ExtArgs> | null
  }


  /**
   * Model MenteeInterest
   */

  export type AggregateMenteeInterest = {
    _count: MenteeInterestCountAggregateOutputType | null
    _min: MenteeInterestMinAggregateOutputType | null
    _max: MenteeInterestMaxAggregateOutputType | null
  }

  export type MenteeInterestMinAggregateOutputType = {
    user_id: string | null
    interest: string | null
    created_at: Date | null
  }

  export type MenteeInterestMaxAggregateOutputType = {
    user_id: string | null
    interest: string | null
    created_at: Date | null
  }

  export type MenteeInterestCountAggregateOutputType = {
    user_id: number
    interest: number
    created_at: number
    _all: number
  }


  export type MenteeInterestMinAggregateInputType = {
    user_id?: true
    interest?: true
    created_at?: true
  }

  export type MenteeInterestMaxAggregateInputType = {
    user_id?: true
    interest?: true
    created_at?: true
  }

  export type MenteeInterestCountAggregateInputType = {
    user_id?: true
    interest?: true
    created_at?: true
    _all?: true
  }

  export type MenteeInterestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenteeInterest to aggregate.
     */
    where?: MenteeInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteeInterests to fetch.
     */
    orderBy?: MenteeInterestOrderByWithRelationInput | MenteeInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenteeInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteeInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteeInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MenteeInterests
    **/
    _count?: true | MenteeInterestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenteeInterestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenteeInterestMaxAggregateInputType
  }

  export type GetMenteeInterestAggregateType<T extends MenteeInterestAggregateArgs> = {
        [P in keyof T & keyof AggregateMenteeInterest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenteeInterest[P]>
      : GetScalarType<T[P], AggregateMenteeInterest[P]>
  }




  export type MenteeInterestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenteeInterestWhereInput
    orderBy?: MenteeInterestOrderByWithAggregationInput | MenteeInterestOrderByWithAggregationInput[]
    by: MenteeInterestScalarFieldEnum[] | MenteeInterestScalarFieldEnum
    having?: MenteeInterestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenteeInterestCountAggregateInputType | true
    _min?: MenteeInterestMinAggregateInputType
    _max?: MenteeInterestMaxAggregateInputType
  }

  export type MenteeInterestGroupByOutputType = {
    user_id: string
    interest: string
    created_at: Date
    _count: MenteeInterestCountAggregateOutputType | null
    _min: MenteeInterestMinAggregateOutputType | null
    _max: MenteeInterestMaxAggregateOutputType | null
  }

  type GetMenteeInterestGroupByPayload<T extends MenteeInterestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenteeInterestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenteeInterestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenteeInterestGroupByOutputType[P]>
            : GetScalarType<T[P], MenteeInterestGroupByOutputType[P]>
        }
      >
    >


  export type MenteeInterestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    interest?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menteeInterest"]>

  export type MenteeInterestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    interest?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menteeInterest"]>

  export type MenteeInterestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    interest?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menteeInterest"]>

  export type MenteeInterestSelectScalar = {
    user_id?: boolean
    interest?: boolean
    created_at?: boolean
  }

  export type MenteeInterestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "interest" | "created_at", ExtArgs["result"]["menteeInterest"]>
  export type MenteeInterestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MenteeInterestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MenteeInterestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MenteeInterestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MenteeInterest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: string
      interest: string
      created_at: Date
    }, ExtArgs["result"]["menteeInterest"]>
    composites: {}
  }

  type MenteeInterestGetPayload<S extends boolean | null | undefined | MenteeInterestDefaultArgs> = $Result.GetResult<Prisma.$MenteeInterestPayload, S>

  type MenteeInterestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MenteeInterestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MenteeInterestCountAggregateInputType | true
    }

  export interface MenteeInterestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MenteeInterest'], meta: { name: 'MenteeInterest' } }
    /**
     * Find zero or one MenteeInterest that matches the filter.
     * @param {MenteeInterestFindUniqueArgs} args - Arguments to find a MenteeInterest
     * @example
     * // Get one MenteeInterest
     * const menteeInterest = await prisma.menteeInterest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenteeInterestFindUniqueArgs>(args: SelectSubset<T, MenteeInterestFindUniqueArgs<ExtArgs>>): Prisma__MenteeInterestClient<$Result.GetResult<Prisma.$MenteeInterestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MenteeInterest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MenteeInterestFindUniqueOrThrowArgs} args - Arguments to find a MenteeInterest
     * @example
     * // Get one MenteeInterest
     * const menteeInterest = await prisma.menteeInterest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenteeInterestFindUniqueOrThrowArgs>(args: SelectSubset<T, MenteeInterestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MenteeInterestClient<$Result.GetResult<Prisma.$MenteeInterestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenteeInterest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeInterestFindFirstArgs} args - Arguments to find a MenteeInterest
     * @example
     * // Get one MenteeInterest
     * const menteeInterest = await prisma.menteeInterest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenteeInterestFindFirstArgs>(args?: SelectSubset<T, MenteeInterestFindFirstArgs<ExtArgs>>): Prisma__MenteeInterestClient<$Result.GetResult<Prisma.$MenteeInterestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenteeInterest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeInterestFindFirstOrThrowArgs} args - Arguments to find a MenteeInterest
     * @example
     * // Get one MenteeInterest
     * const menteeInterest = await prisma.menteeInterest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenteeInterestFindFirstOrThrowArgs>(args?: SelectSubset<T, MenteeInterestFindFirstOrThrowArgs<ExtArgs>>): Prisma__MenteeInterestClient<$Result.GetResult<Prisma.$MenteeInterestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MenteeInterests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeInterestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MenteeInterests
     * const menteeInterests = await prisma.menteeInterest.findMany()
     * 
     * // Get first 10 MenteeInterests
     * const menteeInterests = await prisma.menteeInterest.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const menteeInterestWithUser_idOnly = await prisma.menteeInterest.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends MenteeInterestFindManyArgs>(args?: SelectSubset<T, MenteeInterestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteeInterestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MenteeInterest.
     * @param {MenteeInterestCreateArgs} args - Arguments to create a MenteeInterest.
     * @example
     * // Create one MenteeInterest
     * const MenteeInterest = await prisma.menteeInterest.create({
     *   data: {
     *     // ... data to create a MenteeInterest
     *   }
     * })
     * 
     */
    create<T extends MenteeInterestCreateArgs>(args: SelectSubset<T, MenteeInterestCreateArgs<ExtArgs>>): Prisma__MenteeInterestClient<$Result.GetResult<Prisma.$MenteeInterestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MenteeInterests.
     * @param {MenteeInterestCreateManyArgs} args - Arguments to create many MenteeInterests.
     * @example
     * // Create many MenteeInterests
     * const menteeInterest = await prisma.menteeInterest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MenteeInterestCreateManyArgs>(args?: SelectSubset<T, MenteeInterestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MenteeInterests and returns the data saved in the database.
     * @param {MenteeInterestCreateManyAndReturnArgs} args - Arguments to create many MenteeInterests.
     * @example
     * // Create many MenteeInterests
     * const menteeInterest = await prisma.menteeInterest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MenteeInterests and only return the `user_id`
     * const menteeInterestWithUser_idOnly = await prisma.menteeInterest.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MenteeInterestCreateManyAndReturnArgs>(args?: SelectSubset<T, MenteeInterestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteeInterestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MenteeInterest.
     * @param {MenteeInterestDeleteArgs} args - Arguments to delete one MenteeInterest.
     * @example
     * // Delete one MenteeInterest
     * const MenteeInterest = await prisma.menteeInterest.delete({
     *   where: {
     *     // ... filter to delete one MenteeInterest
     *   }
     * })
     * 
     */
    delete<T extends MenteeInterestDeleteArgs>(args: SelectSubset<T, MenteeInterestDeleteArgs<ExtArgs>>): Prisma__MenteeInterestClient<$Result.GetResult<Prisma.$MenteeInterestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MenteeInterest.
     * @param {MenteeInterestUpdateArgs} args - Arguments to update one MenteeInterest.
     * @example
     * // Update one MenteeInterest
     * const menteeInterest = await prisma.menteeInterest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MenteeInterestUpdateArgs>(args: SelectSubset<T, MenteeInterestUpdateArgs<ExtArgs>>): Prisma__MenteeInterestClient<$Result.GetResult<Prisma.$MenteeInterestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MenteeInterests.
     * @param {MenteeInterestDeleteManyArgs} args - Arguments to filter MenteeInterests to delete.
     * @example
     * // Delete a few MenteeInterests
     * const { count } = await prisma.menteeInterest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MenteeInterestDeleteManyArgs>(args?: SelectSubset<T, MenteeInterestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenteeInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeInterestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MenteeInterests
     * const menteeInterest = await prisma.menteeInterest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MenteeInterestUpdateManyArgs>(args: SelectSubset<T, MenteeInterestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenteeInterests and returns the data updated in the database.
     * @param {MenteeInterestUpdateManyAndReturnArgs} args - Arguments to update many MenteeInterests.
     * @example
     * // Update many MenteeInterests
     * const menteeInterest = await prisma.menteeInterest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MenteeInterests and only return the `user_id`
     * const menteeInterestWithUser_idOnly = await prisma.menteeInterest.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MenteeInterestUpdateManyAndReturnArgs>(args: SelectSubset<T, MenteeInterestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteeInterestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MenteeInterest.
     * @param {MenteeInterestUpsertArgs} args - Arguments to update or create a MenteeInterest.
     * @example
     * // Update or create a MenteeInterest
     * const menteeInterest = await prisma.menteeInterest.upsert({
     *   create: {
     *     // ... data to create a MenteeInterest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MenteeInterest we want to update
     *   }
     * })
     */
    upsert<T extends MenteeInterestUpsertArgs>(args: SelectSubset<T, MenteeInterestUpsertArgs<ExtArgs>>): Prisma__MenteeInterestClient<$Result.GetResult<Prisma.$MenteeInterestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MenteeInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeInterestCountArgs} args - Arguments to filter MenteeInterests to count.
     * @example
     * // Count the number of MenteeInterests
     * const count = await prisma.menteeInterest.count({
     *   where: {
     *     // ... the filter for the MenteeInterests we want to count
     *   }
     * })
    **/
    count<T extends MenteeInterestCountArgs>(
      args?: Subset<T, MenteeInterestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenteeInterestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MenteeInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeInterestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenteeInterestAggregateArgs>(args: Subset<T, MenteeInterestAggregateArgs>): Prisma.PrismaPromise<GetMenteeInterestAggregateType<T>>

    /**
     * Group by MenteeInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeInterestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenteeInterestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenteeInterestGroupByArgs['orderBy'] }
        : { orderBy?: MenteeInterestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenteeInterestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenteeInterestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MenteeInterest model
   */
  readonly fields: MenteeInterestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MenteeInterest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenteeInterestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MenteeInterest model
   */
  interface MenteeInterestFieldRefs {
    readonly user_id: FieldRef<"MenteeInterest", 'String'>
    readonly interest: FieldRef<"MenteeInterest", 'String'>
    readonly created_at: FieldRef<"MenteeInterest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MenteeInterest findUnique
   */
  export type MenteeInterestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeInterest
     */
    select?: MenteeInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeInterest
     */
    omit?: MenteeInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeInterestInclude<ExtArgs> | null
    /**
     * Filter, which MenteeInterest to fetch.
     */
    where: MenteeInterestWhereUniqueInput
  }

  /**
   * MenteeInterest findUniqueOrThrow
   */
  export type MenteeInterestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeInterest
     */
    select?: MenteeInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeInterest
     */
    omit?: MenteeInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeInterestInclude<ExtArgs> | null
    /**
     * Filter, which MenteeInterest to fetch.
     */
    where: MenteeInterestWhereUniqueInput
  }

  /**
   * MenteeInterest findFirst
   */
  export type MenteeInterestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeInterest
     */
    select?: MenteeInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeInterest
     */
    omit?: MenteeInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeInterestInclude<ExtArgs> | null
    /**
     * Filter, which MenteeInterest to fetch.
     */
    where?: MenteeInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteeInterests to fetch.
     */
    orderBy?: MenteeInterestOrderByWithRelationInput | MenteeInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenteeInterests.
     */
    cursor?: MenteeInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteeInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteeInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenteeInterests.
     */
    distinct?: MenteeInterestScalarFieldEnum | MenteeInterestScalarFieldEnum[]
  }

  /**
   * MenteeInterest findFirstOrThrow
   */
  export type MenteeInterestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeInterest
     */
    select?: MenteeInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeInterest
     */
    omit?: MenteeInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeInterestInclude<ExtArgs> | null
    /**
     * Filter, which MenteeInterest to fetch.
     */
    where?: MenteeInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteeInterests to fetch.
     */
    orderBy?: MenteeInterestOrderByWithRelationInput | MenteeInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenteeInterests.
     */
    cursor?: MenteeInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteeInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteeInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenteeInterests.
     */
    distinct?: MenteeInterestScalarFieldEnum | MenteeInterestScalarFieldEnum[]
  }

  /**
   * MenteeInterest findMany
   */
  export type MenteeInterestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeInterest
     */
    select?: MenteeInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeInterest
     */
    omit?: MenteeInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeInterestInclude<ExtArgs> | null
    /**
     * Filter, which MenteeInterests to fetch.
     */
    where?: MenteeInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteeInterests to fetch.
     */
    orderBy?: MenteeInterestOrderByWithRelationInput | MenteeInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MenteeInterests.
     */
    cursor?: MenteeInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteeInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteeInterests.
     */
    skip?: number
    distinct?: MenteeInterestScalarFieldEnum | MenteeInterestScalarFieldEnum[]
  }

  /**
   * MenteeInterest create
   */
  export type MenteeInterestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeInterest
     */
    select?: MenteeInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeInterest
     */
    omit?: MenteeInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeInterestInclude<ExtArgs> | null
    /**
     * The data needed to create a MenteeInterest.
     */
    data: XOR<MenteeInterestCreateInput, MenteeInterestUncheckedCreateInput>
  }

  /**
   * MenteeInterest createMany
   */
  export type MenteeInterestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MenteeInterests.
     */
    data: MenteeInterestCreateManyInput | MenteeInterestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MenteeInterest createManyAndReturn
   */
  export type MenteeInterestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeInterest
     */
    select?: MenteeInterestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeInterest
     */
    omit?: MenteeInterestOmit<ExtArgs> | null
    /**
     * The data used to create many MenteeInterests.
     */
    data: MenteeInterestCreateManyInput | MenteeInterestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeInterestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenteeInterest update
   */
  export type MenteeInterestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeInterest
     */
    select?: MenteeInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeInterest
     */
    omit?: MenteeInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeInterestInclude<ExtArgs> | null
    /**
     * The data needed to update a MenteeInterest.
     */
    data: XOR<MenteeInterestUpdateInput, MenteeInterestUncheckedUpdateInput>
    /**
     * Choose, which MenteeInterest to update.
     */
    where: MenteeInterestWhereUniqueInput
  }

  /**
   * MenteeInterest updateMany
   */
  export type MenteeInterestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MenteeInterests.
     */
    data: XOR<MenteeInterestUpdateManyMutationInput, MenteeInterestUncheckedUpdateManyInput>
    /**
     * Filter which MenteeInterests to update
     */
    where?: MenteeInterestWhereInput
    /**
     * Limit how many MenteeInterests to update.
     */
    limit?: number
  }

  /**
   * MenteeInterest updateManyAndReturn
   */
  export type MenteeInterestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeInterest
     */
    select?: MenteeInterestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeInterest
     */
    omit?: MenteeInterestOmit<ExtArgs> | null
    /**
     * The data used to update MenteeInterests.
     */
    data: XOR<MenteeInterestUpdateManyMutationInput, MenteeInterestUncheckedUpdateManyInput>
    /**
     * Filter which MenteeInterests to update
     */
    where?: MenteeInterestWhereInput
    /**
     * Limit how many MenteeInterests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeInterestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenteeInterest upsert
   */
  export type MenteeInterestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeInterest
     */
    select?: MenteeInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeInterest
     */
    omit?: MenteeInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeInterestInclude<ExtArgs> | null
    /**
     * The filter to search for the MenteeInterest to update in case it exists.
     */
    where: MenteeInterestWhereUniqueInput
    /**
     * In case the MenteeInterest found by the `where` argument doesn't exist, create a new MenteeInterest with this data.
     */
    create: XOR<MenteeInterestCreateInput, MenteeInterestUncheckedCreateInput>
    /**
     * In case the MenteeInterest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenteeInterestUpdateInput, MenteeInterestUncheckedUpdateInput>
  }

  /**
   * MenteeInterest delete
   */
  export type MenteeInterestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeInterest
     */
    select?: MenteeInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeInterest
     */
    omit?: MenteeInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeInterestInclude<ExtArgs> | null
    /**
     * Filter which MenteeInterest to delete.
     */
    where: MenteeInterestWhereUniqueInput
  }

  /**
   * MenteeInterest deleteMany
   */
  export type MenteeInterestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenteeInterests to delete
     */
    where?: MenteeInterestWhereInput
    /**
     * Limit how many MenteeInterests to delete.
     */
    limit?: number
  }

  /**
   * MenteeInterest without action
   */
  export type MenteeInterestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeInterest
     */
    select?: MenteeInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeInterest
     */
    omit?: MenteeInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeInterestInclude<ExtArgs> | null
  }


  /**
   * Model MenteePriority
   */

  export type AggregateMenteePriority = {
    _count: MenteePriorityCountAggregateOutputType | null
    _min: MenteePriorityMinAggregateOutputType | null
    _max: MenteePriorityMaxAggregateOutputType | null
  }

  export type MenteePriorityMinAggregateOutputType = {
    user_id: string | null
    priority: string | null
    created_at: Date | null
  }

  export type MenteePriorityMaxAggregateOutputType = {
    user_id: string | null
    priority: string | null
    created_at: Date | null
  }

  export type MenteePriorityCountAggregateOutputType = {
    user_id: number
    priority: number
    created_at: number
    _all: number
  }


  export type MenteePriorityMinAggregateInputType = {
    user_id?: true
    priority?: true
    created_at?: true
  }

  export type MenteePriorityMaxAggregateInputType = {
    user_id?: true
    priority?: true
    created_at?: true
  }

  export type MenteePriorityCountAggregateInputType = {
    user_id?: true
    priority?: true
    created_at?: true
    _all?: true
  }

  export type MenteePriorityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenteePriority to aggregate.
     */
    where?: MenteePriorityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteePriorities to fetch.
     */
    orderBy?: MenteePriorityOrderByWithRelationInput | MenteePriorityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenteePriorityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteePriorities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteePriorities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MenteePriorities
    **/
    _count?: true | MenteePriorityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenteePriorityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenteePriorityMaxAggregateInputType
  }

  export type GetMenteePriorityAggregateType<T extends MenteePriorityAggregateArgs> = {
        [P in keyof T & keyof AggregateMenteePriority]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenteePriority[P]>
      : GetScalarType<T[P], AggregateMenteePriority[P]>
  }




  export type MenteePriorityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenteePriorityWhereInput
    orderBy?: MenteePriorityOrderByWithAggregationInput | MenteePriorityOrderByWithAggregationInput[]
    by: MenteePriorityScalarFieldEnum[] | MenteePriorityScalarFieldEnum
    having?: MenteePriorityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenteePriorityCountAggregateInputType | true
    _min?: MenteePriorityMinAggregateInputType
    _max?: MenteePriorityMaxAggregateInputType
  }

  export type MenteePriorityGroupByOutputType = {
    user_id: string
    priority: string
    created_at: Date
    _count: MenteePriorityCountAggregateOutputType | null
    _min: MenteePriorityMinAggregateOutputType | null
    _max: MenteePriorityMaxAggregateOutputType | null
  }

  type GetMenteePriorityGroupByPayload<T extends MenteePriorityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenteePriorityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenteePriorityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenteePriorityGroupByOutputType[P]>
            : GetScalarType<T[P], MenteePriorityGroupByOutputType[P]>
        }
      >
    >


  export type MenteePrioritySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    priority?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menteePriority"]>

  export type MenteePrioritySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    priority?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menteePriority"]>

  export type MenteePrioritySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    priority?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menteePriority"]>

  export type MenteePrioritySelectScalar = {
    user_id?: boolean
    priority?: boolean
    created_at?: boolean
  }

  export type MenteePriorityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "priority" | "created_at", ExtArgs["result"]["menteePriority"]>
  export type MenteePriorityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MenteePriorityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MenteePriorityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MenteePriorityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MenteePriority"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: string
      priority: string
      created_at: Date
    }, ExtArgs["result"]["menteePriority"]>
    composites: {}
  }

  type MenteePriorityGetPayload<S extends boolean | null | undefined | MenteePriorityDefaultArgs> = $Result.GetResult<Prisma.$MenteePriorityPayload, S>

  type MenteePriorityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MenteePriorityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MenteePriorityCountAggregateInputType | true
    }

  export interface MenteePriorityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MenteePriority'], meta: { name: 'MenteePriority' } }
    /**
     * Find zero or one MenteePriority that matches the filter.
     * @param {MenteePriorityFindUniqueArgs} args - Arguments to find a MenteePriority
     * @example
     * // Get one MenteePriority
     * const menteePriority = await prisma.menteePriority.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenteePriorityFindUniqueArgs>(args: SelectSubset<T, MenteePriorityFindUniqueArgs<ExtArgs>>): Prisma__MenteePriorityClient<$Result.GetResult<Prisma.$MenteePriorityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MenteePriority that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MenteePriorityFindUniqueOrThrowArgs} args - Arguments to find a MenteePriority
     * @example
     * // Get one MenteePriority
     * const menteePriority = await prisma.menteePriority.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenteePriorityFindUniqueOrThrowArgs>(args: SelectSubset<T, MenteePriorityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MenteePriorityClient<$Result.GetResult<Prisma.$MenteePriorityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenteePriority that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteePriorityFindFirstArgs} args - Arguments to find a MenteePriority
     * @example
     * // Get one MenteePriority
     * const menteePriority = await prisma.menteePriority.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenteePriorityFindFirstArgs>(args?: SelectSubset<T, MenteePriorityFindFirstArgs<ExtArgs>>): Prisma__MenteePriorityClient<$Result.GetResult<Prisma.$MenteePriorityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenteePriority that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteePriorityFindFirstOrThrowArgs} args - Arguments to find a MenteePriority
     * @example
     * // Get one MenteePriority
     * const menteePriority = await prisma.menteePriority.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenteePriorityFindFirstOrThrowArgs>(args?: SelectSubset<T, MenteePriorityFindFirstOrThrowArgs<ExtArgs>>): Prisma__MenteePriorityClient<$Result.GetResult<Prisma.$MenteePriorityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MenteePriorities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteePriorityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MenteePriorities
     * const menteePriorities = await prisma.menteePriority.findMany()
     * 
     * // Get first 10 MenteePriorities
     * const menteePriorities = await prisma.menteePriority.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const menteePriorityWithUser_idOnly = await prisma.menteePriority.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends MenteePriorityFindManyArgs>(args?: SelectSubset<T, MenteePriorityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteePriorityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MenteePriority.
     * @param {MenteePriorityCreateArgs} args - Arguments to create a MenteePriority.
     * @example
     * // Create one MenteePriority
     * const MenteePriority = await prisma.menteePriority.create({
     *   data: {
     *     // ... data to create a MenteePriority
     *   }
     * })
     * 
     */
    create<T extends MenteePriorityCreateArgs>(args: SelectSubset<T, MenteePriorityCreateArgs<ExtArgs>>): Prisma__MenteePriorityClient<$Result.GetResult<Prisma.$MenteePriorityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MenteePriorities.
     * @param {MenteePriorityCreateManyArgs} args - Arguments to create many MenteePriorities.
     * @example
     * // Create many MenteePriorities
     * const menteePriority = await prisma.menteePriority.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MenteePriorityCreateManyArgs>(args?: SelectSubset<T, MenteePriorityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MenteePriorities and returns the data saved in the database.
     * @param {MenteePriorityCreateManyAndReturnArgs} args - Arguments to create many MenteePriorities.
     * @example
     * // Create many MenteePriorities
     * const menteePriority = await prisma.menteePriority.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MenteePriorities and only return the `user_id`
     * const menteePriorityWithUser_idOnly = await prisma.menteePriority.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MenteePriorityCreateManyAndReturnArgs>(args?: SelectSubset<T, MenteePriorityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteePriorityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MenteePriority.
     * @param {MenteePriorityDeleteArgs} args - Arguments to delete one MenteePriority.
     * @example
     * // Delete one MenteePriority
     * const MenteePriority = await prisma.menteePriority.delete({
     *   where: {
     *     // ... filter to delete one MenteePriority
     *   }
     * })
     * 
     */
    delete<T extends MenteePriorityDeleteArgs>(args: SelectSubset<T, MenteePriorityDeleteArgs<ExtArgs>>): Prisma__MenteePriorityClient<$Result.GetResult<Prisma.$MenteePriorityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MenteePriority.
     * @param {MenteePriorityUpdateArgs} args - Arguments to update one MenteePriority.
     * @example
     * // Update one MenteePriority
     * const menteePriority = await prisma.menteePriority.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MenteePriorityUpdateArgs>(args: SelectSubset<T, MenteePriorityUpdateArgs<ExtArgs>>): Prisma__MenteePriorityClient<$Result.GetResult<Prisma.$MenteePriorityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MenteePriorities.
     * @param {MenteePriorityDeleteManyArgs} args - Arguments to filter MenteePriorities to delete.
     * @example
     * // Delete a few MenteePriorities
     * const { count } = await prisma.menteePriority.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MenteePriorityDeleteManyArgs>(args?: SelectSubset<T, MenteePriorityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenteePriorities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteePriorityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MenteePriorities
     * const menteePriority = await prisma.menteePriority.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MenteePriorityUpdateManyArgs>(args: SelectSubset<T, MenteePriorityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenteePriorities and returns the data updated in the database.
     * @param {MenteePriorityUpdateManyAndReturnArgs} args - Arguments to update many MenteePriorities.
     * @example
     * // Update many MenteePriorities
     * const menteePriority = await prisma.menteePriority.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MenteePriorities and only return the `user_id`
     * const menteePriorityWithUser_idOnly = await prisma.menteePriority.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MenteePriorityUpdateManyAndReturnArgs>(args: SelectSubset<T, MenteePriorityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteePriorityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MenteePriority.
     * @param {MenteePriorityUpsertArgs} args - Arguments to update or create a MenteePriority.
     * @example
     * // Update or create a MenteePriority
     * const menteePriority = await prisma.menteePriority.upsert({
     *   create: {
     *     // ... data to create a MenteePriority
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MenteePriority we want to update
     *   }
     * })
     */
    upsert<T extends MenteePriorityUpsertArgs>(args: SelectSubset<T, MenteePriorityUpsertArgs<ExtArgs>>): Prisma__MenteePriorityClient<$Result.GetResult<Prisma.$MenteePriorityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MenteePriorities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteePriorityCountArgs} args - Arguments to filter MenteePriorities to count.
     * @example
     * // Count the number of MenteePriorities
     * const count = await prisma.menteePriority.count({
     *   where: {
     *     // ... the filter for the MenteePriorities we want to count
     *   }
     * })
    **/
    count<T extends MenteePriorityCountArgs>(
      args?: Subset<T, MenteePriorityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenteePriorityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MenteePriority.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteePriorityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenteePriorityAggregateArgs>(args: Subset<T, MenteePriorityAggregateArgs>): Prisma.PrismaPromise<GetMenteePriorityAggregateType<T>>

    /**
     * Group by MenteePriority.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteePriorityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenteePriorityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenteePriorityGroupByArgs['orderBy'] }
        : { orderBy?: MenteePriorityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenteePriorityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenteePriorityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MenteePriority model
   */
  readonly fields: MenteePriorityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MenteePriority.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenteePriorityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MenteePriority model
   */
  interface MenteePriorityFieldRefs {
    readonly user_id: FieldRef<"MenteePriority", 'String'>
    readonly priority: FieldRef<"MenteePriority", 'String'>
    readonly created_at: FieldRef<"MenteePriority", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MenteePriority findUnique
   */
  export type MenteePriorityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteePriority
     */
    select?: MenteePrioritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteePriority
     */
    omit?: MenteePriorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteePriorityInclude<ExtArgs> | null
    /**
     * Filter, which MenteePriority to fetch.
     */
    where: MenteePriorityWhereUniqueInput
  }

  /**
   * MenteePriority findUniqueOrThrow
   */
  export type MenteePriorityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteePriority
     */
    select?: MenteePrioritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteePriority
     */
    omit?: MenteePriorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteePriorityInclude<ExtArgs> | null
    /**
     * Filter, which MenteePriority to fetch.
     */
    where: MenteePriorityWhereUniqueInput
  }

  /**
   * MenteePriority findFirst
   */
  export type MenteePriorityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteePriority
     */
    select?: MenteePrioritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteePriority
     */
    omit?: MenteePriorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteePriorityInclude<ExtArgs> | null
    /**
     * Filter, which MenteePriority to fetch.
     */
    where?: MenteePriorityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteePriorities to fetch.
     */
    orderBy?: MenteePriorityOrderByWithRelationInput | MenteePriorityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenteePriorities.
     */
    cursor?: MenteePriorityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteePriorities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteePriorities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenteePriorities.
     */
    distinct?: MenteePriorityScalarFieldEnum | MenteePriorityScalarFieldEnum[]
  }

  /**
   * MenteePriority findFirstOrThrow
   */
  export type MenteePriorityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteePriority
     */
    select?: MenteePrioritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteePriority
     */
    omit?: MenteePriorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteePriorityInclude<ExtArgs> | null
    /**
     * Filter, which MenteePriority to fetch.
     */
    where?: MenteePriorityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteePriorities to fetch.
     */
    orderBy?: MenteePriorityOrderByWithRelationInput | MenteePriorityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenteePriorities.
     */
    cursor?: MenteePriorityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteePriorities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteePriorities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenteePriorities.
     */
    distinct?: MenteePriorityScalarFieldEnum | MenteePriorityScalarFieldEnum[]
  }

  /**
   * MenteePriority findMany
   */
  export type MenteePriorityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteePriority
     */
    select?: MenteePrioritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteePriority
     */
    omit?: MenteePriorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteePriorityInclude<ExtArgs> | null
    /**
     * Filter, which MenteePriorities to fetch.
     */
    where?: MenteePriorityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteePriorities to fetch.
     */
    orderBy?: MenteePriorityOrderByWithRelationInput | MenteePriorityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MenteePriorities.
     */
    cursor?: MenteePriorityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteePriorities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteePriorities.
     */
    skip?: number
    distinct?: MenteePriorityScalarFieldEnum | MenteePriorityScalarFieldEnum[]
  }

  /**
   * MenteePriority create
   */
  export type MenteePriorityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteePriority
     */
    select?: MenteePrioritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteePriority
     */
    omit?: MenteePriorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteePriorityInclude<ExtArgs> | null
    /**
     * The data needed to create a MenteePriority.
     */
    data: XOR<MenteePriorityCreateInput, MenteePriorityUncheckedCreateInput>
  }

  /**
   * MenteePriority createMany
   */
  export type MenteePriorityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MenteePriorities.
     */
    data: MenteePriorityCreateManyInput | MenteePriorityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MenteePriority createManyAndReturn
   */
  export type MenteePriorityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteePriority
     */
    select?: MenteePrioritySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenteePriority
     */
    omit?: MenteePriorityOmit<ExtArgs> | null
    /**
     * The data used to create many MenteePriorities.
     */
    data: MenteePriorityCreateManyInput | MenteePriorityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteePriorityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenteePriority update
   */
  export type MenteePriorityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteePriority
     */
    select?: MenteePrioritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteePriority
     */
    omit?: MenteePriorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteePriorityInclude<ExtArgs> | null
    /**
     * The data needed to update a MenteePriority.
     */
    data: XOR<MenteePriorityUpdateInput, MenteePriorityUncheckedUpdateInput>
    /**
     * Choose, which MenteePriority to update.
     */
    where: MenteePriorityWhereUniqueInput
  }

  /**
   * MenteePriority updateMany
   */
  export type MenteePriorityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MenteePriorities.
     */
    data: XOR<MenteePriorityUpdateManyMutationInput, MenteePriorityUncheckedUpdateManyInput>
    /**
     * Filter which MenteePriorities to update
     */
    where?: MenteePriorityWhereInput
    /**
     * Limit how many MenteePriorities to update.
     */
    limit?: number
  }

  /**
   * MenteePriority updateManyAndReturn
   */
  export type MenteePriorityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteePriority
     */
    select?: MenteePrioritySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenteePriority
     */
    omit?: MenteePriorityOmit<ExtArgs> | null
    /**
     * The data used to update MenteePriorities.
     */
    data: XOR<MenteePriorityUpdateManyMutationInput, MenteePriorityUncheckedUpdateManyInput>
    /**
     * Filter which MenteePriorities to update
     */
    where?: MenteePriorityWhereInput
    /**
     * Limit how many MenteePriorities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteePriorityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenteePriority upsert
   */
  export type MenteePriorityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteePriority
     */
    select?: MenteePrioritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteePriority
     */
    omit?: MenteePriorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteePriorityInclude<ExtArgs> | null
    /**
     * The filter to search for the MenteePriority to update in case it exists.
     */
    where: MenteePriorityWhereUniqueInput
    /**
     * In case the MenteePriority found by the `where` argument doesn't exist, create a new MenteePriority with this data.
     */
    create: XOR<MenteePriorityCreateInput, MenteePriorityUncheckedCreateInput>
    /**
     * In case the MenteePriority was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenteePriorityUpdateInput, MenteePriorityUncheckedUpdateInput>
  }

  /**
   * MenteePriority delete
   */
  export type MenteePriorityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteePriority
     */
    select?: MenteePrioritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteePriority
     */
    omit?: MenteePriorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteePriorityInclude<ExtArgs> | null
    /**
     * Filter which MenteePriority to delete.
     */
    where: MenteePriorityWhereUniqueInput
  }

  /**
   * MenteePriority deleteMany
   */
  export type MenteePriorityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenteePriorities to delete
     */
    where?: MenteePriorityWhereInput
    /**
     * Limit how many MenteePriorities to delete.
     */
    limit?: number
  }

  /**
   * MenteePriority without action
   */
  export type MenteePriorityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteePriority
     */
    select?: MenteePrioritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteePriority
     */
    omit?: MenteePriorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteePriorityInclude<ExtArgs> | null
  }


  /**
   * Model MentorLanguage
   */

  export type AggregateMentorLanguage = {
    _count: MentorLanguageCountAggregateOutputType | null
    _min: MentorLanguageMinAggregateOutputType | null
    _max: MentorLanguageMaxAggregateOutputType | null
  }

  export type MentorLanguageMinAggregateOutputType = {
    user_id: string | null
    lang_code: string | null
  }

  export type MentorLanguageMaxAggregateOutputType = {
    user_id: string | null
    lang_code: string | null
  }

  export type MentorLanguageCountAggregateOutputType = {
    user_id: number
    lang_code: number
    _all: number
  }


  export type MentorLanguageMinAggregateInputType = {
    user_id?: true
    lang_code?: true
  }

  export type MentorLanguageMaxAggregateInputType = {
    user_id?: true
    lang_code?: true
  }

  export type MentorLanguageCountAggregateInputType = {
    user_id?: true
    lang_code?: true
    _all?: true
  }

  export type MentorLanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MentorLanguage to aggregate.
     */
    where?: MentorLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorLanguages to fetch.
     */
    orderBy?: MentorLanguageOrderByWithRelationInput | MentorLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MentorLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MentorLanguages
    **/
    _count?: true | MentorLanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MentorLanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MentorLanguageMaxAggregateInputType
  }

  export type GetMentorLanguageAggregateType<T extends MentorLanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateMentorLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMentorLanguage[P]>
      : GetScalarType<T[P], AggregateMentorLanguage[P]>
  }




  export type MentorLanguageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorLanguageWhereInput
    orderBy?: MentorLanguageOrderByWithAggregationInput | MentorLanguageOrderByWithAggregationInput[]
    by: MentorLanguageScalarFieldEnum[] | MentorLanguageScalarFieldEnum
    having?: MentorLanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MentorLanguageCountAggregateInputType | true
    _min?: MentorLanguageMinAggregateInputType
    _max?: MentorLanguageMaxAggregateInputType
  }

  export type MentorLanguageGroupByOutputType = {
    user_id: string
    lang_code: string
    _count: MentorLanguageCountAggregateOutputType | null
    _min: MentorLanguageMinAggregateOutputType | null
    _max: MentorLanguageMaxAggregateOutputType | null
  }

  type GetMentorLanguageGroupByPayload<T extends MentorLanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MentorLanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MentorLanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MentorLanguageGroupByOutputType[P]>
            : GetScalarType<T[P], MentorLanguageGroupByOutputType[P]>
        }
      >
    >


  export type MentorLanguageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    lang_code?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorLanguage"]>

  export type MentorLanguageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    lang_code?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorLanguage"]>

  export type MentorLanguageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    lang_code?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorLanguage"]>

  export type MentorLanguageSelectScalar = {
    user_id?: boolean
    lang_code?: boolean
  }

  export type MentorLanguageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "lang_code", ExtArgs["result"]["mentorLanguage"]>
  export type MentorLanguageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MentorLanguageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MentorLanguageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MentorLanguagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MentorLanguage"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: string
      lang_code: string
    }, ExtArgs["result"]["mentorLanguage"]>
    composites: {}
  }

  type MentorLanguageGetPayload<S extends boolean | null | undefined | MentorLanguageDefaultArgs> = $Result.GetResult<Prisma.$MentorLanguagePayload, S>

  type MentorLanguageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MentorLanguageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MentorLanguageCountAggregateInputType | true
    }

  export interface MentorLanguageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MentorLanguage'], meta: { name: 'MentorLanguage' } }
    /**
     * Find zero or one MentorLanguage that matches the filter.
     * @param {MentorLanguageFindUniqueArgs} args - Arguments to find a MentorLanguage
     * @example
     * // Get one MentorLanguage
     * const mentorLanguage = await prisma.mentorLanguage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MentorLanguageFindUniqueArgs>(args: SelectSubset<T, MentorLanguageFindUniqueArgs<ExtArgs>>): Prisma__MentorLanguageClient<$Result.GetResult<Prisma.$MentorLanguagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MentorLanguage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MentorLanguageFindUniqueOrThrowArgs} args - Arguments to find a MentorLanguage
     * @example
     * // Get one MentorLanguage
     * const mentorLanguage = await prisma.mentorLanguage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MentorLanguageFindUniqueOrThrowArgs>(args: SelectSubset<T, MentorLanguageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MentorLanguageClient<$Result.GetResult<Prisma.$MentorLanguagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MentorLanguage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorLanguageFindFirstArgs} args - Arguments to find a MentorLanguage
     * @example
     * // Get one MentorLanguage
     * const mentorLanguage = await prisma.mentorLanguage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MentorLanguageFindFirstArgs>(args?: SelectSubset<T, MentorLanguageFindFirstArgs<ExtArgs>>): Prisma__MentorLanguageClient<$Result.GetResult<Prisma.$MentorLanguagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MentorLanguage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorLanguageFindFirstOrThrowArgs} args - Arguments to find a MentorLanguage
     * @example
     * // Get one MentorLanguage
     * const mentorLanguage = await prisma.mentorLanguage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MentorLanguageFindFirstOrThrowArgs>(args?: SelectSubset<T, MentorLanguageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MentorLanguageClient<$Result.GetResult<Prisma.$MentorLanguagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MentorLanguages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorLanguageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MentorLanguages
     * const mentorLanguages = await prisma.mentorLanguage.findMany()
     * 
     * // Get first 10 MentorLanguages
     * const mentorLanguages = await prisma.mentorLanguage.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const mentorLanguageWithUser_idOnly = await prisma.mentorLanguage.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends MentorLanguageFindManyArgs>(args?: SelectSubset<T, MentorLanguageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorLanguagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MentorLanguage.
     * @param {MentorLanguageCreateArgs} args - Arguments to create a MentorLanguage.
     * @example
     * // Create one MentorLanguage
     * const MentorLanguage = await prisma.mentorLanguage.create({
     *   data: {
     *     // ... data to create a MentorLanguage
     *   }
     * })
     * 
     */
    create<T extends MentorLanguageCreateArgs>(args: SelectSubset<T, MentorLanguageCreateArgs<ExtArgs>>): Prisma__MentorLanguageClient<$Result.GetResult<Prisma.$MentorLanguagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MentorLanguages.
     * @param {MentorLanguageCreateManyArgs} args - Arguments to create many MentorLanguages.
     * @example
     * // Create many MentorLanguages
     * const mentorLanguage = await prisma.mentorLanguage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MentorLanguageCreateManyArgs>(args?: SelectSubset<T, MentorLanguageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MentorLanguages and returns the data saved in the database.
     * @param {MentorLanguageCreateManyAndReturnArgs} args - Arguments to create many MentorLanguages.
     * @example
     * // Create many MentorLanguages
     * const mentorLanguage = await prisma.mentorLanguage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MentorLanguages and only return the `user_id`
     * const mentorLanguageWithUser_idOnly = await prisma.mentorLanguage.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MentorLanguageCreateManyAndReturnArgs>(args?: SelectSubset<T, MentorLanguageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorLanguagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MentorLanguage.
     * @param {MentorLanguageDeleteArgs} args - Arguments to delete one MentorLanguage.
     * @example
     * // Delete one MentorLanguage
     * const MentorLanguage = await prisma.mentorLanguage.delete({
     *   where: {
     *     // ... filter to delete one MentorLanguage
     *   }
     * })
     * 
     */
    delete<T extends MentorLanguageDeleteArgs>(args: SelectSubset<T, MentorLanguageDeleteArgs<ExtArgs>>): Prisma__MentorLanguageClient<$Result.GetResult<Prisma.$MentorLanguagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MentorLanguage.
     * @param {MentorLanguageUpdateArgs} args - Arguments to update one MentorLanguage.
     * @example
     * // Update one MentorLanguage
     * const mentorLanguage = await prisma.mentorLanguage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MentorLanguageUpdateArgs>(args: SelectSubset<T, MentorLanguageUpdateArgs<ExtArgs>>): Prisma__MentorLanguageClient<$Result.GetResult<Prisma.$MentorLanguagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MentorLanguages.
     * @param {MentorLanguageDeleteManyArgs} args - Arguments to filter MentorLanguages to delete.
     * @example
     * // Delete a few MentorLanguages
     * const { count } = await prisma.mentorLanguage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MentorLanguageDeleteManyArgs>(args?: SelectSubset<T, MentorLanguageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MentorLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorLanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MentorLanguages
     * const mentorLanguage = await prisma.mentorLanguage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MentorLanguageUpdateManyArgs>(args: SelectSubset<T, MentorLanguageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MentorLanguages and returns the data updated in the database.
     * @param {MentorLanguageUpdateManyAndReturnArgs} args - Arguments to update many MentorLanguages.
     * @example
     * // Update many MentorLanguages
     * const mentorLanguage = await prisma.mentorLanguage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MentorLanguages and only return the `user_id`
     * const mentorLanguageWithUser_idOnly = await prisma.mentorLanguage.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MentorLanguageUpdateManyAndReturnArgs>(args: SelectSubset<T, MentorLanguageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorLanguagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MentorLanguage.
     * @param {MentorLanguageUpsertArgs} args - Arguments to update or create a MentorLanguage.
     * @example
     * // Update or create a MentorLanguage
     * const mentorLanguage = await prisma.mentorLanguage.upsert({
     *   create: {
     *     // ... data to create a MentorLanguage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MentorLanguage we want to update
     *   }
     * })
     */
    upsert<T extends MentorLanguageUpsertArgs>(args: SelectSubset<T, MentorLanguageUpsertArgs<ExtArgs>>): Prisma__MentorLanguageClient<$Result.GetResult<Prisma.$MentorLanguagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MentorLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorLanguageCountArgs} args - Arguments to filter MentorLanguages to count.
     * @example
     * // Count the number of MentorLanguages
     * const count = await prisma.mentorLanguage.count({
     *   where: {
     *     // ... the filter for the MentorLanguages we want to count
     *   }
     * })
    **/
    count<T extends MentorLanguageCountArgs>(
      args?: Subset<T, MentorLanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MentorLanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MentorLanguage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorLanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MentorLanguageAggregateArgs>(args: Subset<T, MentorLanguageAggregateArgs>): Prisma.PrismaPromise<GetMentorLanguageAggregateType<T>>

    /**
     * Group by MentorLanguage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorLanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MentorLanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MentorLanguageGroupByArgs['orderBy'] }
        : { orderBy?: MentorLanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MentorLanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMentorLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MentorLanguage model
   */
  readonly fields: MentorLanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MentorLanguage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MentorLanguageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MentorLanguage model
   */
  interface MentorLanguageFieldRefs {
    readonly user_id: FieldRef<"MentorLanguage", 'String'>
    readonly lang_code: FieldRef<"MentorLanguage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MentorLanguage findUnique
   */
  export type MentorLanguageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorLanguage
     */
    select?: MentorLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorLanguage
     */
    omit?: MentorLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorLanguageInclude<ExtArgs> | null
    /**
     * Filter, which MentorLanguage to fetch.
     */
    where: MentorLanguageWhereUniqueInput
  }

  /**
   * MentorLanguage findUniqueOrThrow
   */
  export type MentorLanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorLanguage
     */
    select?: MentorLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorLanguage
     */
    omit?: MentorLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorLanguageInclude<ExtArgs> | null
    /**
     * Filter, which MentorLanguage to fetch.
     */
    where: MentorLanguageWhereUniqueInput
  }

  /**
   * MentorLanguage findFirst
   */
  export type MentorLanguageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorLanguage
     */
    select?: MentorLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorLanguage
     */
    omit?: MentorLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorLanguageInclude<ExtArgs> | null
    /**
     * Filter, which MentorLanguage to fetch.
     */
    where?: MentorLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorLanguages to fetch.
     */
    orderBy?: MentorLanguageOrderByWithRelationInput | MentorLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MentorLanguages.
     */
    cursor?: MentorLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MentorLanguages.
     */
    distinct?: MentorLanguageScalarFieldEnum | MentorLanguageScalarFieldEnum[]
  }

  /**
   * MentorLanguage findFirstOrThrow
   */
  export type MentorLanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorLanguage
     */
    select?: MentorLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorLanguage
     */
    omit?: MentorLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorLanguageInclude<ExtArgs> | null
    /**
     * Filter, which MentorLanguage to fetch.
     */
    where?: MentorLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorLanguages to fetch.
     */
    orderBy?: MentorLanguageOrderByWithRelationInput | MentorLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MentorLanguages.
     */
    cursor?: MentorLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MentorLanguages.
     */
    distinct?: MentorLanguageScalarFieldEnum | MentorLanguageScalarFieldEnum[]
  }

  /**
   * MentorLanguage findMany
   */
  export type MentorLanguageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorLanguage
     */
    select?: MentorLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorLanguage
     */
    omit?: MentorLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorLanguageInclude<ExtArgs> | null
    /**
     * Filter, which MentorLanguages to fetch.
     */
    where?: MentorLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorLanguages to fetch.
     */
    orderBy?: MentorLanguageOrderByWithRelationInput | MentorLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MentorLanguages.
     */
    cursor?: MentorLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorLanguages.
     */
    skip?: number
    distinct?: MentorLanguageScalarFieldEnum | MentorLanguageScalarFieldEnum[]
  }

  /**
   * MentorLanguage create
   */
  export type MentorLanguageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorLanguage
     */
    select?: MentorLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorLanguage
     */
    omit?: MentorLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorLanguageInclude<ExtArgs> | null
    /**
     * The data needed to create a MentorLanguage.
     */
    data: XOR<MentorLanguageCreateInput, MentorLanguageUncheckedCreateInput>
  }

  /**
   * MentorLanguage createMany
   */
  export type MentorLanguageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MentorLanguages.
     */
    data: MentorLanguageCreateManyInput | MentorLanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MentorLanguage createManyAndReturn
   */
  export type MentorLanguageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorLanguage
     */
    select?: MentorLanguageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MentorLanguage
     */
    omit?: MentorLanguageOmit<ExtArgs> | null
    /**
     * The data used to create many MentorLanguages.
     */
    data: MentorLanguageCreateManyInput | MentorLanguageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorLanguageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MentorLanguage update
   */
  export type MentorLanguageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorLanguage
     */
    select?: MentorLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorLanguage
     */
    omit?: MentorLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorLanguageInclude<ExtArgs> | null
    /**
     * The data needed to update a MentorLanguage.
     */
    data: XOR<MentorLanguageUpdateInput, MentorLanguageUncheckedUpdateInput>
    /**
     * Choose, which MentorLanguage to update.
     */
    where: MentorLanguageWhereUniqueInput
  }

  /**
   * MentorLanguage updateMany
   */
  export type MentorLanguageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MentorLanguages.
     */
    data: XOR<MentorLanguageUpdateManyMutationInput, MentorLanguageUncheckedUpdateManyInput>
    /**
     * Filter which MentorLanguages to update
     */
    where?: MentorLanguageWhereInput
    /**
     * Limit how many MentorLanguages to update.
     */
    limit?: number
  }

  /**
   * MentorLanguage updateManyAndReturn
   */
  export type MentorLanguageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorLanguage
     */
    select?: MentorLanguageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MentorLanguage
     */
    omit?: MentorLanguageOmit<ExtArgs> | null
    /**
     * The data used to update MentorLanguages.
     */
    data: XOR<MentorLanguageUpdateManyMutationInput, MentorLanguageUncheckedUpdateManyInput>
    /**
     * Filter which MentorLanguages to update
     */
    where?: MentorLanguageWhereInput
    /**
     * Limit how many MentorLanguages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorLanguageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MentorLanguage upsert
   */
  export type MentorLanguageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorLanguage
     */
    select?: MentorLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorLanguage
     */
    omit?: MentorLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorLanguageInclude<ExtArgs> | null
    /**
     * The filter to search for the MentorLanguage to update in case it exists.
     */
    where: MentorLanguageWhereUniqueInput
    /**
     * In case the MentorLanguage found by the `where` argument doesn't exist, create a new MentorLanguage with this data.
     */
    create: XOR<MentorLanguageCreateInput, MentorLanguageUncheckedCreateInput>
    /**
     * In case the MentorLanguage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MentorLanguageUpdateInput, MentorLanguageUncheckedUpdateInput>
  }

  /**
   * MentorLanguage delete
   */
  export type MentorLanguageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorLanguage
     */
    select?: MentorLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorLanguage
     */
    omit?: MentorLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorLanguageInclude<ExtArgs> | null
    /**
     * Filter which MentorLanguage to delete.
     */
    where: MentorLanguageWhereUniqueInput
  }

  /**
   * MentorLanguage deleteMany
   */
  export type MentorLanguageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MentorLanguages to delete
     */
    where?: MentorLanguageWhereInput
    /**
     * Limit how many MentorLanguages to delete.
     */
    limit?: number
  }

  /**
   * MentorLanguage without action
   */
  export type MentorLanguageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorLanguage
     */
    select?: MentorLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorLanguage
     */
    omit?: MentorLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorLanguageInclude<ExtArgs> | null
  }


  /**
   * Model MentorCategory
   */

  export type AggregateMentorCategory = {
    _count: MentorCategoryCountAggregateOutputType | null
    _min: MentorCategoryMinAggregateOutputType | null
    _max: MentorCategoryMaxAggregateOutputType | null
  }

  export type MentorCategoryMinAggregateOutputType = {
    user_id: string | null
    category: string | null
  }

  export type MentorCategoryMaxAggregateOutputType = {
    user_id: string | null
    category: string | null
  }

  export type MentorCategoryCountAggregateOutputType = {
    user_id: number
    category: number
    _all: number
  }


  export type MentorCategoryMinAggregateInputType = {
    user_id?: true
    category?: true
  }

  export type MentorCategoryMaxAggregateInputType = {
    user_id?: true
    category?: true
  }

  export type MentorCategoryCountAggregateInputType = {
    user_id?: true
    category?: true
    _all?: true
  }

  export type MentorCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MentorCategory to aggregate.
     */
    where?: MentorCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorCategories to fetch.
     */
    orderBy?: MentorCategoryOrderByWithRelationInput | MentorCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MentorCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MentorCategories
    **/
    _count?: true | MentorCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MentorCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MentorCategoryMaxAggregateInputType
  }

  export type GetMentorCategoryAggregateType<T extends MentorCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateMentorCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMentorCategory[P]>
      : GetScalarType<T[P], AggregateMentorCategory[P]>
  }




  export type MentorCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorCategoryWhereInput
    orderBy?: MentorCategoryOrderByWithAggregationInput | MentorCategoryOrderByWithAggregationInput[]
    by: MentorCategoryScalarFieldEnum[] | MentorCategoryScalarFieldEnum
    having?: MentorCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MentorCategoryCountAggregateInputType | true
    _min?: MentorCategoryMinAggregateInputType
    _max?: MentorCategoryMaxAggregateInputType
  }

  export type MentorCategoryGroupByOutputType = {
    user_id: string
    category: string
    _count: MentorCategoryCountAggregateOutputType | null
    _min: MentorCategoryMinAggregateOutputType | null
    _max: MentorCategoryMaxAggregateOutputType | null
  }

  type GetMentorCategoryGroupByPayload<T extends MentorCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MentorCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MentorCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MentorCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], MentorCategoryGroupByOutputType[P]>
        }
      >
    >


  export type MentorCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    category?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorCategory"]>

  export type MentorCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    category?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorCategory"]>

  export type MentorCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    category?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorCategory"]>

  export type MentorCategorySelectScalar = {
    user_id?: boolean
    category?: boolean
  }

  export type MentorCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "category", ExtArgs["result"]["mentorCategory"]>
  export type MentorCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MentorCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MentorCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MentorCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MentorCategory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: string
      category: string
    }, ExtArgs["result"]["mentorCategory"]>
    composites: {}
  }

  type MentorCategoryGetPayload<S extends boolean | null | undefined | MentorCategoryDefaultArgs> = $Result.GetResult<Prisma.$MentorCategoryPayload, S>

  type MentorCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MentorCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MentorCategoryCountAggregateInputType | true
    }

  export interface MentorCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MentorCategory'], meta: { name: 'MentorCategory' } }
    /**
     * Find zero or one MentorCategory that matches the filter.
     * @param {MentorCategoryFindUniqueArgs} args - Arguments to find a MentorCategory
     * @example
     * // Get one MentorCategory
     * const mentorCategory = await prisma.mentorCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MentorCategoryFindUniqueArgs>(args: SelectSubset<T, MentorCategoryFindUniqueArgs<ExtArgs>>): Prisma__MentorCategoryClient<$Result.GetResult<Prisma.$MentorCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MentorCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MentorCategoryFindUniqueOrThrowArgs} args - Arguments to find a MentorCategory
     * @example
     * // Get one MentorCategory
     * const mentorCategory = await prisma.mentorCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MentorCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, MentorCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MentorCategoryClient<$Result.GetResult<Prisma.$MentorCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MentorCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorCategoryFindFirstArgs} args - Arguments to find a MentorCategory
     * @example
     * // Get one MentorCategory
     * const mentorCategory = await prisma.mentorCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MentorCategoryFindFirstArgs>(args?: SelectSubset<T, MentorCategoryFindFirstArgs<ExtArgs>>): Prisma__MentorCategoryClient<$Result.GetResult<Prisma.$MentorCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MentorCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorCategoryFindFirstOrThrowArgs} args - Arguments to find a MentorCategory
     * @example
     * // Get one MentorCategory
     * const mentorCategory = await prisma.mentorCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MentorCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, MentorCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__MentorCategoryClient<$Result.GetResult<Prisma.$MentorCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MentorCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MentorCategories
     * const mentorCategories = await prisma.mentorCategory.findMany()
     * 
     * // Get first 10 MentorCategories
     * const mentorCategories = await prisma.mentorCategory.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const mentorCategoryWithUser_idOnly = await prisma.mentorCategory.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends MentorCategoryFindManyArgs>(args?: SelectSubset<T, MentorCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MentorCategory.
     * @param {MentorCategoryCreateArgs} args - Arguments to create a MentorCategory.
     * @example
     * // Create one MentorCategory
     * const MentorCategory = await prisma.mentorCategory.create({
     *   data: {
     *     // ... data to create a MentorCategory
     *   }
     * })
     * 
     */
    create<T extends MentorCategoryCreateArgs>(args: SelectSubset<T, MentorCategoryCreateArgs<ExtArgs>>): Prisma__MentorCategoryClient<$Result.GetResult<Prisma.$MentorCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MentorCategories.
     * @param {MentorCategoryCreateManyArgs} args - Arguments to create many MentorCategories.
     * @example
     * // Create many MentorCategories
     * const mentorCategory = await prisma.mentorCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MentorCategoryCreateManyArgs>(args?: SelectSubset<T, MentorCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MentorCategories and returns the data saved in the database.
     * @param {MentorCategoryCreateManyAndReturnArgs} args - Arguments to create many MentorCategories.
     * @example
     * // Create many MentorCategories
     * const mentorCategory = await prisma.mentorCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MentorCategories and only return the `user_id`
     * const mentorCategoryWithUser_idOnly = await prisma.mentorCategory.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MentorCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, MentorCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MentorCategory.
     * @param {MentorCategoryDeleteArgs} args - Arguments to delete one MentorCategory.
     * @example
     * // Delete one MentorCategory
     * const MentorCategory = await prisma.mentorCategory.delete({
     *   where: {
     *     // ... filter to delete one MentorCategory
     *   }
     * })
     * 
     */
    delete<T extends MentorCategoryDeleteArgs>(args: SelectSubset<T, MentorCategoryDeleteArgs<ExtArgs>>): Prisma__MentorCategoryClient<$Result.GetResult<Prisma.$MentorCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MentorCategory.
     * @param {MentorCategoryUpdateArgs} args - Arguments to update one MentorCategory.
     * @example
     * // Update one MentorCategory
     * const mentorCategory = await prisma.mentorCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MentorCategoryUpdateArgs>(args: SelectSubset<T, MentorCategoryUpdateArgs<ExtArgs>>): Prisma__MentorCategoryClient<$Result.GetResult<Prisma.$MentorCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MentorCategories.
     * @param {MentorCategoryDeleteManyArgs} args - Arguments to filter MentorCategories to delete.
     * @example
     * // Delete a few MentorCategories
     * const { count } = await prisma.mentorCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MentorCategoryDeleteManyArgs>(args?: SelectSubset<T, MentorCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MentorCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MentorCategories
     * const mentorCategory = await prisma.mentorCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MentorCategoryUpdateManyArgs>(args: SelectSubset<T, MentorCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MentorCategories and returns the data updated in the database.
     * @param {MentorCategoryUpdateManyAndReturnArgs} args - Arguments to update many MentorCategories.
     * @example
     * // Update many MentorCategories
     * const mentorCategory = await prisma.mentorCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MentorCategories and only return the `user_id`
     * const mentorCategoryWithUser_idOnly = await prisma.mentorCategory.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MentorCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, MentorCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MentorCategory.
     * @param {MentorCategoryUpsertArgs} args - Arguments to update or create a MentorCategory.
     * @example
     * // Update or create a MentorCategory
     * const mentorCategory = await prisma.mentorCategory.upsert({
     *   create: {
     *     // ... data to create a MentorCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MentorCategory we want to update
     *   }
     * })
     */
    upsert<T extends MentorCategoryUpsertArgs>(args: SelectSubset<T, MentorCategoryUpsertArgs<ExtArgs>>): Prisma__MentorCategoryClient<$Result.GetResult<Prisma.$MentorCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MentorCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorCategoryCountArgs} args - Arguments to filter MentorCategories to count.
     * @example
     * // Count the number of MentorCategories
     * const count = await prisma.mentorCategory.count({
     *   where: {
     *     // ... the filter for the MentorCategories we want to count
     *   }
     * })
    **/
    count<T extends MentorCategoryCountArgs>(
      args?: Subset<T, MentorCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MentorCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MentorCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MentorCategoryAggregateArgs>(args: Subset<T, MentorCategoryAggregateArgs>): Prisma.PrismaPromise<GetMentorCategoryAggregateType<T>>

    /**
     * Group by MentorCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MentorCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MentorCategoryGroupByArgs['orderBy'] }
        : { orderBy?: MentorCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MentorCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMentorCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MentorCategory model
   */
  readonly fields: MentorCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MentorCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MentorCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MentorCategory model
   */
  interface MentorCategoryFieldRefs {
    readonly user_id: FieldRef<"MentorCategory", 'String'>
    readonly category: FieldRef<"MentorCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MentorCategory findUnique
   */
  export type MentorCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorCategory
     */
    select?: MentorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorCategory
     */
    omit?: MentorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which MentorCategory to fetch.
     */
    where: MentorCategoryWhereUniqueInput
  }

  /**
   * MentorCategory findUniqueOrThrow
   */
  export type MentorCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorCategory
     */
    select?: MentorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorCategory
     */
    omit?: MentorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which MentorCategory to fetch.
     */
    where: MentorCategoryWhereUniqueInput
  }

  /**
   * MentorCategory findFirst
   */
  export type MentorCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorCategory
     */
    select?: MentorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorCategory
     */
    omit?: MentorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which MentorCategory to fetch.
     */
    where?: MentorCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorCategories to fetch.
     */
    orderBy?: MentorCategoryOrderByWithRelationInput | MentorCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MentorCategories.
     */
    cursor?: MentorCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MentorCategories.
     */
    distinct?: MentorCategoryScalarFieldEnum | MentorCategoryScalarFieldEnum[]
  }

  /**
   * MentorCategory findFirstOrThrow
   */
  export type MentorCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorCategory
     */
    select?: MentorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorCategory
     */
    omit?: MentorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which MentorCategory to fetch.
     */
    where?: MentorCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorCategories to fetch.
     */
    orderBy?: MentorCategoryOrderByWithRelationInput | MentorCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MentorCategories.
     */
    cursor?: MentorCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MentorCategories.
     */
    distinct?: MentorCategoryScalarFieldEnum | MentorCategoryScalarFieldEnum[]
  }

  /**
   * MentorCategory findMany
   */
  export type MentorCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorCategory
     */
    select?: MentorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorCategory
     */
    omit?: MentorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which MentorCategories to fetch.
     */
    where?: MentorCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorCategories to fetch.
     */
    orderBy?: MentorCategoryOrderByWithRelationInput | MentorCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MentorCategories.
     */
    cursor?: MentorCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorCategories.
     */
    skip?: number
    distinct?: MentorCategoryScalarFieldEnum | MentorCategoryScalarFieldEnum[]
  }

  /**
   * MentorCategory create
   */
  export type MentorCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorCategory
     */
    select?: MentorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorCategory
     */
    omit?: MentorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a MentorCategory.
     */
    data: XOR<MentorCategoryCreateInput, MentorCategoryUncheckedCreateInput>
  }

  /**
   * MentorCategory createMany
   */
  export type MentorCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MentorCategories.
     */
    data: MentorCategoryCreateManyInput | MentorCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MentorCategory createManyAndReturn
   */
  export type MentorCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorCategory
     */
    select?: MentorCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MentorCategory
     */
    omit?: MentorCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many MentorCategories.
     */
    data: MentorCategoryCreateManyInput | MentorCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MentorCategory update
   */
  export type MentorCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorCategory
     */
    select?: MentorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorCategory
     */
    omit?: MentorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a MentorCategory.
     */
    data: XOR<MentorCategoryUpdateInput, MentorCategoryUncheckedUpdateInput>
    /**
     * Choose, which MentorCategory to update.
     */
    where: MentorCategoryWhereUniqueInput
  }

  /**
   * MentorCategory updateMany
   */
  export type MentorCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MentorCategories.
     */
    data: XOR<MentorCategoryUpdateManyMutationInput, MentorCategoryUncheckedUpdateManyInput>
    /**
     * Filter which MentorCategories to update
     */
    where?: MentorCategoryWhereInput
    /**
     * Limit how many MentorCategories to update.
     */
    limit?: number
  }

  /**
   * MentorCategory updateManyAndReturn
   */
  export type MentorCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorCategory
     */
    select?: MentorCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MentorCategory
     */
    omit?: MentorCategoryOmit<ExtArgs> | null
    /**
     * The data used to update MentorCategories.
     */
    data: XOR<MentorCategoryUpdateManyMutationInput, MentorCategoryUncheckedUpdateManyInput>
    /**
     * Filter which MentorCategories to update
     */
    where?: MentorCategoryWhereInput
    /**
     * Limit how many MentorCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MentorCategory upsert
   */
  export type MentorCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorCategory
     */
    select?: MentorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorCategory
     */
    omit?: MentorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the MentorCategory to update in case it exists.
     */
    where: MentorCategoryWhereUniqueInput
    /**
     * In case the MentorCategory found by the `where` argument doesn't exist, create a new MentorCategory with this data.
     */
    create: XOR<MentorCategoryCreateInput, MentorCategoryUncheckedCreateInput>
    /**
     * In case the MentorCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MentorCategoryUpdateInput, MentorCategoryUncheckedUpdateInput>
  }

  /**
   * MentorCategory delete
   */
  export type MentorCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorCategory
     */
    select?: MentorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorCategory
     */
    omit?: MentorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorCategoryInclude<ExtArgs> | null
    /**
     * Filter which MentorCategory to delete.
     */
    where: MentorCategoryWhereUniqueInput
  }

  /**
   * MentorCategory deleteMany
   */
  export type MentorCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MentorCategories to delete
     */
    where?: MentorCategoryWhereInput
    /**
     * Limit how many MentorCategories to delete.
     */
    limit?: number
  }

  /**
   * MentorCategory without action
   */
  export type MentorCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorCategory
     */
    select?: MentorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorCategory
     */
    omit?: MentorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorCategoryInclude<ExtArgs> | null
  }


  /**
   * Model MentorSkill
   */

  export type AggregateMentorSkill = {
    _count: MentorSkillCountAggregateOutputType | null
    _min: MentorSkillMinAggregateOutputType | null
    _max: MentorSkillMaxAggregateOutputType | null
  }

  export type MentorSkillMinAggregateOutputType = {
    user_id: string | null
    skill: string | null
  }

  export type MentorSkillMaxAggregateOutputType = {
    user_id: string | null
    skill: string | null
  }

  export type MentorSkillCountAggregateOutputType = {
    user_id: number
    skill: number
    _all: number
  }


  export type MentorSkillMinAggregateInputType = {
    user_id?: true
    skill?: true
  }

  export type MentorSkillMaxAggregateInputType = {
    user_id?: true
    skill?: true
  }

  export type MentorSkillCountAggregateInputType = {
    user_id?: true
    skill?: true
    _all?: true
  }

  export type MentorSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MentorSkill to aggregate.
     */
    where?: MentorSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorSkills to fetch.
     */
    orderBy?: MentorSkillOrderByWithRelationInput | MentorSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MentorSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MentorSkills
    **/
    _count?: true | MentorSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MentorSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MentorSkillMaxAggregateInputType
  }

  export type GetMentorSkillAggregateType<T extends MentorSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateMentorSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMentorSkill[P]>
      : GetScalarType<T[P], AggregateMentorSkill[P]>
  }




  export type MentorSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorSkillWhereInput
    orderBy?: MentorSkillOrderByWithAggregationInput | MentorSkillOrderByWithAggregationInput[]
    by: MentorSkillScalarFieldEnum[] | MentorSkillScalarFieldEnum
    having?: MentorSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MentorSkillCountAggregateInputType | true
    _min?: MentorSkillMinAggregateInputType
    _max?: MentorSkillMaxAggregateInputType
  }

  export type MentorSkillGroupByOutputType = {
    user_id: string
    skill: string
    _count: MentorSkillCountAggregateOutputType | null
    _min: MentorSkillMinAggregateOutputType | null
    _max: MentorSkillMaxAggregateOutputType | null
  }

  type GetMentorSkillGroupByPayload<T extends MentorSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MentorSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MentorSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MentorSkillGroupByOutputType[P]>
            : GetScalarType<T[P], MentorSkillGroupByOutputType[P]>
        }
      >
    >


  export type MentorSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    skill?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorSkill"]>

  export type MentorSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    skill?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorSkill"]>

  export type MentorSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    skill?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorSkill"]>

  export type MentorSkillSelectScalar = {
    user_id?: boolean
    skill?: boolean
  }

  export type MentorSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "skill", ExtArgs["result"]["mentorSkill"]>
  export type MentorSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MentorSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MentorSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MentorSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MentorSkill"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: string
      skill: string
    }, ExtArgs["result"]["mentorSkill"]>
    composites: {}
  }

  type MentorSkillGetPayload<S extends boolean | null | undefined | MentorSkillDefaultArgs> = $Result.GetResult<Prisma.$MentorSkillPayload, S>

  type MentorSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MentorSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MentorSkillCountAggregateInputType | true
    }

  export interface MentorSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MentorSkill'], meta: { name: 'MentorSkill' } }
    /**
     * Find zero or one MentorSkill that matches the filter.
     * @param {MentorSkillFindUniqueArgs} args - Arguments to find a MentorSkill
     * @example
     * // Get one MentorSkill
     * const mentorSkill = await prisma.mentorSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MentorSkillFindUniqueArgs>(args: SelectSubset<T, MentorSkillFindUniqueArgs<ExtArgs>>): Prisma__MentorSkillClient<$Result.GetResult<Prisma.$MentorSkillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MentorSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MentorSkillFindUniqueOrThrowArgs} args - Arguments to find a MentorSkill
     * @example
     * // Get one MentorSkill
     * const mentorSkill = await prisma.mentorSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MentorSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, MentorSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MentorSkillClient<$Result.GetResult<Prisma.$MentorSkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MentorSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorSkillFindFirstArgs} args - Arguments to find a MentorSkill
     * @example
     * // Get one MentorSkill
     * const mentorSkill = await prisma.mentorSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MentorSkillFindFirstArgs>(args?: SelectSubset<T, MentorSkillFindFirstArgs<ExtArgs>>): Prisma__MentorSkillClient<$Result.GetResult<Prisma.$MentorSkillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MentorSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorSkillFindFirstOrThrowArgs} args - Arguments to find a MentorSkill
     * @example
     * // Get one MentorSkill
     * const mentorSkill = await prisma.mentorSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MentorSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, MentorSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__MentorSkillClient<$Result.GetResult<Prisma.$MentorSkillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MentorSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MentorSkills
     * const mentorSkills = await prisma.mentorSkill.findMany()
     * 
     * // Get first 10 MentorSkills
     * const mentorSkills = await prisma.mentorSkill.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const mentorSkillWithUser_idOnly = await prisma.mentorSkill.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends MentorSkillFindManyArgs>(args?: SelectSubset<T, MentorSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MentorSkill.
     * @param {MentorSkillCreateArgs} args - Arguments to create a MentorSkill.
     * @example
     * // Create one MentorSkill
     * const MentorSkill = await prisma.mentorSkill.create({
     *   data: {
     *     // ... data to create a MentorSkill
     *   }
     * })
     * 
     */
    create<T extends MentorSkillCreateArgs>(args: SelectSubset<T, MentorSkillCreateArgs<ExtArgs>>): Prisma__MentorSkillClient<$Result.GetResult<Prisma.$MentorSkillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MentorSkills.
     * @param {MentorSkillCreateManyArgs} args - Arguments to create many MentorSkills.
     * @example
     * // Create many MentorSkills
     * const mentorSkill = await prisma.mentorSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MentorSkillCreateManyArgs>(args?: SelectSubset<T, MentorSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MentorSkills and returns the data saved in the database.
     * @param {MentorSkillCreateManyAndReturnArgs} args - Arguments to create many MentorSkills.
     * @example
     * // Create many MentorSkills
     * const mentorSkill = await prisma.mentorSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MentorSkills and only return the `user_id`
     * const mentorSkillWithUser_idOnly = await prisma.mentorSkill.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MentorSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, MentorSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorSkillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MentorSkill.
     * @param {MentorSkillDeleteArgs} args - Arguments to delete one MentorSkill.
     * @example
     * // Delete one MentorSkill
     * const MentorSkill = await prisma.mentorSkill.delete({
     *   where: {
     *     // ... filter to delete one MentorSkill
     *   }
     * })
     * 
     */
    delete<T extends MentorSkillDeleteArgs>(args: SelectSubset<T, MentorSkillDeleteArgs<ExtArgs>>): Prisma__MentorSkillClient<$Result.GetResult<Prisma.$MentorSkillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MentorSkill.
     * @param {MentorSkillUpdateArgs} args - Arguments to update one MentorSkill.
     * @example
     * // Update one MentorSkill
     * const mentorSkill = await prisma.mentorSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MentorSkillUpdateArgs>(args: SelectSubset<T, MentorSkillUpdateArgs<ExtArgs>>): Prisma__MentorSkillClient<$Result.GetResult<Prisma.$MentorSkillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MentorSkills.
     * @param {MentorSkillDeleteManyArgs} args - Arguments to filter MentorSkills to delete.
     * @example
     * // Delete a few MentorSkills
     * const { count } = await prisma.mentorSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MentorSkillDeleteManyArgs>(args?: SelectSubset<T, MentorSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MentorSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MentorSkills
     * const mentorSkill = await prisma.mentorSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MentorSkillUpdateManyArgs>(args: SelectSubset<T, MentorSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MentorSkills and returns the data updated in the database.
     * @param {MentorSkillUpdateManyAndReturnArgs} args - Arguments to update many MentorSkills.
     * @example
     * // Update many MentorSkills
     * const mentorSkill = await prisma.mentorSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MentorSkills and only return the `user_id`
     * const mentorSkillWithUser_idOnly = await prisma.mentorSkill.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MentorSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, MentorSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorSkillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MentorSkill.
     * @param {MentorSkillUpsertArgs} args - Arguments to update or create a MentorSkill.
     * @example
     * // Update or create a MentorSkill
     * const mentorSkill = await prisma.mentorSkill.upsert({
     *   create: {
     *     // ... data to create a MentorSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MentorSkill we want to update
     *   }
     * })
     */
    upsert<T extends MentorSkillUpsertArgs>(args: SelectSubset<T, MentorSkillUpsertArgs<ExtArgs>>): Prisma__MentorSkillClient<$Result.GetResult<Prisma.$MentorSkillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MentorSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorSkillCountArgs} args - Arguments to filter MentorSkills to count.
     * @example
     * // Count the number of MentorSkills
     * const count = await prisma.mentorSkill.count({
     *   where: {
     *     // ... the filter for the MentorSkills we want to count
     *   }
     * })
    **/
    count<T extends MentorSkillCountArgs>(
      args?: Subset<T, MentorSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MentorSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MentorSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MentorSkillAggregateArgs>(args: Subset<T, MentorSkillAggregateArgs>): Prisma.PrismaPromise<GetMentorSkillAggregateType<T>>

    /**
     * Group by MentorSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MentorSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MentorSkillGroupByArgs['orderBy'] }
        : { orderBy?: MentorSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MentorSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMentorSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MentorSkill model
   */
  readonly fields: MentorSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MentorSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MentorSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MentorSkill model
   */
  interface MentorSkillFieldRefs {
    readonly user_id: FieldRef<"MentorSkill", 'String'>
    readonly skill: FieldRef<"MentorSkill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MentorSkill findUnique
   */
  export type MentorSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorSkill
     */
    select?: MentorSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorSkill
     */
    omit?: MentorSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSkillInclude<ExtArgs> | null
    /**
     * Filter, which MentorSkill to fetch.
     */
    where: MentorSkillWhereUniqueInput
  }

  /**
   * MentorSkill findUniqueOrThrow
   */
  export type MentorSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorSkill
     */
    select?: MentorSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorSkill
     */
    omit?: MentorSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSkillInclude<ExtArgs> | null
    /**
     * Filter, which MentorSkill to fetch.
     */
    where: MentorSkillWhereUniqueInput
  }

  /**
   * MentorSkill findFirst
   */
  export type MentorSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorSkill
     */
    select?: MentorSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorSkill
     */
    omit?: MentorSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSkillInclude<ExtArgs> | null
    /**
     * Filter, which MentorSkill to fetch.
     */
    where?: MentorSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorSkills to fetch.
     */
    orderBy?: MentorSkillOrderByWithRelationInput | MentorSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MentorSkills.
     */
    cursor?: MentorSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MentorSkills.
     */
    distinct?: MentorSkillScalarFieldEnum | MentorSkillScalarFieldEnum[]
  }

  /**
   * MentorSkill findFirstOrThrow
   */
  export type MentorSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorSkill
     */
    select?: MentorSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorSkill
     */
    omit?: MentorSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSkillInclude<ExtArgs> | null
    /**
     * Filter, which MentorSkill to fetch.
     */
    where?: MentorSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorSkills to fetch.
     */
    orderBy?: MentorSkillOrderByWithRelationInput | MentorSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MentorSkills.
     */
    cursor?: MentorSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MentorSkills.
     */
    distinct?: MentorSkillScalarFieldEnum | MentorSkillScalarFieldEnum[]
  }

  /**
   * MentorSkill findMany
   */
  export type MentorSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorSkill
     */
    select?: MentorSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorSkill
     */
    omit?: MentorSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSkillInclude<ExtArgs> | null
    /**
     * Filter, which MentorSkills to fetch.
     */
    where?: MentorSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorSkills to fetch.
     */
    orderBy?: MentorSkillOrderByWithRelationInput | MentorSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MentorSkills.
     */
    cursor?: MentorSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorSkills.
     */
    skip?: number
    distinct?: MentorSkillScalarFieldEnum | MentorSkillScalarFieldEnum[]
  }

  /**
   * MentorSkill create
   */
  export type MentorSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorSkill
     */
    select?: MentorSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorSkill
     */
    omit?: MentorSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a MentorSkill.
     */
    data: XOR<MentorSkillCreateInput, MentorSkillUncheckedCreateInput>
  }

  /**
   * MentorSkill createMany
   */
  export type MentorSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MentorSkills.
     */
    data: MentorSkillCreateManyInput | MentorSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MentorSkill createManyAndReturn
   */
  export type MentorSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorSkill
     */
    select?: MentorSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MentorSkill
     */
    omit?: MentorSkillOmit<ExtArgs> | null
    /**
     * The data used to create many MentorSkills.
     */
    data: MentorSkillCreateManyInput | MentorSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MentorSkill update
   */
  export type MentorSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorSkill
     */
    select?: MentorSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorSkill
     */
    omit?: MentorSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a MentorSkill.
     */
    data: XOR<MentorSkillUpdateInput, MentorSkillUncheckedUpdateInput>
    /**
     * Choose, which MentorSkill to update.
     */
    where: MentorSkillWhereUniqueInput
  }

  /**
   * MentorSkill updateMany
   */
  export type MentorSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MentorSkills.
     */
    data: XOR<MentorSkillUpdateManyMutationInput, MentorSkillUncheckedUpdateManyInput>
    /**
     * Filter which MentorSkills to update
     */
    where?: MentorSkillWhereInput
    /**
     * Limit how many MentorSkills to update.
     */
    limit?: number
  }

  /**
   * MentorSkill updateManyAndReturn
   */
  export type MentorSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorSkill
     */
    select?: MentorSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MentorSkill
     */
    omit?: MentorSkillOmit<ExtArgs> | null
    /**
     * The data used to update MentorSkills.
     */
    data: XOR<MentorSkillUpdateManyMutationInput, MentorSkillUncheckedUpdateManyInput>
    /**
     * Filter which MentorSkills to update
     */
    where?: MentorSkillWhereInput
    /**
     * Limit how many MentorSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MentorSkill upsert
   */
  export type MentorSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorSkill
     */
    select?: MentorSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorSkill
     */
    omit?: MentorSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the MentorSkill to update in case it exists.
     */
    where: MentorSkillWhereUniqueInput
    /**
     * In case the MentorSkill found by the `where` argument doesn't exist, create a new MentorSkill with this data.
     */
    create: XOR<MentorSkillCreateInput, MentorSkillUncheckedCreateInput>
    /**
     * In case the MentorSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MentorSkillUpdateInput, MentorSkillUncheckedUpdateInput>
  }

  /**
   * MentorSkill delete
   */
  export type MentorSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorSkill
     */
    select?: MentorSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorSkill
     */
    omit?: MentorSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSkillInclude<ExtArgs> | null
    /**
     * Filter which MentorSkill to delete.
     */
    where: MentorSkillWhereUniqueInput
  }

  /**
   * MentorSkill deleteMany
   */
  export type MentorSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MentorSkills to delete
     */
    where?: MentorSkillWhereInput
    /**
     * Limit how many MentorSkills to delete.
     */
    limit?: number
  }

  /**
   * MentorSkill without action
   */
  export type MentorSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorSkill
     */
    select?: MentorSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorSkill
     */
    omit?: MentorSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSkillInclude<ExtArgs> | null
  }


  /**
   * Model MenteeServiceFocus
   */

  export type AggregateMenteeServiceFocus = {
    _count: MenteeServiceFocusCountAggregateOutputType | null
    _min: MenteeServiceFocusMinAggregateOutputType | null
    _max: MenteeServiceFocusMaxAggregateOutputType | null
  }

  export type MenteeServiceFocusMinAggregateOutputType = {
    user_id: string | null
    service_focus_id: string | null
  }

  export type MenteeServiceFocusMaxAggregateOutputType = {
    user_id: string | null
    service_focus_id: string | null
  }

  export type MenteeServiceFocusCountAggregateOutputType = {
    user_id: number
    service_focus_id: number
    _all: number
  }


  export type MenteeServiceFocusMinAggregateInputType = {
    user_id?: true
    service_focus_id?: true
  }

  export type MenteeServiceFocusMaxAggregateInputType = {
    user_id?: true
    service_focus_id?: true
  }

  export type MenteeServiceFocusCountAggregateInputType = {
    user_id?: true
    service_focus_id?: true
    _all?: true
  }

  export type MenteeServiceFocusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenteeServiceFocus to aggregate.
     */
    where?: MenteeServiceFocusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteeServiceFoci to fetch.
     */
    orderBy?: MenteeServiceFocusOrderByWithRelationInput | MenteeServiceFocusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenteeServiceFocusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteeServiceFoci from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteeServiceFoci.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MenteeServiceFoci
    **/
    _count?: true | MenteeServiceFocusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenteeServiceFocusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenteeServiceFocusMaxAggregateInputType
  }

  export type GetMenteeServiceFocusAggregateType<T extends MenteeServiceFocusAggregateArgs> = {
        [P in keyof T & keyof AggregateMenteeServiceFocus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenteeServiceFocus[P]>
      : GetScalarType<T[P], AggregateMenteeServiceFocus[P]>
  }




  export type MenteeServiceFocusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenteeServiceFocusWhereInput
    orderBy?: MenteeServiceFocusOrderByWithAggregationInput | MenteeServiceFocusOrderByWithAggregationInput[]
    by: MenteeServiceFocusScalarFieldEnum[] | MenteeServiceFocusScalarFieldEnum
    having?: MenteeServiceFocusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenteeServiceFocusCountAggregateInputType | true
    _min?: MenteeServiceFocusMinAggregateInputType
    _max?: MenteeServiceFocusMaxAggregateInputType
  }

  export type MenteeServiceFocusGroupByOutputType = {
    user_id: string
    service_focus_id: string
    _count: MenteeServiceFocusCountAggregateOutputType | null
    _min: MenteeServiceFocusMinAggregateOutputType | null
    _max: MenteeServiceFocusMaxAggregateOutputType | null
  }

  type GetMenteeServiceFocusGroupByPayload<T extends MenteeServiceFocusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenteeServiceFocusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenteeServiceFocusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenteeServiceFocusGroupByOutputType[P]>
            : GetScalarType<T[P], MenteeServiceFocusGroupByOutputType[P]>
        }
      >
    >


  export type MenteeServiceFocusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    service_focus_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    service_focus?: boolean | ServiceFocusRefDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menteeServiceFocus"]>

  export type MenteeServiceFocusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    service_focus_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    service_focus?: boolean | ServiceFocusRefDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menteeServiceFocus"]>

  export type MenteeServiceFocusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    service_focus_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    service_focus?: boolean | ServiceFocusRefDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menteeServiceFocus"]>

  export type MenteeServiceFocusSelectScalar = {
    user_id?: boolean
    service_focus_id?: boolean
  }

  export type MenteeServiceFocusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "service_focus_id", ExtArgs["result"]["menteeServiceFocus"]>
  export type MenteeServiceFocusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    service_focus?: boolean | ServiceFocusRefDefaultArgs<ExtArgs>
  }
  export type MenteeServiceFocusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    service_focus?: boolean | ServiceFocusRefDefaultArgs<ExtArgs>
  }
  export type MenteeServiceFocusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    service_focus?: boolean | ServiceFocusRefDefaultArgs<ExtArgs>
  }

  export type $MenteeServiceFocusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MenteeServiceFocus"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      service_focus: Prisma.$ServiceFocusRefPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: string
      service_focus_id: string
    }, ExtArgs["result"]["menteeServiceFocus"]>
    composites: {}
  }

  type MenteeServiceFocusGetPayload<S extends boolean | null | undefined | MenteeServiceFocusDefaultArgs> = $Result.GetResult<Prisma.$MenteeServiceFocusPayload, S>

  type MenteeServiceFocusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MenteeServiceFocusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MenteeServiceFocusCountAggregateInputType | true
    }

  export interface MenteeServiceFocusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MenteeServiceFocus'], meta: { name: 'MenteeServiceFocus' } }
    /**
     * Find zero or one MenteeServiceFocus that matches the filter.
     * @param {MenteeServiceFocusFindUniqueArgs} args - Arguments to find a MenteeServiceFocus
     * @example
     * // Get one MenteeServiceFocus
     * const menteeServiceFocus = await prisma.menteeServiceFocus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenteeServiceFocusFindUniqueArgs>(args: SelectSubset<T, MenteeServiceFocusFindUniqueArgs<ExtArgs>>): Prisma__MenteeServiceFocusClient<$Result.GetResult<Prisma.$MenteeServiceFocusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MenteeServiceFocus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MenteeServiceFocusFindUniqueOrThrowArgs} args - Arguments to find a MenteeServiceFocus
     * @example
     * // Get one MenteeServiceFocus
     * const menteeServiceFocus = await prisma.menteeServiceFocus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenteeServiceFocusFindUniqueOrThrowArgs>(args: SelectSubset<T, MenteeServiceFocusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MenteeServiceFocusClient<$Result.GetResult<Prisma.$MenteeServiceFocusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenteeServiceFocus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeServiceFocusFindFirstArgs} args - Arguments to find a MenteeServiceFocus
     * @example
     * // Get one MenteeServiceFocus
     * const menteeServiceFocus = await prisma.menteeServiceFocus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenteeServiceFocusFindFirstArgs>(args?: SelectSubset<T, MenteeServiceFocusFindFirstArgs<ExtArgs>>): Prisma__MenteeServiceFocusClient<$Result.GetResult<Prisma.$MenteeServiceFocusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenteeServiceFocus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeServiceFocusFindFirstOrThrowArgs} args - Arguments to find a MenteeServiceFocus
     * @example
     * // Get one MenteeServiceFocus
     * const menteeServiceFocus = await prisma.menteeServiceFocus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenteeServiceFocusFindFirstOrThrowArgs>(args?: SelectSubset<T, MenteeServiceFocusFindFirstOrThrowArgs<ExtArgs>>): Prisma__MenteeServiceFocusClient<$Result.GetResult<Prisma.$MenteeServiceFocusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MenteeServiceFoci that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeServiceFocusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MenteeServiceFoci
     * const menteeServiceFoci = await prisma.menteeServiceFocus.findMany()
     * 
     * // Get first 10 MenteeServiceFoci
     * const menteeServiceFoci = await prisma.menteeServiceFocus.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const menteeServiceFocusWithUser_idOnly = await prisma.menteeServiceFocus.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends MenteeServiceFocusFindManyArgs>(args?: SelectSubset<T, MenteeServiceFocusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteeServiceFocusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MenteeServiceFocus.
     * @param {MenteeServiceFocusCreateArgs} args - Arguments to create a MenteeServiceFocus.
     * @example
     * // Create one MenteeServiceFocus
     * const MenteeServiceFocus = await prisma.menteeServiceFocus.create({
     *   data: {
     *     // ... data to create a MenteeServiceFocus
     *   }
     * })
     * 
     */
    create<T extends MenteeServiceFocusCreateArgs>(args: SelectSubset<T, MenteeServiceFocusCreateArgs<ExtArgs>>): Prisma__MenteeServiceFocusClient<$Result.GetResult<Prisma.$MenteeServiceFocusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MenteeServiceFoci.
     * @param {MenteeServiceFocusCreateManyArgs} args - Arguments to create many MenteeServiceFoci.
     * @example
     * // Create many MenteeServiceFoci
     * const menteeServiceFocus = await prisma.menteeServiceFocus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MenteeServiceFocusCreateManyArgs>(args?: SelectSubset<T, MenteeServiceFocusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MenteeServiceFoci and returns the data saved in the database.
     * @param {MenteeServiceFocusCreateManyAndReturnArgs} args - Arguments to create many MenteeServiceFoci.
     * @example
     * // Create many MenteeServiceFoci
     * const menteeServiceFocus = await prisma.menteeServiceFocus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MenteeServiceFoci and only return the `user_id`
     * const menteeServiceFocusWithUser_idOnly = await prisma.menteeServiceFocus.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MenteeServiceFocusCreateManyAndReturnArgs>(args?: SelectSubset<T, MenteeServiceFocusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteeServiceFocusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MenteeServiceFocus.
     * @param {MenteeServiceFocusDeleteArgs} args - Arguments to delete one MenteeServiceFocus.
     * @example
     * // Delete one MenteeServiceFocus
     * const MenteeServiceFocus = await prisma.menteeServiceFocus.delete({
     *   where: {
     *     // ... filter to delete one MenteeServiceFocus
     *   }
     * })
     * 
     */
    delete<T extends MenteeServiceFocusDeleteArgs>(args: SelectSubset<T, MenteeServiceFocusDeleteArgs<ExtArgs>>): Prisma__MenteeServiceFocusClient<$Result.GetResult<Prisma.$MenteeServiceFocusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MenteeServiceFocus.
     * @param {MenteeServiceFocusUpdateArgs} args - Arguments to update one MenteeServiceFocus.
     * @example
     * // Update one MenteeServiceFocus
     * const menteeServiceFocus = await prisma.menteeServiceFocus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MenteeServiceFocusUpdateArgs>(args: SelectSubset<T, MenteeServiceFocusUpdateArgs<ExtArgs>>): Prisma__MenteeServiceFocusClient<$Result.GetResult<Prisma.$MenteeServiceFocusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MenteeServiceFoci.
     * @param {MenteeServiceFocusDeleteManyArgs} args - Arguments to filter MenteeServiceFoci to delete.
     * @example
     * // Delete a few MenteeServiceFoci
     * const { count } = await prisma.menteeServiceFocus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MenteeServiceFocusDeleteManyArgs>(args?: SelectSubset<T, MenteeServiceFocusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenteeServiceFoci.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeServiceFocusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MenteeServiceFoci
     * const menteeServiceFocus = await prisma.menteeServiceFocus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MenteeServiceFocusUpdateManyArgs>(args: SelectSubset<T, MenteeServiceFocusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenteeServiceFoci and returns the data updated in the database.
     * @param {MenteeServiceFocusUpdateManyAndReturnArgs} args - Arguments to update many MenteeServiceFoci.
     * @example
     * // Update many MenteeServiceFoci
     * const menteeServiceFocus = await prisma.menteeServiceFocus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MenteeServiceFoci and only return the `user_id`
     * const menteeServiceFocusWithUser_idOnly = await prisma.menteeServiceFocus.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MenteeServiceFocusUpdateManyAndReturnArgs>(args: SelectSubset<T, MenteeServiceFocusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteeServiceFocusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MenteeServiceFocus.
     * @param {MenteeServiceFocusUpsertArgs} args - Arguments to update or create a MenteeServiceFocus.
     * @example
     * // Update or create a MenteeServiceFocus
     * const menteeServiceFocus = await prisma.menteeServiceFocus.upsert({
     *   create: {
     *     // ... data to create a MenteeServiceFocus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MenteeServiceFocus we want to update
     *   }
     * })
     */
    upsert<T extends MenteeServiceFocusUpsertArgs>(args: SelectSubset<T, MenteeServiceFocusUpsertArgs<ExtArgs>>): Prisma__MenteeServiceFocusClient<$Result.GetResult<Prisma.$MenteeServiceFocusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MenteeServiceFoci.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeServiceFocusCountArgs} args - Arguments to filter MenteeServiceFoci to count.
     * @example
     * // Count the number of MenteeServiceFoci
     * const count = await prisma.menteeServiceFocus.count({
     *   where: {
     *     // ... the filter for the MenteeServiceFoci we want to count
     *   }
     * })
    **/
    count<T extends MenteeServiceFocusCountArgs>(
      args?: Subset<T, MenteeServiceFocusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenteeServiceFocusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MenteeServiceFocus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeServiceFocusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenteeServiceFocusAggregateArgs>(args: Subset<T, MenteeServiceFocusAggregateArgs>): Prisma.PrismaPromise<GetMenteeServiceFocusAggregateType<T>>

    /**
     * Group by MenteeServiceFocus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeServiceFocusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenteeServiceFocusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenteeServiceFocusGroupByArgs['orderBy'] }
        : { orderBy?: MenteeServiceFocusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenteeServiceFocusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenteeServiceFocusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MenteeServiceFocus model
   */
  readonly fields: MenteeServiceFocusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MenteeServiceFocus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenteeServiceFocusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service_focus<T extends ServiceFocusRefDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceFocusRefDefaultArgs<ExtArgs>>): Prisma__ServiceFocusRefClient<$Result.GetResult<Prisma.$ServiceFocusRefPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MenteeServiceFocus model
   */
  interface MenteeServiceFocusFieldRefs {
    readonly user_id: FieldRef<"MenteeServiceFocus", 'String'>
    readonly service_focus_id: FieldRef<"MenteeServiceFocus", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MenteeServiceFocus findUnique
   */
  export type MenteeServiceFocusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeServiceFocus
     */
    select?: MenteeServiceFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeServiceFocus
     */
    omit?: MenteeServiceFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeServiceFocusInclude<ExtArgs> | null
    /**
     * Filter, which MenteeServiceFocus to fetch.
     */
    where: MenteeServiceFocusWhereUniqueInput
  }

  /**
   * MenteeServiceFocus findUniqueOrThrow
   */
  export type MenteeServiceFocusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeServiceFocus
     */
    select?: MenteeServiceFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeServiceFocus
     */
    omit?: MenteeServiceFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeServiceFocusInclude<ExtArgs> | null
    /**
     * Filter, which MenteeServiceFocus to fetch.
     */
    where: MenteeServiceFocusWhereUniqueInput
  }

  /**
   * MenteeServiceFocus findFirst
   */
  export type MenteeServiceFocusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeServiceFocus
     */
    select?: MenteeServiceFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeServiceFocus
     */
    omit?: MenteeServiceFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeServiceFocusInclude<ExtArgs> | null
    /**
     * Filter, which MenteeServiceFocus to fetch.
     */
    where?: MenteeServiceFocusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteeServiceFoci to fetch.
     */
    orderBy?: MenteeServiceFocusOrderByWithRelationInput | MenteeServiceFocusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenteeServiceFoci.
     */
    cursor?: MenteeServiceFocusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteeServiceFoci from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteeServiceFoci.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenteeServiceFoci.
     */
    distinct?: MenteeServiceFocusScalarFieldEnum | MenteeServiceFocusScalarFieldEnum[]
  }

  /**
   * MenteeServiceFocus findFirstOrThrow
   */
  export type MenteeServiceFocusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeServiceFocus
     */
    select?: MenteeServiceFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeServiceFocus
     */
    omit?: MenteeServiceFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeServiceFocusInclude<ExtArgs> | null
    /**
     * Filter, which MenteeServiceFocus to fetch.
     */
    where?: MenteeServiceFocusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteeServiceFoci to fetch.
     */
    orderBy?: MenteeServiceFocusOrderByWithRelationInput | MenteeServiceFocusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenteeServiceFoci.
     */
    cursor?: MenteeServiceFocusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteeServiceFoci from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteeServiceFoci.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenteeServiceFoci.
     */
    distinct?: MenteeServiceFocusScalarFieldEnum | MenteeServiceFocusScalarFieldEnum[]
  }

  /**
   * MenteeServiceFocus findMany
   */
  export type MenteeServiceFocusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeServiceFocus
     */
    select?: MenteeServiceFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeServiceFocus
     */
    omit?: MenteeServiceFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeServiceFocusInclude<ExtArgs> | null
    /**
     * Filter, which MenteeServiceFoci to fetch.
     */
    where?: MenteeServiceFocusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteeServiceFoci to fetch.
     */
    orderBy?: MenteeServiceFocusOrderByWithRelationInput | MenteeServiceFocusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MenteeServiceFoci.
     */
    cursor?: MenteeServiceFocusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteeServiceFoci from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteeServiceFoci.
     */
    skip?: number
    distinct?: MenteeServiceFocusScalarFieldEnum | MenteeServiceFocusScalarFieldEnum[]
  }

  /**
   * MenteeServiceFocus create
   */
  export type MenteeServiceFocusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeServiceFocus
     */
    select?: MenteeServiceFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeServiceFocus
     */
    omit?: MenteeServiceFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeServiceFocusInclude<ExtArgs> | null
    /**
     * The data needed to create a MenteeServiceFocus.
     */
    data: XOR<MenteeServiceFocusCreateInput, MenteeServiceFocusUncheckedCreateInput>
  }

  /**
   * MenteeServiceFocus createMany
   */
  export type MenteeServiceFocusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MenteeServiceFoci.
     */
    data: MenteeServiceFocusCreateManyInput | MenteeServiceFocusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MenteeServiceFocus createManyAndReturn
   */
  export type MenteeServiceFocusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeServiceFocus
     */
    select?: MenteeServiceFocusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeServiceFocus
     */
    omit?: MenteeServiceFocusOmit<ExtArgs> | null
    /**
     * The data used to create many MenteeServiceFoci.
     */
    data: MenteeServiceFocusCreateManyInput | MenteeServiceFocusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeServiceFocusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenteeServiceFocus update
   */
  export type MenteeServiceFocusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeServiceFocus
     */
    select?: MenteeServiceFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeServiceFocus
     */
    omit?: MenteeServiceFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeServiceFocusInclude<ExtArgs> | null
    /**
     * The data needed to update a MenteeServiceFocus.
     */
    data: XOR<MenteeServiceFocusUpdateInput, MenteeServiceFocusUncheckedUpdateInput>
    /**
     * Choose, which MenteeServiceFocus to update.
     */
    where: MenteeServiceFocusWhereUniqueInput
  }

  /**
   * MenteeServiceFocus updateMany
   */
  export type MenteeServiceFocusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MenteeServiceFoci.
     */
    data: XOR<MenteeServiceFocusUpdateManyMutationInput, MenteeServiceFocusUncheckedUpdateManyInput>
    /**
     * Filter which MenteeServiceFoci to update
     */
    where?: MenteeServiceFocusWhereInput
    /**
     * Limit how many MenteeServiceFoci to update.
     */
    limit?: number
  }

  /**
   * MenteeServiceFocus updateManyAndReturn
   */
  export type MenteeServiceFocusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeServiceFocus
     */
    select?: MenteeServiceFocusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeServiceFocus
     */
    omit?: MenteeServiceFocusOmit<ExtArgs> | null
    /**
     * The data used to update MenteeServiceFoci.
     */
    data: XOR<MenteeServiceFocusUpdateManyMutationInput, MenteeServiceFocusUncheckedUpdateManyInput>
    /**
     * Filter which MenteeServiceFoci to update
     */
    where?: MenteeServiceFocusWhereInput
    /**
     * Limit how many MenteeServiceFoci to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeServiceFocusIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenteeServiceFocus upsert
   */
  export type MenteeServiceFocusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeServiceFocus
     */
    select?: MenteeServiceFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeServiceFocus
     */
    omit?: MenteeServiceFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeServiceFocusInclude<ExtArgs> | null
    /**
     * The filter to search for the MenteeServiceFocus to update in case it exists.
     */
    where: MenteeServiceFocusWhereUniqueInput
    /**
     * In case the MenteeServiceFocus found by the `where` argument doesn't exist, create a new MenteeServiceFocus with this data.
     */
    create: XOR<MenteeServiceFocusCreateInput, MenteeServiceFocusUncheckedCreateInput>
    /**
     * In case the MenteeServiceFocus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenteeServiceFocusUpdateInput, MenteeServiceFocusUncheckedUpdateInput>
  }

  /**
   * MenteeServiceFocus delete
   */
  export type MenteeServiceFocusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeServiceFocus
     */
    select?: MenteeServiceFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeServiceFocus
     */
    omit?: MenteeServiceFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeServiceFocusInclude<ExtArgs> | null
    /**
     * Filter which MenteeServiceFocus to delete.
     */
    where: MenteeServiceFocusWhereUniqueInput
  }

  /**
   * MenteeServiceFocus deleteMany
   */
  export type MenteeServiceFocusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenteeServiceFoci to delete
     */
    where?: MenteeServiceFocusWhereInput
    /**
     * Limit how many MenteeServiceFoci to delete.
     */
    limit?: number
  }

  /**
   * MenteeServiceFocus without action
   */
  export type MenteeServiceFocusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeServiceFocus
     */
    select?: MenteeServiceFocusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeServiceFocus
     */
    omit?: MenteeServiceFocusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeServiceFocusInclude<ExtArgs> | null
  }


  /**
   * Model MenteeLanguageRef
   */

  export type AggregateMenteeLanguageRef = {
    _count: MenteeLanguageRefCountAggregateOutputType | null
    _min: MenteeLanguageRefMinAggregateOutputType | null
    _max: MenteeLanguageRefMaxAggregateOutputType | null
  }

  export type MenteeLanguageRefMinAggregateOutputType = {
    user_id: string | null
    language_id: string | null
  }

  export type MenteeLanguageRefMaxAggregateOutputType = {
    user_id: string | null
    language_id: string | null
  }

  export type MenteeLanguageRefCountAggregateOutputType = {
    user_id: number
    language_id: number
    _all: number
  }


  export type MenteeLanguageRefMinAggregateInputType = {
    user_id?: true
    language_id?: true
  }

  export type MenteeLanguageRefMaxAggregateInputType = {
    user_id?: true
    language_id?: true
  }

  export type MenteeLanguageRefCountAggregateInputType = {
    user_id?: true
    language_id?: true
    _all?: true
  }

  export type MenteeLanguageRefAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenteeLanguageRef to aggregate.
     */
    where?: MenteeLanguageRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteeLanguageRefs to fetch.
     */
    orderBy?: MenteeLanguageRefOrderByWithRelationInput | MenteeLanguageRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenteeLanguageRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteeLanguageRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteeLanguageRefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MenteeLanguageRefs
    **/
    _count?: true | MenteeLanguageRefCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenteeLanguageRefMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenteeLanguageRefMaxAggregateInputType
  }

  export type GetMenteeLanguageRefAggregateType<T extends MenteeLanguageRefAggregateArgs> = {
        [P in keyof T & keyof AggregateMenteeLanguageRef]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenteeLanguageRef[P]>
      : GetScalarType<T[P], AggregateMenteeLanguageRef[P]>
  }




  export type MenteeLanguageRefGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenteeLanguageRefWhereInput
    orderBy?: MenteeLanguageRefOrderByWithAggregationInput | MenteeLanguageRefOrderByWithAggregationInput[]
    by: MenteeLanguageRefScalarFieldEnum[] | MenteeLanguageRefScalarFieldEnum
    having?: MenteeLanguageRefScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenteeLanguageRefCountAggregateInputType | true
    _min?: MenteeLanguageRefMinAggregateInputType
    _max?: MenteeLanguageRefMaxAggregateInputType
  }

  export type MenteeLanguageRefGroupByOutputType = {
    user_id: string
    language_id: string
    _count: MenteeLanguageRefCountAggregateOutputType | null
    _min: MenteeLanguageRefMinAggregateOutputType | null
    _max: MenteeLanguageRefMaxAggregateOutputType | null
  }

  type GetMenteeLanguageRefGroupByPayload<T extends MenteeLanguageRefGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenteeLanguageRefGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenteeLanguageRefGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenteeLanguageRefGroupByOutputType[P]>
            : GetScalarType<T[P], MenteeLanguageRefGroupByOutputType[P]>
        }
      >
    >


  export type MenteeLanguageRefSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    language_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    language?: boolean | LanguageRefDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menteeLanguageRef"]>

  export type MenteeLanguageRefSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    language_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    language?: boolean | LanguageRefDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menteeLanguageRef"]>

  export type MenteeLanguageRefSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    language_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    language?: boolean | LanguageRefDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menteeLanguageRef"]>

  export type MenteeLanguageRefSelectScalar = {
    user_id?: boolean
    language_id?: boolean
  }

  export type MenteeLanguageRefOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "language_id", ExtArgs["result"]["menteeLanguageRef"]>
  export type MenteeLanguageRefInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    language?: boolean | LanguageRefDefaultArgs<ExtArgs>
  }
  export type MenteeLanguageRefIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    language?: boolean | LanguageRefDefaultArgs<ExtArgs>
  }
  export type MenteeLanguageRefIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    language?: boolean | LanguageRefDefaultArgs<ExtArgs>
  }

  export type $MenteeLanguageRefPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MenteeLanguageRef"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      language: Prisma.$LanguageRefPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: string
      language_id: string
    }, ExtArgs["result"]["menteeLanguageRef"]>
    composites: {}
  }

  type MenteeLanguageRefGetPayload<S extends boolean | null | undefined | MenteeLanguageRefDefaultArgs> = $Result.GetResult<Prisma.$MenteeLanguageRefPayload, S>

  type MenteeLanguageRefCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MenteeLanguageRefFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MenteeLanguageRefCountAggregateInputType | true
    }

  export interface MenteeLanguageRefDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MenteeLanguageRef'], meta: { name: 'MenteeLanguageRef' } }
    /**
     * Find zero or one MenteeLanguageRef that matches the filter.
     * @param {MenteeLanguageRefFindUniqueArgs} args - Arguments to find a MenteeLanguageRef
     * @example
     * // Get one MenteeLanguageRef
     * const menteeLanguageRef = await prisma.menteeLanguageRef.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenteeLanguageRefFindUniqueArgs>(args: SelectSubset<T, MenteeLanguageRefFindUniqueArgs<ExtArgs>>): Prisma__MenteeLanguageRefClient<$Result.GetResult<Prisma.$MenteeLanguageRefPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MenteeLanguageRef that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MenteeLanguageRefFindUniqueOrThrowArgs} args - Arguments to find a MenteeLanguageRef
     * @example
     * // Get one MenteeLanguageRef
     * const menteeLanguageRef = await prisma.menteeLanguageRef.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenteeLanguageRefFindUniqueOrThrowArgs>(args: SelectSubset<T, MenteeLanguageRefFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MenteeLanguageRefClient<$Result.GetResult<Prisma.$MenteeLanguageRefPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenteeLanguageRef that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeLanguageRefFindFirstArgs} args - Arguments to find a MenteeLanguageRef
     * @example
     * // Get one MenteeLanguageRef
     * const menteeLanguageRef = await prisma.menteeLanguageRef.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenteeLanguageRefFindFirstArgs>(args?: SelectSubset<T, MenteeLanguageRefFindFirstArgs<ExtArgs>>): Prisma__MenteeLanguageRefClient<$Result.GetResult<Prisma.$MenteeLanguageRefPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenteeLanguageRef that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeLanguageRefFindFirstOrThrowArgs} args - Arguments to find a MenteeLanguageRef
     * @example
     * // Get one MenteeLanguageRef
     * const menteeLanguageRef = await prisma.menteeLanguageRef.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenteeLanguageRefFindFirstOrThrowArgs>(args?: SelectSubset<T, MenteeLanguageRefFindFirstOrThrowArgs<ExtArgs>>): Prisma__MenteeLanguageRefClient<$Result.GetResult<Prisma.$MenteeLanguageRefPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MenteeLanguageRefs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeLanguageRefFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MenteeLanguageRefs
     * const menteeLanguageRefs = await prisma.menteeLanguageRef.findMany()
     * 
     * // Get first 10 MenteeLanguageRefs
     * const menteeLanguageRefs = await prisma.menteeLanguageRef.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const menteeLanguageRefWithUser_idOnly = await prisma.menteeLanguageRef.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends MenteeLanguageRefFindManyArgs>(args?: SelectSubset<T, MenteeLanguageRefFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteeLanguageRefPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MenteeLanguageRef.
     * @param {MenteeLanguageRefCreateArgs} args - Arguments to create a MenteeLanguageRef.
     * @example
     * // Create one MenteeLanguageRef
     * const MenteeLanguageRef = await prisma.menteeLanguageRef.create({
     *   data: {
     *     // ... data to create a MenteeLanguageRef
     *   }
     * })
     * 
     */
    create<T extends MenteeLanguageRefCreateArgs>(args: SelectSubset<T, MenteeLanguageRefCreateArgs<ExtArgs>>): Prisma__MenteeLanguageRefClient<$Result.GetResult<Prisma.$MenteeLanguageRefPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MenteeLanguageRefs.
     * @param {MenteeLanguageRefCreateManyArgs} args - Arguments to create many MenteeLanguageRefs.
     * @example
     * // Create many MenteeLanguageRefs
     * const menteeLanguageRef = await prisma.menteeLanguageRef.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MenteeLanguageRefCreateManyArgs>(args?: SelectSubset<T, MenteeLanguageRefCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MenteeLanguageRefs and returns the data saved in the database.
     * @param {MenteeLanguageRefCreateManyAndReturnArgs} args - Arguments to create many MenteeLanguageRefs.
     * @example
     * // Create many MenteeLanguageRefs
     * const menteeLanguageRef = await prisma.menteeLanguageRef.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MenteeLanguageRefs and only return the `user_id`
     * const menteeLanguageRefWithUser_idOnly = await prisma.menteeLanguageRef.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MenteeLanguageRefCreateManyAndReturnArgs>(args?: SelectSubset<T, MenteeLanguageRefCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteeLanguageRefPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MenteeLanguageRef.
     * @param {MenteeLanguageRefDeleteArgs} args - Arguments to delete one MenteeLanguageRef.
     * @example
     * // Delete one MenteeLanguageRef
     * const MenteeLanguageRef = await prisma.menteeLanguageRef.delete({
     *   where: {
     *     // ... filter to delete one MenteeLanguageRef
     *   }
     * })
     * 
     */
    delete<T extends MenteeLanguageRefDeleteArgs>(args: SelectSubset<T, MenteeLanguageRefDeleteArgs<ExtArgs>>): Prisma__MenteeLanguageRefClient<$Result.GetResult<Prisma.$MenteeLanguageRefPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MenteeLanguageRef.
     * @param {MenteeLanguageRefUpdateArgs} args - Arguments to update one MenteeLanguageRef.
     * @example
     * // Update one MenteeLanguageRef
     * const menteeLanguageRef = await prisma.menteeLanguageRef.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MenteeLanguageRefUpdateArgs>(args: SelectSubset<T, MenteeLanguageRefUpdateArgs<ExtArgs>>): Prisma__MenteeLanguageRefClient<$Result.GetResult<Prisma.$MenteeLanguageRefPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MenteeLanguageRefs.
     * @param {MenteeLanguageRefDeleteManyArgs} args - Arguments to filter MenteeLanguageRefs to delete.
     * @example
     * // Delete a few MenteeLanguageRefs
     * const { count } = await prisma.menteeLanguageRef.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MenteeLanguageRefDeleteManyArgs>(args?: SelectSubset<T, MenteeLanguageRefDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenteeLanguageRefs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeLanguageRefUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MenteeLanguageRefs
     * const menteeLanguageRef = await prisma.menteeLanguageRef.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MenteeLanguageRefUpdateManyArgs>(args: SelectSubset<T, MenteeLanguageRefUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenteeLanguageRefs and returns the data updated in the database.
     * @param {MenteeLanguageRefUpdateManyAndReturnArgs} args - Arguments to update many MenteeLanguageRefs.
     * @example
     * // Update many MenteeLanguageRefs
     * const menteeLanguageRef = await prisma.menteeLanguageRef.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MenteeLanguageRefs and only return the `user_id`
     * const menteeLanguageRefWithUser_idOnly = await prisma.menteeLanguageRef.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MenteeLanguageRefUpdateManyAndReturnArgs>(args: SelectSubset<T, MenteeLanguageRefUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteeLanguageRefPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MenteeLanguageRef.
     * @param {MenteeLanguageRefUpsertArgs} args - Arguments to update or create a MenteeLanguageRef.
     * @example
     * // Update or create a MenteeLanguageRef
     * const menteeLanguageRef = await prisma.menteeLanguageRef.upsert({
     *   create: {
     *     // ... data to create a MenteeLanguageRef
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MenteeLanguageRef we want to update
     *   }
     * })
     */
    upsert<T extends MenteeLanguageRefUpsertArgs>(args: SelectSubset<T, MenteeLanguageRefUpsertArgs<ExtArgs>>): Prisma__MenteeLanguageRefClient<$Result.GetResult<Prisma.$MenteeLanguageRefPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MenteeLanguageRefs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeLanguageRefCountArgs} args - Arguments to filter MenteeLanguageRefs to count.
     * @example
     * // Count the number of MenteeLanguageRefs
     * const count = await prisma.menteeLanguageRef.count({
     *   where: {
     *     // ... the filter for the MenteeLanguageRefs we want to count
     *   }
     * })
    **/
    count<T extends MenteeLanguageRefCountArgs>(
      args?: Subset<T, MenteeLanguageRefCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenteeLanguageRefCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MenteeLanguageRef.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeLanguageRefAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenteeLanguageRefAggregateArgs>(args: Subset<T, MenteeLanguageRefAggregateArgs>): Prisma.PrismaPromise<GetMenteeLanguageRefAggregateType<T>>

    /**
     * Group by MenteeLanguageRef.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeLanguageRefGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenteeLanguageRefGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenteeLanguageRefGroupByArgs['orderBy'] }
        : { orderBy?: MenteeLanguageRefGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenteeLanguageRefGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenteeLanguageRefGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MenteeLanguageRef model
   */
  readonly fields: MenteeLanguageRefFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MenteeLanguageRef.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenteeLanguageRefClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    language<T extends LanguageRefDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguageRefDefaultArgs<ExtArgs>>): Prisma__LanguageRefClient<$Result.GetResult<Prisma.$LanguageRefPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MenteeLanguageRef model
   */
  interface MenteeLanguageRefFieldRefs {
    readonly user_id: FieldRef<"MenteeLanguageRef", 'String'>
    readonly language_id: FieldRef<"MenteeLanguageRef", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MenteeLanguageRef findUnique
   */
  export type MenteeLanguageRefFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeLanguageRef
     */
    select?: MenteeLanguageRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeLanguageRef
     */
    omit?: MenteeLanguageRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeLanguageRefInclude<ExtArgs> | null
    /**
     * Filter, which MenteeLanguageRef to fetch.
     */
    where: MenteeLanguageRefWhereUniqueInput
  }

  /**
   * MenteeLanguageRef findUniqueOrThrow
   */
  export type MenteeLanguageRefFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeLanguageRef
     */
    select?: MenteeLanguageRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeLanguageRef
     */
    omit?: MenteeLanguageRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeLanguageRefInclude<ExtArgs> | null
    /**
     * Filter, which MenteeLanguageRef to fetch.
     */
    where: MenteeLanguageRefWhereUniqueInput
  }

  /**
   * MenteeLanguageRef findFirst
   */
  export type MenteeLanguageRefFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeLanguageRef
     */
    select?: MenteeLanguageRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeLanguageRef
     */
    omit?: MenteeLanguageRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeLanguageRefInclude<ExtArgs> | null
    /**
     * Filter, which MenteeLanguageRef to fetch.
     */
    where?: MenteeLanguageRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteeLanguageRefs to fetch.
     */
    orderBy?: MenteeLanguageRefOrderByWithRelationInput | MenteeLanguageRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenteeLanguageRefs.
     */
    cursor?: MenteeLanguageRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteeLanguageRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteeLanguageRefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenteeLanguageRefs.
     */
    distinct?: MenteeLanguageRefScalarFieldEnum | MenteeLanguageRefScalarFieldEnum[]
  }

  /**
   * MenteeLanguageRef findFirstOrThrow
   */
  export type MenteeLanguageRefFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeLanguageRef
     */
    select?: MenteeLanguageRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeLanguageRef
     */
    omit?: MenteeLanguageRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeLanguageRefInclude<ExtArgs> | null
    /**
     * Filter, which MenteeLanguageRef to fetch.
     */
    where?: MenteeLanguageRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteeLanguageRefs to fetch.
     */
    orderBy?: MenteeLanguageRefOrderByWithRelationInput | MenteeLanguageRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenteeLanguageRefs.
     */
    cursor?: MenteeLanguageRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteeLanguageRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteeLanguageRefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenteeLanguageRefs.
     */
    distinct?: MenteeLanguageRefScalarFieldEnum | MenteeLanguageRefScalarFieldEnum[]
  }

  /**
   * MenteeLanguageRef findMany
   */
  export type MenteeLanguageRefFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeLanguageRef
     */
    select?: MenteeLanguageRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeLanguageRef
     */
    omit?: MenteeLanguageRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeLanguageRefInclude<ExtArgs> | null
    /**
     * Filter, which MenteeLanguageRefs to fetch.
     */
    where?: MenteeLanguageRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteeLanguageRefs to fetch.
     */
    orderBy?: MenteeLanguageRefOrderByWithRelationInput | MenteeLanguageRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MenteeLanguageRefs.
     */
    cursor?: MenteeLanguageRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteeLanguageRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteeLanguageRefs.
     */
    skip?: number
    distinct?: MenteeLanguageRefScalarFieldEnum | MenteeLanguageRefScalarFieldEnum[]
  }

  /**
   * MenteeLanguageRef create
   */
  export type MenteeLanguageRefCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeLanguageRef
     */
    select?: MenteeLanguageRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeLanguageRef
     */
    omit?: MenteeLanguageRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeLanguageRefInclude<ExtArgs> | null
    /**
     * The data needed to create a MenteeLanguageRef.
     */
    data: XOR<MenteeLanguageRefCreateInput, MenteeLanguageRefUncheckedCreateInput>
  }

  /**
   * MenteeLanguageRef createMany
   */
  export type MenteeLanguageRefCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MenteeLanguageRefs.
     */
    data: MenteeLanguageRefCreateManyInput | MenteeLanguageRefCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MenteeLanguageRef createManyAndReturn
   */
  export type MenteeLanguageRefCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeLanguageRef
     */
    select?: MenteeLanguageRefSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeLanguageRef
     */
    omit?: MenteeLanguageRefOmit<ExtArgs> | null
    /**
     * The data used to create many MenteeLanguageRefs.
     */
    data: MenteeLanguageRefCreateManyInput | MenteeLanguageRefCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeLanguageRefIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenteeLanguageRef update
   */
  export type MenteeLanguageRefUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeLanguageRef
     */
    select?: MenteeLanguageRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeLanguageRef
     */
    omit?: MenteeLanguageRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeLanguageRefInclude<ExtArgs> | null
    /**
     * The data needed to update a MenteeLanguageRef.
     */
    data: XOR<MenteeLanguageRefUpdateInput, MenteeLanguageRefUncheckedUpdateInput>
    /**
     * Choose, which MenteeLanguageRef to update.
     */
    where: MenteeLanguageRefWhereUniqueInput
  }

  /**
   * MenteeLanguageRef updateMany
   */
  export type MenteeLanguageRefUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MenteeLanguageRefs.
     */
    data: XOR<MenteeLanguageRefUpdateManyMutationInput, MenteeLanguageRefUncheckedUpdateManyInput>
    /**
     * Filter which MenteeLanguageRefs to update
     */
    where?: MenteeLanguageRefWhereInput
    /**
     * Limit how many MenteeLanguageRefs to update.
     */
    limit?: number
  }

  /**
   * MenteeLanguageRef updateManyAndReturn
   */
  export type MenteeLanguageRefUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeLanguageRef
     */
    select?: MenteeLanguageRefSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeLanguageRef
     */
    omit?: MenteeLanguageRefOmit<ExtArgs> | null
    /**
     * The data used to update MenteeLanguageRefs.
     */
    data: XOR<MenteeLanguageRefUpdateManyMutationInput, MenteeLanguageRefUncheckedUpdateManyInput>
    /**
     * Filter which MenteeLanguageRefs to update
     */
    where?: MenteeLanguageRefWhereInput
    /**
     * Limit how many MenteeLanguageRefs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeLanguageRefIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenteeLanguageRef upsert
   */
  export type MenteeLanguageRefUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeLanguageRef
     */
    select?: MenteeLanguageRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeLanguageRef
     */
    omit?: MenteeLanguageRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeLanguageRefInclude<ExtArgs> | null
    /**
     * The filter to search for the MenteeLanguageRef to update in case it exists.
     */
    where: MenteeLanguageRefWhereUniqueInput
    /**
     * In case the MenteeLanguageRef found by the `where` argument doesn't exist, create a new MenteeLanguageRef with this data.
     */
    create: XOR<MenteeLanguageRefCreateInput, MenteeLanguageRefUncheckedCreateInput>
    /**
     * In case the MenteeLanguageRef was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenteeLanguageRefUpdateInput, MenteeLanguageRefUncheckedUpdateInput>
  }

  /**
   * MenteeLanguageRef delete
   */
  export type MenteeLanguageRefDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeLanguageRef
     */
    select?: MenteeLanguageRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeLanguageRef
     */
    omit?: MenteeLanguageRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeLanguageRefInclude<ExtArgs> | null
    /**
     * Filter which MenteeLanguageRef to delete.
     */
    where: MenteeLanguageRefWhereUniqueInput
  }

  /**
   * MenteeLanguageRef deleteMany
   */
  export type MenteeLanguageRefDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenteeLanguageRefs to delete
     */
    where?: MenteeLanguageRefWhereInput
    /**
     * Limit how many MenteeLanguageRefs to delete.
     */
    limit?: number
  }

  /**
   * MenteeLanguageRef without action
   */
  export type MenteeLanguageRefDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeLanguageRef
     */
    select?: MenteeLanguageRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeLanguageRef
     */
    omit?: MenteeLanguageRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeLanguageRefInclude<ExtArgs> | null
  }


  /**
   * Model MenteeDisciplineRef
   */

  export type AggregateMenteeDisciplineRef = {
    _count: MenteeDisciplineRefCountAggregateOutputType | null
    _min: MenteeDisciplineRefMinAggregateOutputType | null
    _max: MenteeDisciplineRefMaxAggregateOutputType | null
  }

  export type MenteeDisciplineRefMinAggregateOutputType = {
    user_id: string | null
    discipline_id: string | null
  }

  export type MenteeDisciplineRefMaxAggregateOutputType = {
    user_id: string | null
    discipline_id: string | null
  }

  export type MenteeDisciplineRefCountAggregateOutputType = {
    user_id: number
    discipline_id: number
    _all: number
  }


  export type MenteeDisciplineRefMinAggregateInputType = {
    user_id?: true
    discipline_id?: true
  }

  export type MenteeDisciplineRefMaxAggregateInputType = {
    user_id?: true
    discipline_id?: true
  }

  export type MenteeDisciplineRefCountAggregateInputType = {
    user_id?: true
    discipline_id?: true
    _all?: true
  }

  export type MenteeDisciplineRefAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenteeDisciplineRef to aggregate.
     */
    where?: MenteeDisciplineRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteeDisciplineRefs to fetch.
     */
    orderBy?: MenteeDisciplineRefOrderByWithRelationInput | MenteeDisciplineRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenteeDisciplineRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteeDisciplineRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteeDisciplineRefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MenteeDisciplineRefs
    **/
    _count?: true | MenteeDisciplineRefCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenteeDisciplineRefMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenteeDisciplineRefMaxAggregateInputType
  }

  export type GetMenteeDisciplineRefAggregateType<T extends MenteeDisciplineRefAggregateArgs> = {
        [P in keyof T & keyof AggregateMenteeDisciplineRef]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenteeDisciplineRef[P]>
      : GetScalarType<T[P], AggregateMenteeDisciplineRef[P]>
  }




  export type MenteeDisciplineRefGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenteeDisciplineRefWhereInput
    orderBy?: MenteeDisciplineRefOrderByWithAggregationInput | MenteeDisciplineRefOrderByWithAggregationInput[]
    by: MenteeDisciplineRefScalarFieldEnum[] | MenteeDisciplineRefScalarFieldEnum
    having?: MenteeDisciplineRefScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenteeDisciplineRefCountAggregateInputType | true
    _min?: MenteeDisciplineRefMinAggregateInputType
    _max?: MenteeDisciplineRefMaxAggregateInputType
  }

  export type MenteeDisciplineRefGroupByOutputType = {
    user_id: string
    discipline_id: string
    _count: MenteeDisciplineRefCountAggregateOutputType | null
    _min: MenteeDisciplineRefMinAggregateOutputType | null
    _max: MenteeDisciplineRefMaxAggregateOutputType | null
  }

  type GetMenteeDisciplineRefGroupByPayload<T extends MenteeDisciplineRefGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenteeDisciplineRefGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenteeDisciplineRefGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenteeDisciplineRefGroupByOutputType[P]>
            : GetScalarType<T[P], MenteeDisciplineRefGroupByOutputType[P]>
        }
      >
    >


  export type MenteeDisciplineRefSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    discipline_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    discipline?: boolean | DisciplineRefDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menteeDisciplineRef"]>

  export type MenteeDisciplineRefSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    discipline_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    discipline?: boolean | DisciplineRefDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menteeDisciplineRef"]>

  export type MenteeDisciplineRefSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    discipline_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    discipline?: boolean | DisciplineRefDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menteeDisciplineRef"]>

  export type MenteeDisciplineRefSelectScalar = {
    user_id?: boolean
    discipline_id?: boolean
  }

  export type MenteeDisciplineRefOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "discipline_id", ExtArgs["result"]["menteeDisciplineRef"]>
  export type MenteeDisciplineRefInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    discipline?: boolean | DisciplineRefDefaultArgs<ExtArgs>
  }
  export type MenteeDisciplineRefIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    discipline?: boolean | DisciplineRefDefaultArgs<ExtArgs>
  }
  export type MenteeDisciplineRefIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    discipline?: boolean | DisciplineRefDefaultArgs<ExtArgs>
  }

  export type $MenteeDisciplineRefPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MenteeDisciplineRef"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      discipline: Prisma.$DisciplineRefPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: string
      discipline_id: string
    }, ExtArgs["result"]["menteeDisciplineRef"]>
    composites: {}
  }

  type MenteeDisciplineRefGetPayload<S extends boolean | null | undefined | MenteeDisciplineRefDefaultArgs> = $Result.GetResult<Prisma.$MenteeDisciplineRefPayload, S>

  type MenteeDisciplineRefCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MenteeDisciplineRefFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MenteeDisciplineRefCountAggregateInputType | true
    }

  export interface MenteeDisciplineRefDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MenteeDisciplineRef'], meta: { name: 'MenteeDisciplineRef' } }
    /**
     * Find zero or one MenteeDisciplineRef that matches the filter.
     * @param {MenteeDisciplineRefFindUniqueArgs} args - Arguments to find a MenteeDisciplineRef
     * @example
     * // Get one MenteeDisciplineRef
     * const menteeDisciplineRef = await prisma.menteeDisciplineRef.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenteeDisciplineRefFindUniqueArgs>(args: SelectSubset<T, MenteeDisciplineRefFindUniqueArgs<ExtArgs>>): Prisma__MenteeDisciplineRefClient<$Result.GetResult<Prisma.$MenteeDisciplineRefPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MenteeDisciplineRef that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MenteeDisciplineRefFindUniqueOrThrowArgs} args - Arguments to find a MenteeDisciplineRef
     * @example
     * // Get one MenteeDisciplineRef
     * const menteeDisciplineRef = await prisma.menteeDisciplineRef.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenteeDisciplineRefFindUniqueOrThrowArgs>(args: SelectSubset<T, MenteeDisciplineRefFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MenteeDisciplineRefClient<$Result.GetResult<Prisma.$MenteeDisciplineRefPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenteeDisciplineRef that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeDisciplineRefFindFirstArgs} args - Arguments to find a MenteeDisciplineRef
     * @example
     * // Get one MenteeDisciplineRef
     * const menteeDisciplineRef = await prisma.menteeDisciplineRef.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenteeDisciplineRefFindFirstArgs>(args?: SelectSubset<T, MenteeDisciplineRefFindFirstArgs<ExtArgs>>): Prisma__MenteeDisciplineRefClient<$Result.GetResult<Prisma.$MenteeDisciplineRefPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenteeDisciplineRef that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeDisciplineRefFindFirstOrThrowArgs} args - Arguments to find a MenteeDisciplineRef
     * @example
     * // Get one MenteeDisciplineRef
     * const menteeDisciplineRef = await prisma.menteeDisciplineRef.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenteeDisciplineRefFindFirstOrThrowArgs>(args?: SelectSubset<T, MenteeDisciplineRefFindFirstOrThrowArgs<ExtArgs>>): Prisma__MenteeDisciplineRefClient<$Result.GetResult<Prisma.$MenteeDisciplineRefPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MenteeDisciplineRefs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeDisciplineRefFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MenteeDisciplineRefs
     * const menteeDisciplineRefs = await prisma.menteeDisciplineRef.findMany()
     * 
     * // Get first 10 MenteeDisciplineRefs
     * const menteeDisciplineRefs = await prisma.menteeDisciplineRef.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const menteeDisciplineRefWithUser_idOnly = await prisma.menteeDisciplineRef.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends MenteeDisciplineRefFindManyArgs>(args?: SelectSubset<T, MenteeDisciplineRefFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteeDisciplineRefPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MenteeDisciplineRef.
     * @param {MenteeDisciplineRefCreateArgs} args - Arguments to create a MenteeDisciplineRef.
     * @example
     * // Create one MenteeDisciplineRef
     * const MenteeDisciplineRef = await prisma.menteeDisciplineRef.create({
     *   data: {
     *     // ... data to create a MenteeDisciplineRef
     *   }
     * })
     * 
     */
    create<T extends MenteeDisciplineRefCreateArgs>(args: SelectSubset<T, MenteeDisciplineRefCreateArgs<ExtArgs>>): Prisma__MenteeDisciplineRefClient<$Result.GetResult<Prisma.$MenteeDisciplineRefPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MenteeDisciplineRefs.
     * @param {MenteeDisciplineRefCreateManyArgs} args - Arguments to create many MenteeDisciplineRefs.
     * @example
     * // Create many MenteeDisciplineRefs
     * const menteeDisciplineRef = await prisma.menteeDisciplineRef.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MenteeDisciplineRefCreateManyArgs>(args?: SelectSubset<T, MenteeDisciplineRefCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MenteeDisciplineRefs and returns the data saved in the database.
     * @param {MenteeDisciplineRefCreateManyAndReturnArgs} args - Arguments to create many MenteeDisciplineRefs.
     * @example
     * // Create many MenteeDisciplineRefs
     * const menteeDisciplineRef = await prisma.menteeDisciplineRef.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MenteeDisciplineRefs and only return the `user_id`
     * const menteeDisciplineRefWithUser_idOnly = await prisma.menteeDisciplineRef.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MenteeDisciplineRefCreateManyAndReturnArgs>(args?: SelectSubset<T, MenteeDisciplineRefCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteeDisciplineRefPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MenteeDisciplineRef.
     * @param {MenteeDisciplineRefDeleteArgs} args - Arguments to delete one MenteeDisciplineRef.
     * @example
     * // Delete one MenteeDisciplineRef
     * const MenteeDisciplineRef = await prisma.menteeDisciplineRef.delete({
     *   where: {
     *     // ... filter to delete one MenteeDisciplineRef
     *   }
     * })
     * 
     */
    delete<T extends MenteeDisciplineRefDeleteArgs>(args: SelectSubset<T, MenteeDisciplineRefDeleteArgs<ExtArgs>>): Prisma__MenteeDisciplineRefClient<$Result.GetResult<Prisma.$MenteeDisciplineRefPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MenteeDisciplineRef.
     * @param {MenteeDisciplineRefUpdateArgs} args - Arguments to update one MenteeDisciplineRef.
     * @example
     * // Update one MenteeDisciplineRef
     * const menteeDisciplineRef = await prisma.menteeDisciplineRef.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MenteeDisciplineRefUpdateArgs>(args: SelectSubset<T, MenteeDisciplineRefUpdateArgs<ExtArgs>>): Prisma__MenteeDisciplineRefClient<$Result.GetResult<Prisma.$MenteeDisciplineRefPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MenteeDisciplineRefs.
     * @param {MenteeDisciplineRefDeleteManyArgs} args - Arguments to filter MenteeDisciplineRefs to delete.
     * @example
     * // Delete a few MenteeDisciplineRefs
     * const { count } = await prisma.menteeDisciplineRef.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MenteeDisciplineRefDeleteManyArgs>(args?: SelectSubset<T, MenteeDisciplineRefDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenteeDisciplineRefs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeDisciplineRefUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MenteeDisciplineRefs
     * const menteeDisciplineRef = await prisma.menteeDisciplineRef.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MenteeDisciplineRefUpdateManyArgs>(args: SelectSubset<T, MenteeDisciplineRefUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenteeDisciplineRefs and returns the data updated in the database.
     * @param {MenteeDisciplineRefUpdateManyAndReturnArgs} args - Arguments to update many MenteeDisciplineRefs.
     * @example
     * // Update many MenteeDisciplineRefs
     * const menteeDisciplineRef = await prisma.menteeDisciplineRef.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MenteeDisciplineRefs and only return the `user_id`
     * const menteeDisciplineRefWithUser_idOnly = await prisma.menteeDisciplineRef.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MenteeDisciplineRefUpdateManyAndReturnArgs>(args: SelectSubset<T, MenteeDisciplineRefUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteeDisciplineRefPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MenteeDisciplineRef.
     * @param {MenteeDisciplineRefUpsertArgs} args - Arguments to update or create a MenteeDisciplineRef.
     * @example
     * // Update or create a MenteeDisciplineRef
     * const menteeDisciplineRef = await prisma.menteeDisciplineRef.upsert({
     *   create: {
     *     // ... data to create a MenteeDisciplineRef
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MenteeDisciplineRef we want to update
     *   }
     * })
     */
    upsert<T extends MenteeDisciplineRefUpsertArgs>(args: SelectSubset<T, MenteeDisciplineRefUpsertArgs<ExtArgs>>): Prisma__MenteeDisciplineRefClient<$Result.GetResult<Prisma.$MenteeDisciplineRefPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MenteeDisciplineRefs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeDisciplineRefCountArgs} args - Arguments to filter MenteeDisciplineRefs to count.
     * @example
     * // Count the number of MenteeDisciplineRefs
     * const count = await prisma.menteeDisciplineRef.count({
     *   where: {
     *     // ... the filter for the MenteeDisciplineRefs we want to count
     *   }
     * })
    **/
    count<T extends MenteeDisciplineRefCountArgs>(
      args?: Subset<T, MenteeDisciplineRefCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenteeDisciplineRefCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MenteeDisciplineRef.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeDisciplineRefAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenteeDisciplineRefAggregateArgs>(args: Subset<T, MenteeDisciplineRefAggregateArgs>): Prisma.PrismaPromise<GetMenteeDisciplineRefAggregateType<T>>

    /**
     * Group by MenteeDisciplineRef.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteeDisciplineRefGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenteeDisciplineRefGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenteeDisciplineRefGroupByArgs['orderBy'] }
        : { orderBy?: MenteeDisciplineRefGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenteeDisciplineRefGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenteeDisciplineRefGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MenteeDisciplineRef model
   */
  readonly fields: MenteeDisciplineRefFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MenteeDisciplineRef.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenteeDisciplineRefClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    discipline<T extends DisciplineRefDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DisciplineRefDefaultArgs<ExtArgs>>): Prisma__DisciplineRefClient<$Result.GetResult<Prisma.$DisciplineRefPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MenteeDisciplineRef model
   */
  interface MenteeDisciplineRefFieldRefs {
    readonly user_id: FieldRef<"MenteeDisciplineRef", 'String'>
    readonly discipline_id: FieldRef<"MenteeDisciplineRef", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MenteeDisciplineRef findUnique
   */
  export type MenteeDisciplineRefFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeDisciplineRef
     */
    select?: MenteeDisciplineRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeDisciplineRef
     */
    omit?: MenteeDisciplineRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeDisciplineRefInclude<ExtArgs> | null
    /**
     * Filter, which MenteeDisciplineRef to fetch.
     */
    where: MenteeDisciplineRefWhereUniqueInput
  }

  /**
   * MenteeDisciplineRef findUniqueOrThrow
   */
  export type MenteeDisciplineRefFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeDisciplineRef
     */
    select?: MenteeDisciplineRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeDisciplineRef
     */
    omit?: MenteeDisciplineRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeDisciplineRefInclude<ExtArgs> | null
    /**
     * Filter, which MenteeDisciplineRef to fetch.
     */
    where: MenteeDisciplineRefWhereUniqueInput
  }

  /**
   * MenteeDisciplineRef findFirst
   */
  export type MenteeDisciplineRefFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeDisciplineRef
     */
    select?: MenteeDisciplineRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeDisciplineRef
     */
    omit?: MenteeDisciplineRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeDisciplineRefInclude<ExtArgs> | null
    /**
     * Filter, which MenteeDisciplineRef to fetch.
     */
    where?: MenteeDisciplineRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteeDisciplineRefs to fetch.
     */
    orderBy?: MenteeDisciplineRefOrderByWithRelationInput | MenteeDisciplineRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenteeDisciplineRefs.
     */
    cursor?: MenteeDisciplineRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteeDisciplineRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteeDisciplineRefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenteeDisciplineRefs.
     */
    distinct?: MenteeDisciplineRefScalarFieldEnum | MenteeDisciplineRefScalarFieldEnum[]
  }

  /**
   * MenteeDisciplineRef findFirstOrThrow
   */
  export type MenteeDisciplineRefFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeDisciplineRef
     */
    select?: MenteeDisciplineRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeDisciplineRef
     */
    omit?: MenteeDisciplineRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeDisciplineRefInclude<ExtArgs> | null
    /**
     * Filter, which MenteeDisciplineRef to fetch.
     */
    where?: MenteeDisciplineRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteeDisciplineRefs to fetch.
     */
    orderBy?: MenteeDisciplineRefOrderByWithRelationInput | MenteeDisciplineRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenteeDisciplineRefs.
     */
    cursor?: MenteeDisciplineRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteeDisciplineRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteeDisciplineRefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenteeDisciplineRefs.
     */
    distinct?: MenteeDisciplineRefScalarFieldEnum | MenteeDisciplineRefScalarFieldEnum[]
  }

  /**
   * MenteeDisciplineRef findMany
   */
  export type MenteeDisciplineRefFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeDisciplineRef
     */
    select?: MenteeDisciplineRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeDisciplineRef
     */
    omit?: MenteeDisciplineRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeDisciplineRefInclude<ExtArgs> | null
    /**
     * Filter, which MenteeDisciplineRefs to fetch.
     */
    where?: MenteeDisciplineRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteeDisciplineRefs to fetch.
     */
    orderBy?: MenteeDisciplineRefOrderByWithRelationInput | MenteeDisciplineRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MenteeDisciplineRefs.
     */
    cursor?: MenteeDisciplineRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteeDisciplineRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteeDisciplineRefs.
     */
    skip?: number
    distinct?: MenteeDisciplineRefScalarFieldEnum | MenteeDisciplineRefScalarFieldEnum[]
  }

  /**
   * MenteeDisciplineRef create
   */
  export type MenteeDisciplineRefCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeDisciplineRef
     */
    select?: MenteeDisciplineRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeDisciplineRef
     */
    omit?: MenteeDisciplineRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeDisciplineRefInclude<ExtArgs> | null
    /**
     * The data needed to create a MenteeDisciplineRef.
     */
    data: XOR<MenteeDisciplineRefCreateInput, MenteeDisciplineRefUncheckedCreateInput>
  }

  /**
   * MenteeDisciplineRef createMany
   */
  export type MenteeDisciplineRefCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MenteeDisciplineRefs.
     */
    data: MenteeDisciplineRefCreateManyInput | MenteeDisciplineRefCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MenteeDisciplineRef createManyAndReturn
   */
  export type MenteeDisciplineRefCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeDisciplineRef
     */
    select?: MenteeDisciplineRefSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeDisciplineRef
     */
    omit?: MenteeDisciplineRefOmit<ExtArgs> | null
    /**
     * The data used to create many MenteeDisciplineRefs.
     */
    data: MenteeDisciplineRefCreateManyInput | MenteeDisciplineRefCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeDisciplineRefIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenteeDisciplineRef update
   */
  export type MenteeDisciplineRefUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeDisciplineRef
     */
    select?: MenteeDisciplineRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeDisciplineRef
     */
    omit?: MenteeDisciplineRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeDisciplineRefInclude<ExtArgs> | null
    /**
     * The data needed to update a MenteeDisciplineRef.
     */
    data: XOR<MenteeDisciplineRefUpdateInput, MenteeDisciplineRefUncheckedUpdateInput>
    /**
     * Choose, which MenteeDisciplineRef to update.
     */
    where: MenteeDisciplineRefWhereUniqueInput
  }

  /**
   * MenteeDisciplineRef updateMany
   */
  export type MenteeDisciplineRefUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MenteeDisciplineRefs.
     */
    data: XOR<MenteeDisciplineRefUpdateManyMutationInput, MenteeDisciplineRefUncheckedUpdateManyInput>
    /**
     * Filter which MenteeDisciplineRefs to update
     */
    where?: MenteeDisciplineRefWhereInput
    /**
     * Limit how many MenteeDisciplineRefs to update.
     */
    limit?: number
  }

  /**
   * MenteeDisciplineRef updateManyAndReturn
   */
  export type MenteeDisciplineRefUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeDisciplineRef
     */
    select?: MenteeDisciplineRefSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeDisciplineRef
     */
    omit?: MenteeDisciplineRefOmit<ExtArgs> | null
    /**
     * The data used to update MenteeDisciplineRefs.
     */
    data: XOR<MenteeDisciplineRefUpdateManyMutationInput, MenteeDisciplineRefUncheckedUpdateManyInput>
    /**
     * Filter which MenteeDisciplineRefs to update
     */
    where?: MenteeDisciplineRefWhereInput
    /**
     * Limit how many MenteeDisciplineRefs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeDisciplineRefIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenteeDisciplineRef upsert
   */
  export type MenteeDisciplineRefUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeDisciplineRef
     */
    select?: MenteeDisciplineRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeDisciplineRef
     */
    omit?: MenteeDisciplineRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeDisciplineRefInclude<ExtArgs> | null
    /**
     * The filter to search for the MenteeDisciplineRef to update in case it exists.
     */
    where: MenteeDisciplineRefWhereUniqueInput
    /**
     * In case the MenteeDisciplineRef found by the `where` argument doesn't exist, create a new MenteeDisciplineRef with this data.
     */
    create: XOR<MenteeDisciplineRefCreateInput, MenteeDisciplineRefUncheckedCreateInput>
    /**
     * In case the MenteeDisciplineRef was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenteeDisciplineRefUpdateInput, MenteeDisciplineRefUncheckedUpdateInput>
  }

  /**
   * MenteeDisciplineRef delete
   */
  export type MenteeDisciplineRefDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeDisciplineRef
     */
    select?: MenteeDisciplineRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeDisciplineRef
     */
    omit?: MenteeDisciplineRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeDisciplineRefInclude<ExtArgs> | null
    /**
     * Filter which MenteeDisciplineRef to delete.
     */
    where: MenteeDisciplineRefWhereUniqueInput
  }

  /**
   * MenteeDisciplineRef deleteMany
   */
  export type MenteeDisciplineRefDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenteeDisciplineRefs to delete
     */
    where?: MenteeDisciplineRefWhereInput
    /**
     * Limit how many MenteeDisciplineRefs to delete.
     */
    limit?: number
  }

  /**
   * MenteeDisciplineRef without action
   */
  export type MenteeDisciplineRefDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteeDisciplineRef
     */
    select?: MenteeDisciplineRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteeDisciplineRef
     */
    omit?: MenteeDisciplineRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteeDisciplineRefInclude<ExtArgs> | null
  }


  /**
   * Model MenteePreferenceRef
   */

  export type AggregateMenteePreferenceRef = {
    _count: MenteePreferenceRefCountAggregateOutputType | null
    _min: MenteePreferenceRefMinAggregateOutputType | null
    _max: MenteePreferenceRefMaxAggregateOutputType | null
  }

  export type MenteePreferenceRefMinAggregateOutputType = {
    user_id: string | null
    preference_id: string | null
  }

  export type MenteePreferenceRefMaxAggregateOutputType = {
    user_id: string | null
    preference_id: string | null
  }

  export type MenteePreferenceRefCountAggregateOutputType = {
    user_id: number
    preference_id: number
    _all: number
  }


  export type MenteePreferenceRefMinAggregateInputType = {
    user_id?: true
    preference_id?: true
  }

  export type MenteePreferenceRefMaxAggregateInputType = {
    user_id?: true
    preference_id?: true
  }

  export type MenteePreferenceRefCountAggregateInputType = {
    user_id?: true
    preference_id?: true
    _all?: true
  }

  export type MenteePreferenceRefAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenteePreferenceRef to aggregate.
     */
    where?: MenteePreferenceRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteePreferenceRefs to fetch.
     */
    orderBy?: MenteePreferenceRefOrderByWithRelationInput | MenteePreferenceRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenteePreferenceRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteePreferenceRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteePreferenceRefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MenteePreferenceRefs
    **/
    _count?: true | MenteePreferenceRefCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenteePreferenceRefMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenteePreferenceRefMaxAggregateInputType
  }

  export type GetMenteePreferenceRefAggregateType<T extends MenteePreferenceRefAggregateArgs> = {
        [P in keyof T & keyof AggregateMenteePreferenceRef]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenteePreferenceRef[P]>
      : GetScalarType<T[P], AggregateMenteePreferenceRef[P]>
  }




  export type MenteePreferenceRefGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenteePreferenceRefWhereInput
    orderBy?: MenteePreferenceRefOrderByWithAggregationInput | MenteePreferenceRefOrderByWithAggregationInput[]
    by: MenteePreferenceRefScalarFieldEnum[] | MenteePreferenceRefScalarFieldEnum
    having?: MenteePreferenceRefScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenteePreferenceRefCountAggregateInputType | true
    _min?: MenteePreferenceRefMinAggregateInputType
    _max?: MenteePreferenceRefMaxAggregateInputType
  }

  export type MenteePreferenceRefGroupByOutputType = {
    user_id: string
    preference_id: string
    _count: MenteePreferenceRefCountAggregateOutputType | null
    _min: MenteePreferenceRefMinAggregateOutputType | null
    _max: MenteePreferenceRefMaxAggregateOutputType | null
  }

  type GetMenteePreferenceRefGroupByPayload<T extends MenteePreferenceRefGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenteePreferenceRefGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenteePreferenceRefGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenteePreferenceRefGroupByOutputType[P]>
            : GetScalarType<T[P], MenteePreferenceRefGroupByOutputType[P]>
        }
      >
    >


  export type MenteePreferenceRefSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    preference_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    preference?: boolean | PreferenceRefDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menteePreferenceRef"]>

  export type MenteePreferenceRefSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    preference_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    preference?: boolean | PreferenceRefDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menteePreferenceRef"]>

  export type MenteePreferenceRefSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    preference_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    preference?: boolean | PreferenceRefDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menteePreferenceRef"]>

  export type MenteePreferenceRefSelectScalar = {
    user_id?: boolean
    preference_id?: boolean
  }

  export type MenteePreferenceRefOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "preference_id", ExtArgs["result"]["menteePreferenceRef"]>
  export type MenteePreferenceRefInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    preference?: boolean | PreferenceRefDefaultArgs<ExtArgs>
  }
  export type MenteePreferenceRefIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    preference?: boolean | PreferenceRefDefaultArgs<ExtArgs>
  }
  export type MenteePreferenceRefIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    preference?: boolean | PreferenceRefDefaultArgs<ExtArgs>
  }

  export type $MenteePreferenceRefPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MenteePreferenceRef"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      preference: Prisma.$PreferenceRefPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: string
      preference_id: string
    }, ExtArgs["result"]["menteePreferenceRef"]>
    composites: {}
  }

  type MenteePreferenceRefGetPayload<S extends boolean | null | undefined | MenteePreferenceRefDefaultArgs> = $Result.GetResult<Prisma.$MenteePreferenceRefPayload, S>

  type MenteePreferenceRefCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MenteePreferenceRefFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MenteePreferenceRefCountAggregateInputType | true
    }

  export interface MenteePreferenceRefDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MenteePreferenceRef'], meta: { name: 'MenteePreferenceRef' } }
    /**
     * Find zero or one MenteePreferenceRef that matches the filter.
     * @param {MenteePreferenceRefFindUniqueArgs} args - Arguments to find a MenteePreferenceRef
     * @example
     * // Get one MenteePreferenceRef
     * const menteePreferenceRef = await prisma.menteePreferenceRef.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenteePreferenceRefFindUniqueArgs>(args: SelectSubset<T, MenteePreferenceRefFindUniqueArgs<ExtArgs>>): Prisma__MenteePreferenceRefClient<$Result.GetResult<Prisma.$MenteePreferenceRefPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MenteePreferenceRef that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MenteePreferenceRefFindUniqueOrThrowArgs} args - Arguments to find a MenteePreferenceRef
     * @example
     * // Get one MenteePreferenceRef
     * const menteePreferenceRef = await prisma.menteePreferenceRef.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenteePreferenceRefFindUniqueOrThrowArgs>(args: SelectSubset<T, MenteePreferenceRefFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MenteePreferenceRefClient<$Result.GetResult<Prisma.$MenteePreferenceRefPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenteePreferenceRef that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteePreferenceRefFindFirstArgs} args - Arguments to find a MenteePreferenceRef
     * @example
     * // Get one MenteePreferenceRef
     * const menteePreferenceRef = await prisma.menteePreferenceRef.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenteePreferenceRefFindFirstArgs>(args?: SelectSubset<T, MenteePreferenceRefFindFirstArgs<ExtArgs>>): Prisma__MenteePreferenceRefClient<$Result.GetResult<Prisma.$MenteePreferenceRefPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenteePreferenceRef that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteePreferenceRefFindFirstOrThrowArgs} args - Arguments to find a MenteePreferenceRef
     * @example
     * // Get one MenteePreferenceRef
     * const menteePreferenceRef = await prisma.menteePreferenceRef.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenteePreferenceRefFindFirstOrThrowArgs>(args?: SelectSubset<T, MenteePreferenceRefFindFirstOrThrowArgs<ExtArgs>>): Prisma__MenteePreferenceRefClient<$Result.GetResult<Prisma.$MenteePreferenceRefPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MenteePreferenceRefs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteePreferenceRefFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MenteePreferenceRefs
     * const menteePreferenceRefs = await prisma.menteePreferenceRef.findMany()
     * 
     * // Get first 10 MenteePreferenceRefs
     * const menteePreferenceRefs = await prisma.menteePreferenceRef.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const menteePreferenceRefWithUser_idOnly = await prisma.menteePreferenceRef.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends MenteePreferenceRefFindManyArgs>(args?: SelectSubset<T, MenteePreferenceRefFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteePreferenceRefPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MenteePreferenceRef.
     * @param {MenteePreferenceRefCreateArgs} args - Arguments to create a MenteePreferenceRef.
     * @example
     * // Create one MenteePreferenceRef
     * const MenteePreferenceRef = await prisma.menteePreferenceRef.create({
     *   data: {
     *     // ... data to create a MenteePreferenceRef
     *   }
     * })
     * 
     */
    create<T extends MenteePreferenceRefCreateArgs>(args: SelectSubset<T, MenteePreferenceRefCreateArgs<ExtArgs>>): Prisma__MenteePreferenceRefClient<$Result.GetResult<Prisma.$MenteePreferenceRefPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MenteePreferenceRefs.
     * @param {MenteePreferenceRefCreateManyArgs} args - Arguments to create many MenteePreferenceRefs.
     * @example
     * // Create many MenteePreferenceRefs
     * const menteePreferenceRef = await prisma.menteePreferenceRef.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MenteePreferenceRefCreateManyArgs>(args?: SelectSubset<T, MenteePreferenceRefCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MenteePreferenceRefs and returns the data saved in the database.
     * @param {MenteePreferenceRefCreateManyAndReturnArgs} args - Arguments to create many MenteePreferenceRefs.
     * @example
     * // Create many MenteePreferenceRefs
     * const menteePreferenceRef = await prisma.menteePreferenceRef.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MenteePreferenceRefs and only return the `user_id`
     * const menteePreferenceRefWithUser_idOnly = await prisma.menteePreferenceRef.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MenteePreferenceRefCreateManyAndReturnArgs>(args?: SelectSubset<T, MenteePreferenceRefCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteePreferenceRefPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MenteePreferenceRef.
     * @param {MenteePreferenceRefDeleteArgs} args - Arguments to delete one MenteePreferenceRef.
     * @example
     * // Delete one MenteePreferenceRef
     * const MenteePreferenceRef = await prisma.menteePreferenceRef.delete({
     *   where: {
     *     // ... filter to delete one MenteePreferenceRef
     *   }
     * })
     * 
     */
    delete<T extends MenteePreferenceRefDeleteArgs>(args: SelectSubset<T, MenteePreferenceRefDeleteArgs<ExtArgs>>): Prisma__MenteePreferenceRefClient<$Result.GetResult<Prisma.$MenteePreferenceRefPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MenteePreferenceRef.
     * @param {MenteePreferenceRefUpdateArgs} args - Arguments to update one MenteePreferenceRef.
     * @example
     * // Update one MenteePreferenceRef
     * const menteePreferenceRef = await prisma.menteePreferenceRef.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MenteePreferenceRefUpdateArgs>(args: SelectSubset<T, MenteePreferenceRefUpdateArgs<ExtArgs>>): Prisma__MenteePreferenceRefClient<$Result.GetResult<Prisma.$MenteePreferenceRefPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MenteePreferenceRefs.
     * @param {MenteePreferenceRefDeleteManyArgs} args - Arguments to filter MenteePreferenceRefs to delete.
     * @example
     * // Delete a few MenteePreferenceRefs
     * const { count } = await prisma.menteePreferenceRef.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MenteePreferenceRefDeleteManyArgs>(args?: SelectSubset<T, MenteePreferenceRefDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenteePreferenceRefs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteePreferenceRefUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MenteePreferenceRefs
     * const menteePreferenceRef = await prisma.menteePreferenceRef.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MenteePreferenceRefUpdateManyArgs>(args: SelectSubset<T, MenteePreferenceRefUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenteePreferenceRefs and returns the data updated in the database.
     * @param {MenteePreferenceRefUpdateManyAndReturnArgs} args - Arguments to update many MenteePreferenceRefs.
     * @example
     * // Update many MenteePreferenceRefs
     * const menteePreferenceRef = await prisma.menteePreferenceRef.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MenteePreferenceRefs and only return the `user_id`
     * const menteePreferenceRefWithUser_idOnly = await prisma.menteePreferenceRef.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MenteePreferenceRefUpdateManyAndReturnArgs>(args: SelectSubset<T, MenteePreferenceRefUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenteePreferenceRefPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MenteePreferenceRef.
     * @param {MenteePreferenceRefUpsertArgs} args - Arguments to update or create a MenteePreferenceRef.
     * @example
     * // Update or create a MenteePreferenceRef
     * const menteePreferenceRef = await prisma.menteePreferenceRef.upsert({
     *   create: {
     *     // ... data to create a MenteePreferenceRef
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MenteePreferenceRef we want to update
     *   }
     * })
     */
    upsert<T extends MenteePreferenceRefUpsertArgs>(args: SelectSubset<T, MenteePreferenceRefUpsertArgs<ExtArgs>>): Prisma__MenteePreferenceRefClient<$Result.GetResult<Prisma.$MenteePreferenceRefPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MenteePreferenceRefs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteePreferenceRefCountArgs} args - Arguments to filter MenteePreferenceRefs to count.
     * @example
     * // Count the number of MenteePreferenceRefs
     * const count = await prisma.menteePreferenceRef.count({
     *   where: {
     *     // ... the filter for the MenteePreferenceRefs we want to count
     *   }
     * })
    **/
    count<T extends MenteePreferenceRefCountArgs>(
      args?: Subset<T, MenteePreferenceRefCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenteePreferenceRefCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MenteePreferenceRef.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteePreferenceRefAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenteePreferenceRefAggregateArgs>(args: Subset<T, MenteePreferenceRefAggregateArgs>): Prisma.PrismaPromise<GetMenteePreferenceRefAggregateType<T>>

    /**
     * Group by MenteePreferenceRef.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenteePreferenceRefGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenteePreferenceRefGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenteePreferenceRefGroupByArgs['orderBy'] }
        : { orderBy?: MenteePreferenceRefGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenteePreferenceRefGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenteePreferenceRefGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MenteePreferenceRef model
   */
  readonly fields: MenteePreferenceRefFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MenteePreferenceRef.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenteePreferenceRefClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    preference<T extends PreferenceRefDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PreferenceRefDefaultArgs<ExtArgs>>): Prisma__PreferenceRefClient<$Result.GetResult<Prisma.$PreferenceRefPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MenteePreferenceRef model
   */
  interface MenteePreferenceRefFieldRefs {
    readonly user_id: FieldRef<"MenteePreferenceRef", 'String'>
    readonly preference_id: FieldRef<"MenteePreferenceRef", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MenteePreferenceRef findUnique
   */
  export type MenteePreferenceRefFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteePreferenceRef
     */
    select?: MenteePreferenceRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteePreferenceRef
     */
    omit?: MenteePreferenceRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteePreferenceRefInclude<ExtArgs> | null
    /**
     * Filter, which MenteePreferenceRef to fetch.
     */
    where: MenteePreferenceRefWhereUniqueInput
  }

  /**
   * MenteePreferenceRef findUniqueOrThrow
   */
  export type MenteePreferenceRefFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteePreferenceRef
     */
    select?: MenteePreferenceRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteePreferenceRef
     */
    omit?: MenteePreferenceRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteePreferenceRefInclude<ExtArgs> | null
    /**
     * Filter, which MenteePreferenceRef to fetch.
     */
    where: MenteePreferenceRefWhereUniqueInput
  }

  /**
   * MenteePreferenceRef findFirst
   */
  export type MenteePreferenceRefFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteePreferenceRef
     */
    select?: MenteePreferenceRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteePreferenceRef
     */
    omit?: MenteePreferenceRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteePreferenceRefInclude<ExtArgs> | null
    /**
     * Filter, which MenteePreferenceRef to fetch.
     */
    where?: MenteePreferenceRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteePreferenceRefs to fetch.
     */
    orderBy?: MenteePreferenceRefOrderByWithRelationInput | MenteePreferenceRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenteePreferenceRefs.
     */
    cursor?: MenteePreferenceRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteePreferenceRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteePreferenceRefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenteePreferenceRefs.
     */
    distinct?: MenteePreferenceRefScalarFieldEnum | MenteePreferenceRefScalarFieldEnum[]
  }

  /**
   * MenteePreferenceRef findFirstOrThrow
   */
  export type MenteePreferenceRefFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteePreferenceRef
     */
    select?: MenteePreferenceRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteePreferenceRef
     */
    omit?: MenteePreferenceRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteePreferenceRefInclude<ExtArgs> | null
    /**
     * Filter, which MenteePreferenceRef to fetch.
     */
    where?: MenteePreferenceRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteePreferenceRefs to fetch.
     */
    orderBy?: MenteePreferenceRefOrderByWithRelationInput | MenteePreferenceRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenteePreferenceRefs.
     */
    cursor?: MenteePreferenceRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteePreferenceRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteePreferenceRefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenteePreferenceRefs.
     */
    distinct?: MenteePreferenceRefScalarFieldEnum | MenteePreferenceRefScalarFieldEnum[]
  }

  /**
   * MenteePreferenceRef findMany
   */
  export type MenteePreferenceRefFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteePreferenceRef
     */
    select?: MenteePreferenceRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteePreferenceRef
     */
    omit?: MenteePreferenceRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteePreferenceRefInclude<ExtArgs> | null
    /**
     * Filter, which MenteePreferenceRefs to fetch.
     */
    where?: MenteePreferenceRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenteePreferenceRefs to fetch.
     */
    orderBy?: MenteePreferenceRefOrderByWithRelationInput | MenteePreferenceRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MenteePreferenceRefs.
     */
    cursor?: MenteePreferenceRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenteePreferenceRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenteePreferenceRefs.
     */
    skip?: number
    distinct?: MenteePreferenceRefScalarFieldEnum | MenteePreferenceRefScalarFieldEnum[]
  }

  /**
   * MenteePreferenceRef create
   */
  export type MenteePreferenceRefCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteePreferenceRef
     */
    select?: MenteePreferenceRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteePreferenceRef
     */
    omit?: MenteePreferenceRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteePreferenceRefInclude<ExtArgs> | null
    /**
     * The data needed to create a MenteePreferenceRef.
     */
    data: XOR<MenteePreferenceRefCreateInput, MenteePreferenceRefUncheckedCreateInput>
  }

  /**
   * MenteePreferenceRef createMany
   */
  export type MenteePreferenceRefCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MenteePreferenceRefs.
     */
    data: MenteePreferenceRefCreateManyInput | MenteePreferenceRefCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MenteePreferenceRef createManyAndReturn
   */
  export type MenteePreferenceRefCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteePreferenceRef
     */
    select?: MenteePreferenceRefSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenteePreferenceRef
     */
    omit?: MenteePreferenceRefOmit<ExtArgs> | null
    /**
     * The data used to create many MenteePreferenceRefs.
     */
    data: MenteePreferenceRefCreateManyInput | MenteePreferenceRefCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteePreferenceRefIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenteePreferenceRef update
   */
  export type MenteePreferenceRefUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteePreferenceRef
     */
    select?: MenteePreferenceRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteePreferenceRef
     */
    omit?: MenteePreferenceRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteePreferenceRefInclude<ExtArgs> | null
    /**
     * The data needed to update a MenteePreferenceRef.
     */
    data: XOR<MenteePreferenceRefUpdateInput, MenteePreferenceRefUncheckedUpdateInput>
    /**
     * Choose, which MenteePreferenceRef to update.
     */
    where: MenteePreferenceRefWhereUniqueInput
  }

  /**
   * MenteePreferenceRef updateMany
   */
  export type MenteePreferenceRefUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MenteePreferenceRefs.
     */
    data: XOR<MenteePreferenceRefUpdateManyMutationInput, MenteePreferenceRefUncheckedUpdateManyInput>
    /**
     * Filter which MenteePreferenceRefs to update
     */
    where?: MenteePreferenceRefWhereInput
    /**
     * Limit how many MenteePreferenceRefs to update.
     */
    limit?: number
  }

  /**
   * MenteePreferenceRef updateManyAndReturn
   */
  export type MenteePreferenceRefUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteePreferenceRef
     */
    select?: MenteePreferenceRefSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenteePreferenceRef
     */
    omit?: MenteePreferenceRefOmit<ExtArgs> | null
    /**
     * The data used to update MenteePreferenceRefs.
     */
    data: XOR<MenteePreferenceRefUpdateManyMutationInput, MenteePreferenceRefUncheckedUpdateManyInput>
    /**
     * Filter which MenteePreferenceRefs to update
     */
    where?: MenteePreferenceRefWhereInput
    /**
     * Limit how many MenteePreferenceRefs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteePreferenceRefIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenteePreferenceRef upsert
   */
  export type MenteePreferenceRefUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteePreferenceRef
     */
    select?: MenteePreferenceRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteePreferenceRef
     */
    omit?: MenteePreferenceRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteePreferenceRefInclude<ExtArgs> | null
    /**
     * The filter to search for the MenteePreferenceRef to update in case it exists.
     */
    where: MenteePreferenceRefWhereUniqueInput
    /**
     * In case the MenteePreferenceRef found by the `where` argument doesn't exist, create a new MenteePreferenceRef with this data.
     */
    create: XOR<MenteePreferenceRefCreateInput, MenteePreferenceRefUncheckedCreateInput>
    /**
     * In case the MenteePreferenceRef was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenteePreferenceRefUpdateInput, MenteePreferenceRefUncheckedUpdateInput>
  }

  /**
   * MenteePreferenceRef delete
   */
  export type MenteePreferenceRefDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteePreferenceRef
     */
    select?: MenteePreferenceRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteePreferenceRef
     */
    omit?: MenteePreferenceRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteePreferenceRefInclude<ExtArgs> | null
    /**
     * Filter which MenteePreferenceRef to delete.
     */
    where: MenteePreferenceRefWhereUniqueInput
  }

  /**
   * MenteePreferenceRef deleteMany
   */
  export type MenteePreferenceRefDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenteePreferenceRefs to delete
     */
    where?: MenteePreferenceRefWhereInput
    /**
     * Limit how many MenteePreferenceRefs to delete.
     */
    limit?: number
  }

  /**
   * MenteePreferenceRef without action
   */
  export type MenteePreferenceRefDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenteePreferenceRef
     */
    select?: MenteePreferenceRefSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenteePreferenceRef
     */
    omit?: MenteePreferenceRefOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenteePreferenceRefInclude<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    website: string | null
    tax_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    website: string | null
    tax_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    website: number
    tax_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    website?: true
    tax_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    website?: true
    tax_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    website?: true
    tax_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    name: string
    website: string | null
    tax_id: string | null
    created_at: Date
    updated_at: Date
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    website?: boolean
    tax_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    mentor_company_membership?: boolean | Company$mentor_company_membershipArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    website?: boolean
    tax_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    website?: boolean
    tax_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    website?: boolean
    tax_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "website" | "tax_id" | "created_at" | "updated_at", ExtArgs["result"]["company"]>
  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentor_company_membership?: boolean | Company$mentor_company_membershipArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      mentor_company_membership: Prisma.$MentorCompanyMembershipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      website: string | null
      tax_id: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {CompanyUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mentor_company_membership<T extends Company$mentor_company_membershipArgs<ExtArgs> = {}>(args?: Subset<T, Company$mentor_company_membershipArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorCompanyMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly website: FieldRef<"Company", 'String'>
    readonly tax_id: FieldRef<"Company", 'String'>
    readonly created_at: FieldRef<"Company", 'DateTime'>
    readonly updated_at: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company updateManyAndReturn
   */
  export type CompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to delete.
     */
    limit?: number
  }

  /**
   * Company.mentor_company_membership
   */
  export type Company$mentor_company_membershipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorCompanyMembership
     */
    select?: MentorCompanyMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorCompanyMembership
     */
    omit?: MentorCompanyMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorCompanyMembershipInclude<ExtArgs> | null
    where?: MentorCompanyMembershipWhereInput
    orderBy?: MentorCompanyMembershipOrderByWithRelationInput | MentorCompanyMembershipOrderByWithRelationInput[]
    cursor?: MentorCompanyMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentorCompanyMembershipScalarFieldEnum | MentorCompanyMembershipScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model MentorCompanyMembership
   */

  export type AggregateMentorCompanyMembership = {
    _count: MentorCompanyMembershipCountAggregateOutputType | null
    _min: MentorCompanyMembershipMinAggregateOutputType | null
    _max: MentorCompanyMembershipMaxAggregateOutputType | null
  }

  export type MentorCompanyMembershipMinAggregateOutputType = {
    mentor_id: string | null
    company_id: string | null
    role_title: string | null
    work_email: string | null
    created_at: Date | null
  }

  export type MentorCompanyMembershipMaxAggregateOutputType = {
    mentor_id: string | null
    company_id: string | null
    role_title: string | null
    work_email: string | null
    created_at: Date | null
  }

  export type MentorCompanyMembershipCountAggregateOutputType = {
    mentor_id: number
    company_id: number
    role_title: number
    work_email: number
    created_at: number
    _all: number
  }


  export type MentorCompanyMembershipMinAggregateInputType = {
    mentor_id?: true
    company_id?: true
    role_title?: true
    work_email?: true
    created_at?: true
  }

  export type MentorCompanyMembershipMaxAggregateInputType = {
    mentor_id?: true
    company_id?: true
    role_title?: true
    work_email?: true
    created_at?: true
  }

  export type MentorCompanyMembershipCountAggregateInputType = {
    mentor_id?: true
    company_id?: true
    role_title?: true
    work_email?: true
    created_at?: true
    _all?: true
  }

  export type MentorCompanyMembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MentorCompanyMembership to aggregate.
     */
    where?: MentorCompanyMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorCompanyMemberships to fetch.
     */
    orderBy?: MentorCompanyMembershipOrderByWithRelationInput | MentorCompanyMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MentorCompanyMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorCompanyMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorCompanyMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MentorCompanyMemberships
    **/
    _count?: true | MentorCompanyMembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MentorCompanyMembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MentorCompanyMembershipMaxAggregateInputType
  }

  export type GetMentorCompanyMembershipAggregateType<T extends MentorCompanyMembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateMentorCompanyMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMentorCompanyMembership[P]>
      : GetScalarType<T[P], AggregateMentorCompanyMembership[P]>
  }




  export type MentorCompanyMembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorCompanyMembershipWhereInput
    orderBy?: MentorCompanyMembershipOrderByWithAggregationInput | MentorCompanyMembershipOrderByWithAggregationInput[]
    by: MentorCompanyMembershipScalarFieldEnum[] | MentorCompanyMembershipScalarFieldEnum
    having?: MentorCompanyMembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MentorCompanyMembershipCountAggregateInputType | true
    _min?: MentorCompanyMembershipMinAggregateInputType
    _max?: MentorCompanyMembershipMaxAggregateInputType
  }

  export type MentorCompanyMembershipGroupByOutputType = {
    mentor_id: string
    company_id: string
    role_title: string | null
    work_email: string | null
    created_at: Date
    _count: MentorCompanyMembershipCountAggregateOutputType | null
    _min: MentorCompanyMembershipMinAggregateOutputType | null
    _max: MentorCompanyMembershipMaxAggregateOutputType | null
  }

  type GetMentorCompanyMembershipGroupByPayload<T extends MentorCompanyMembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MentorCompanyMembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MentorCompanyMembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MentorCompanyMembershipGroupByOutputType[P]>
            : GetScalarType<T[P], MentorCompanyMembershipGroupByOutputType[P]>
        }
      >
    >


  export type MentorCompanyMembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mentor_id?: boolean
    company_id?: boolean
    role_title?: boolean
    work_email?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorCompanyMembership"]>

  export type MentorCompanyMembershipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mentor_id?: boolean
    company_id?: boolean
    role_title?: boolean
    work_email?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorCompanyMembership"]>

  export type MentorCompanyMembershipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mentor_id?: boolean
    company_id?: boolean
    role_title?: boolean
    work_email?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorCompanyMembership"]>

  export type MentorCompanyMembershipSelectScalar = {
    mentor_id?: boolean
    company_id?: boolean
    role_title?: boolean
    work_email?: boolean
    created_at?: boolean
  }

  export type MentorCompanyMembershipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"mentor_id" | "company_id" | "role_title" | "work_email" | "created_at", ExtArgs["result"]["mentorCompanyMembership"]>
  export type MentorCompanyMembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type MentorCompanyMembershipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type MentorCompanyMembershipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $MentorCompanyMembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MentorCompanyMembership"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      mentor_id: string
      company_id: string
      role_title: string | null
      work_email: string | null
      created_at: Date
    }, ExtArgs["result"]["mentorCompanyMembership"]>
    composites: {}
  }

  type MentorCompanyMembershipGetPayload<S extends boolean | null | undefined | MentorCompanyMembershipDefaultArgs> = $Result.GetResult<Prisma.$MentorCompanyMembershipPayload, S>

  type MentorCompanyMembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MentorCompanyMembershipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MentorCompanyMembershipCountAggregateInputType | true
    }

  export interface MentorCompanyMembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MentorCompanyMembership'], meta: { name: 'MentorCompanyMembership' } }
    /**
     * Find zero or one MentorCompanyMembership that matches the filter.
     * @param {MentorCompanyMembershipFindUniqueArgs} args - Arguments to find a MentorCompanyMembership
     * @example
     * // Get one MentorCompanyMembership
     * const mentorCompanyMembership = await prisma.mentorCompanyMembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MentorCompanyMembershipFindUniqueArgs>(args: SelectSubset<T, MentorCompanyMembershipFindUniqueArgs<ExtArgs>>): Prisma__MentorCompanyMembershipClient<$Result.GetResult<Prisma.$MentorCompanyMembershipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MentorCompanyMembership that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MentorCompanyMembershipFindUniqueOrThrowArgs} args - Arguments to find a MentorCompanyMembership
     * @example
     * // Get one MentorCompanyMembership
     * const mentorCompanyMembership = await prisma.mentorCompanyMembership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MentorCompanyMembershipFindUniqueOrThrowArgs>(args: SelectSubset<T, MentorCompanyMembershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MentorCompanyMembershipClient<$Result.GetResult<Prisma.$MentorCompanyMembershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MentorCompanyMembership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorCompanyMembershipFindFirstArgs} args - Arguments to find a MentorCompanyMembership
     * @example
     * // Get one MentorCompanyMembership
     * const mentorCompanyMembership = await prisma.mentorCompanyMembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MentorCompanyMembershipFindFirstArgs>(args?: SelectSubset<T, MentorCompanyMembershipFindFirstArgs<ExtArgs>>): Prisma__MentorCompanyMembershipClient<$Result.GetResult<Prisma.$MentorCompanyMembershipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MentorCompanyMembership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorCompanyMembershipFindFirstOrThrowArgs} args - Arguments to find a MentorCompanyMembership
     * @example
     * // Get one MentorCompanyMembership
     * const mentorCompanyMembership = await prisma.mentorCompanyMembership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MentorCompanyMembershipFindFirstOrThrowArgs>(args?: SelectSubset<T, MentorCompanyMembershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__MentorCompanyMembershipClient<$Result.GetResult<Prisma.$MentorCompanyMembershipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MentorCompanyMemberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorCompanyMembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MentorCompanyMemberships
     * const mentorCompanyMemberships = await prisma.mentorCompanyMembership.findMany()
     * 
     * // Get first 10 MentorCompanyMemberships
     * const mentorCompanyMemberships = await prisma.mentorCompanyMembership.findMany({ take: 10 })
     * 
     * // Only select the `mentor_id`
     * const mentorCompanyMembershipWithMentor_idOnly = await prisma.mentorCompanyMembership.findMany({ select: { mentor_id: true } })
     * 
     */
    findMany<T extends MentorCompanyMembershipFindManyArgs>(args?: SelectSubset<T, MentorCompanyMembershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorCompanyMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MentorCompanyMembership.
     * @param {MentorCompanyMembershipCreateArgs} args - Arguments to create a MentorCompanyMembership.
     * @example
     * // Create one MentorCompanyMembership
     * const MentorCompanyMembership = await prisma.mentorCompanyMembership.create({
     *   data: {
     *     // ... data to create a MentorCompanyMembership
     *   }
     * })
     * 
     */
    create<T extends MentorCompanyMembershipCreateArgs>(args: SelectSubset<T, MentorCompanyMembershipCreateArgs<ExtArgs>>): Prisma__MentorCompanyMembershipClient<$Result.GetResult<Prisma.$MentorCompanyMembershipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MentorCompanyMemberships.
     * @param {MentorCompanyMembershipCreateManyArgs} args - Arguments to create many MentorCompanyMemberships.
     * @example
     * // Create many MentorCompanyMemberships
     * const mentorCompanyMembership = await prisma.mentorCompanyMembership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MentorCompanyMembershipCreateManyArgs>(args?: SelectSubset<T, MentorCompanyMembershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MentorCompanyMemberships and returns the data saved in the database.
     * @param {MentorCompanyMembershipCreateManyAndReturnArgs} args - Arguments to create many MentorCompanyMemberships.
     * @example
     * // Create many MentorCompanyMemberships
     * const mentorCompanyMembership = await prisma.mentorCompanyMembership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MentorCompanyMemberships and only return the `mentor_id`
     * const mentorCompanyMembershipWithMentor_idOnly = await prisma.mentorCompanyMembership.createManyAndReturn({
     *   select: { mentor_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MentorCompanyMembershipCreateManyAndReturnArgs>(args?: SelectSubset<T, MentorCompanyMembershipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorCompanyMembershipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MentorCompanyMembership.
     * @param {MentorCompanyMembershipDeleteArgs} args - Arguments to delete one MentorCompanyMembership.
     * @example
     * // Delete one MentorCompanyMembership
     * const MentorCompanyMembership = await prisma.mentorCompanyMembership.delete({
     *   where: {
     *     // ... filter to delete one MentorCompanyMembership
     *   }
     * })
     * 
     */
    delete<T extends MentorCompanyMembershipDeleteArgs>(args: SelectSubset<T, MentorCompanyMembershipDeleteArgs<ExtArgs>>): Prisma__MentorCompanyMembershipClient<$Result.GetResult<Prisma.$MentorCompanyMembershipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MentorCompanyMembership.
     * @param {MentorCompanyMembershipUpdateArgs} args - Arguments to update one MentorCompanyMembership.
     * @example
     * // Update one MentorCompanyMembership
     * const mentorCompanyMembership = await prisma.mentorCompanyMembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MentorCompanyMembershipUpdateArgs>(args: SelectSubset<T, MentorCompanyMembershipUpdateArgs<ExtArgs>>): Prisma__MentorCompanyMembershipClient<$Result.GetResult<Prisma.$MentorCompanyMembershipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MentorCompanyMemberships.
     * @param {MentorCompanyMembershipDeleteManyArgs} args - Arguments to filter MentorCompanyMemberships to delete.
     * @example
     * // Delete a few MentorCompanyMemberships
     * const { count } = await prisma.mentorCompanyMembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MentorCompanyMembershipDeleteManyArgs>(args?: SelectSubset<T, MentorCompanyMembershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MentorCompanyMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorCompanyMembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MentorCompanyMemberships
     * const mentorCompanyMembership = await prisma.mentorCompanyMembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MentorCompanyMembershipUpdateManyArgs>(args: SelectSubset<T, MentorCompanyMembershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MentorCompanyMemberships and returns the data updated in the database.
     * @param {MentorCompanyMembershipUpdateManyAndReturnArgs} args - Arguments to update many MentorCompanyMemberships.
     * @example
     * // Update many MentorCompanyMemberships
     * const mentorCompanyMembership = await prisma.mentorCompanyMembership.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MentorCompanyMemberships and only return the `mentor_id`
     * const mentorCompanyMembershipWithMentor_idOnly = await prisma.mentorCompanyMembership.updateManyAndReturn({
     *   select: { mentor_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MentorCompanyMembershipUpdateManyAndReturnArgs>(args: SelectSubset<T, MentorCompanyMembershipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorCompanyMembershipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MentorCompanyMembership.
     * @param {MentorCompanyMembershipUpsertArgs} args - Arguments to update or create a MentorCompanyMembership.
     * @example
     * // Update or create a MentorCompanyMembership
     * const mentorCompanyMembership = await prisma.mentorCompanyMembership.upsert({
     *   create: {
     *     // ... data to create a MentorCompanyMembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MentorCompanyMembership we want to update
     *   }
     * })
     */
    upsert<T extends MentorCompanyMembershipUpsertArgs>(args: SelectSubset<T, MentorCompanyMembershipUpsertArgs<ExtArgs>>): Prisma__MentorCompanyMembershipClient<$Result.GetResult<Prisma.$MentorCompanyMembershipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MentorCompanyMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorCompanyMembershipCountArgs} args - Arguments to filter MentorCompanyMemberships to count.
     * @example
     * // Count the number of MentorCompanyMemberships
     * const count = await prisma.mentorCompanyMembership.count({
     *   where: {
     *     // ... the filter for the MentorCompanyMemberships we want to count
     *   }
     * })
    **/
    count<T extends MentorCompanyMembershipCountArgs>(
      args?: Subset<T, MentorCompanyMembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MentorCompanyMembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MentorCompanyMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorCompanyMembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MentorCompanyMembershipAggregateArgs>(args: Subset<T, MentorCompanyMembershipAggregateArgs>): Prisma.PrismaPromise<GetMentorCompanyMembershipAggregateType<T>>

    /**
     * Group by MentorCompanyMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorCompanyMembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MentorCompanyMembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MentorCompanyMembershipGroupByArgs['orderBy'] }
        : { orderBy?: MentorCompanyMembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MentorCompanyMembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMentorCompanyMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MentorCompanyMembership model
   */
  readonly fields: MentorCompanyMembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MentorCompanyMembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MentorCompanyMembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MentorCompanyMembership model
   */
  interface MentorCompanyMembershipFieldRefs {
    readonly mentor_id: FieldRef<"MentorCompanyMembership", 'String'>
    readonly company_id: FieldRef<"MentorCompanyMembership", 'String'>
    readonly role_title: FieldRef<"MentorCompanyMembership", 'String'>
    readonly work_email: FieldRef<"MentorCompanyMembership", 'String'>
    readonly created_at: FieldRef<"MentorCompanyMembership", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MentorCompanyMembership findUnique
   */
  export type MentorCompanyMembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorCompanyMembership
     */
    select?: MentorCompanyMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorCompanyMembership
     */
    omit?: MentorCompanyMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorCompanyMembershipInclude<ExtArgs> | null
    /**
     * Filter, which MentorCompanyMembership to fetch.
     */
    where: MentorCompanyMembershipWhereUniqueInput
  }

  /**
   * MentorCompanyMembership findUniqueOrThrow
   */
  export type MentorCompanyMembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorCompanyMembership
     */
    select?: MentorCompanyMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorCompanyMembership
     */
    omit?: MentorCompanyMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorCompanyMembershipInclude<ExtArgs> | null
    /**
     * Filter, which MentorCompanyMembership to fetch.
     */
    where: MentorCompanyMembershipWhereUniqueInput
  }

  /**
   * MentorCompanyMembership findFirst
   */
  export type MentorCompanyMembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorCompanyMembership
     */
    select?: MentorCompanyMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorCompanyMembership
     */
    omit?: MentorCompanyMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorCompanyMembershipInclude<ExtArgs> | null
    /**
     * Filter, which MentorCompanyMembership to fetch.
     */
    where?: MentorCompanyMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorCompanyMemberships to fetch.
     */
    orderBy?: MentorCompanyMembershipOrderByWithRelationInput | MentorCompanyMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MentorCompanyMemberships.
     */
    cursor?: MentorCompanyMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorCompanyMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorCompanyMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MentorCompanyMemberships.
     */
    distinct?: MentorCompanyMembershipScalarFieldEnum | MentorCompanyMembershipScalarFieldEnum[]
  }

  /**
   * MentorCompanyMembership findFirstOrThrow
   */
  export type MentorCompanyMembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorCompanyMembership
     */
    select?: MentorCompanyMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorCompanyMembership
     */
    omit?: MentorCompanyMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorCompanyMembershipInclude<ExtArgs> | null
    /**
     * Filter, which MentorCompanyMembership to fetch.
     */
    where?: MentorCompanyMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorCompanyMemberships to fetch.
     */
    orderBy?: MentorCompanyMembershipOrderByWithRelationInput | MentorCompanyMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MentorCompanyMemberships.
     */
    cursor?: MentorCompanyMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorCompanyMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorCompanyMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MentorCompanyMemberships.
     */
    distinct?: MentorCompanyMembershipScalarFieldEnum | MentorCompanyMembershipScalarFieldEnum[]
  }

  /**
   * MentorCompanyMembership findMany
   */
  export type MentorCompanyMembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorCompanyMembership
     */
    select?: MentorCompanyMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorCompanyMembership
     */
    omit?: MentorCompanyMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorCompanyMembershipInclude<ExtArgs> | null
    /**
     * Filter, which MentorCompanyMemberships to fetch.
     */
    where?: MentorCompanyMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorCompanyMemberships to fetch.
     */
    orderBy?: MentorCompanyMembershipOrderByWithRelationInput | MentorCompanyMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MentorCompanyMemberships.
     */
    cursor?: MentorCompanyMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorCompanyMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorCompanyMemberships.
     */
    skip?: number
    distinct?: MentorCompanyMembershipScalarFieldEnum | MentorCompanyMembershipScalarFieldEnum[]
  }

  /**
   * MentorCompanyMembership create
   */
  export type MentorCompanyMembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorCompanyMembership
     */
    select?: MentorCompanyMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorCompanyMembership
     */
    omit?: MentorCompanyMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorCompanyMembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a MentorCompanyMembership.
     */
    data: XOR<MentorCompanyMembershipCreateInput, MentorCompanyMembershipUncheckedCreateInput>
  }

  /**
   * MentorCompanyMembership createMany
   */
  export type MentorCompanyMembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MentorCompanyMemberships.
     */
    data: MentorCompanyMembershipCreateManyInput | MentorCompanyMembershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MentorCompanyMembership createManyAndReturn
   */
  export type MentorCompanyMembershipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorCompanyMembership
     */
    select?: MentorCompanyMembershipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MentorCompanyMembership
     */
    omit?: MentorCompanyMembershipOmit<ExtArgs> | null
    /**
     * The data used to create many MentorCompanyMemberships.
     */
    data: MentorCompanyMembershipCreateManyInput | MentorCompanyMembershipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorCompanyMembershipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MentorCompanyMembership update
   */
  export type MentorCompanyMembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorCompanyMembership
     */
    select?: MentorCompanyMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorCompanyMembership
     */
    omit?: MentorCompanyMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorCompanyMembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a MentorCompanyMembership.
     */
    data: XOR<MentorCompanyMembershipUpdateInput, MentorCompanyMembershipUncheckedUpdateInput>
    /**
     * Choose, which MentorCompanyMembership to update.
     */
    where: MentorCompanyMembershipWhereUniqueInput
  }

  /**
   * MentorCompanyMembership updateMany
   */
  export type MentorCompanyMembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MentorCompanyMemberships.
     */
    data: XOR<MentorCompanyMembershipUpdateManyMutationInput, MentorCompanyMembershipUncheckedUpdateManyInput>
    /**
     * Filter which MentorCompanyMemberships to update
     */
    where?: MentorCompanyMembershipWhereInput
    /**
     * Limit how many MentorCompanyMemberships to update.
     */
    limit?: number
  }

  /**
   * MentorCompanyMembership updateManyAndReturn
   */
  export type MentorCompanyMembershipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorCompanyMembership
     */
    select?: MentorCompanyMembershipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MentorCompanyMembership
     */
    omit?: MentorCompanyMembershipOmit<ExtArgs> | null
    /**
     * The data used to update MentorCompanyMemberships.
     */
    data: XOR<MentorCompanyMembershipUpdateManyMutationInput, MentorCompanyMembershipUncheckedUpdateManyInput>
    /**
     * Filter which MentorCompanyMemberships to update
     */
    where?: MentorCompanyMembershipWhereInput
    /**
     * Limit how many MentorCompanyMemberships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorCompanyMembershipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MentorCompanyMembership upsert
   */
  export type MentorCompanyMembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorCompanyMembership
     */
    select?: MentorCompanyMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorCompanyMembership
     */
    omit?: MentorCompanyMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorCompanyMembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the MentorCompanyMembership to update in case it exists.
     */
    where: MentorCompanyMembershipWhereUniqueInput
    /**
     * In case the MentorCompanyMembership found by the `where` argument doesn't exist, create a new MentorCompanyMembership with this data.
     */
    create: XOR<MentorCompanyMembershipCreateInput, MentorCompanyMembershipUncheckedCreateInput>
    /**
     * In case the MentorCompanyMembership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MentorCompanyMembershipUpdateInput, MentorCompanyMembershipUncheckedUpdateInput>
  }

  /**
   * MentorCompanyMembership delete
   */
  export type MentorCompanyMembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorCompanyMembership
     */
    select?: MentorCompanyMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorCompanyMembership
     */
    omit?: MentorCompanyMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorCompanyMembershipInclude<ExtArgs> | null
    /**
     * Filter which MentorCompanyMembership to delete.
     */
    where: MentorCompanyMembershipWhereUniqueInput
  }

  /**
   * MentorCompanyMembership deleteMany
   */
  export type MentorCompanyMembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MentorCompanyMemberships to delete
     */
    where?: MentorCompanyMembershipWhereInput
    /**
     * Limit how many MentorCompanyMemberships to delete.
     */
    limit?: number
  }

  /**
   * MentorCompanyMembership without action
   */
  export type MentorCompanyMembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorCompanyMembership
     */
    select?: MentorCompanyMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MentorCompanyMembership
     */
    omit?: MentorCompanyMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorCompanyMembershipInclude<ExtArgs> | null
  }


  /**
   * Model UserConsent
   */

  export type AggregateUserConsent = {
    _count: UserConsentCountAggregateOutputType | null
    _min: UserConsentMinAggregateOutputType | null
    _max: UserConsentMaxAggregateOutputType | null
  }

  export type UserConsentMinAggregateOutputType = {
    user_id: string | null
    kvkk_accepted_at: Date | null
    kvkk_version: string | null
    ip_address: string | null
    marketing_opt_in: boolean | null
    created_at: Date | null
  }

  export type UserConsentMaxAggregateOutputType = {
    user_id: string | null
    kvkk_accepted_at: Date | null
    kvkk_version: string | null
    ip_address: string | null
    marketing_opt_in: boolean | null
    created_at: Date | null
  }

  export type UserConsentCountAggregateOutputType = {
    user_id: number
    kvkk_accepted_at: number
    kvkk_version: number
    ip_address: number
    marketing_opt_in: number
    created_at: number
    _all: number
  }


  export type UserConsentMinAggregateInputType = {
    user_id?: true
    kvkk_accepted_at?: true
    kvkk_version?: true
    ip_address?: true
    marketing_opt_in?: true
    created_at?: true
  }

  export type UserConsentMaxAggregateInputType = {
    user_id?: true
    kvkk_accepted_at?: true
    kvkk_version?: true
    ip_address?: true
    marketing_opt_in?: true
    created_at?: true
  }

  export type UserConsentCountAggregateInputType = {
    user_id?: true
    kvkk_accepted_at?: true
    kvkk_version?: true
    ip_address?: true
    marketing_opt_in?: true
    created_at?: true
    _all?: true
  }

  export type UserConsentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserConsent to aggregate.
     */
    where?: UserConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConsents to fetch.
     */
    orderBy?: UserConsentOrderByWithRelationInput | UserConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserConsents
    **/
    _count?: true | UserConsentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserConsentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserConsentMaxAggregateInputType
  }

  export type GetUserConsentAggregateType<T extends UserConsentAggregateArgs> = {
        [P in keyof T & keyof AggregateUserConsent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserConsent[P]>
      : GetScalarType<T[P], AggregateUserConsent[P]>
  }




  export type UserConsentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserConsentWhereInput
    orderBy?: UserConsentOrderByWithAggregationInput | UserConsentOrderByWithAggregationInput[]
    by: UserConsentScalarFieldEnum[] | UserConsentScalarFieldEnum
    having?: UserConsentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserConsentCountAggregateInputType | true
    _min?: UserConsentMinAggregateInputType
    _max?: UserConsentMaxAggregateInputType
  }

  export type UserConsentGroupByOutputType = {
    user_id: string
    kvkk_accepted_at: Date
    kvkk_version: string | null
    ip_address: string | null
    marketing_opt_in: boolean
    created_at: Date
    _count: UserConsentCountAggregateOutputType | null
    _min: UserConsentMinAggregateOutputType | null
    _max: UserConsentMaxAggregateOutputType | null
  }

  type GetUserConsentGroupByPayload<T extends UserConsentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserConsentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserConsentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserConsentGroupByOutputType[P]>
            : GetScalarType<T[P], UserConsentGroupByOutputType[P]>
        }
      >
    >


  export type UserConsentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    kvkk_accepted_at?: boolean
    kvkk_version?: boolean
    ip_address?: boolean
    marketing_opt_in?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userConsent"]>

  export type UserConsentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    kvkk_accepted_at?: boolean
    kvkk_version?: boolean
    ip_address?: boolean
    marketing_opt_in?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userConsent"]>

  export type UserConsentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    kvkk_accepted_at?: boolean
    kvkk_version?: boolean
    ip_address?: boolean
    marketing_opt_in?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userConsent"]>

  export type UserConsentSelectScalar = {
    user_id?: boolean
    kvkk_accepted_at?: boolean
    kvkk_version?: boolean
    ip_address?: boolean
    marketing_opt_in?: boolean
    created_at?: boolean
  }

  export type UserConsentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "kvkk_accepted_at" | "kvkk_version" | "ip_address" | "marketing_opt_in" | "created_at", ExtArgs["result"]["userConsent"]>
  export type UserConsentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserConsentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserConsentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserConsentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserConsent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: string
      kvkk_accepted_at: Date
      kvkk_version: string | null
      ip_address: string | null
      marketing_opt_in: boolean
      created_at: Date
    }, ExtArgs["result"]["userConsent"]>
    composites: {}
  }

  type UserConsentGetPayload<S extends boolean | null | undefined | UserConsentDefaultArgs> = $Result.GetResult<Prisma.$UserConsentPayload, S>

  type UserConsentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserConsentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserConsentCountAggregateInputType | true
    }

  export interface UserConsentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserConsent'], meta: { name: 'UserConsent' } }
    /**
     * Find zero or one UserConsent that matches the filter.
     * @param {UserConsentFindUniqueArgs} args - Arguments to find a UserConsent
     * @example
     * // Get one UserConsent
     * const userConsent = await prisma.userConsent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserConsentFindUniqueArgs>(args: SelectSubset<T, UserConsentFindUniqueArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserConsent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserConsentFindUniqueOrThrowArgs} args - Arguments to find a UserConsent
     * @example
     * // Get one UserConsent
     * const userConsent = await prisma.userConsent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserConsentFindUniqueOrThrowArgs>(args: SelectSubset<T, UserConsentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserConsent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentFindFirstArgs} args - Arguments to find a UserConsent
     * @example
     * // Get one UserConsent
     * const userConsent = await prisma.userConsent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserConsentFindFirstArgs>(args?: SelectSubset<T, UserConsentFindFirstArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserConsent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentFindFirstOrThrowArgs} args - Arguments to find a UserConsent
     * @example
     * // Get one UserConsent
     * const userConsent = await prisma.userConsent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserConsentFindFirstOrThrowArgs>(args?: SelectSubset<T, UserConsentFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserConsents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserConsents
     * const userConsents = await prisma.userConsent.findMany()
     * 
     * // Get first 10 UserConsents
     * const userConsents = await prisma.userConsent.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const userConsentWithUser_idOnly = await prisma.userConsent.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends UserConsentFindManyArgs>(args?: SelectSubset<T, UserConsentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserConsent.
     * @param {UserConsentCreateArgs} args - Arguments to create a UserConsent.
     * @example
     * // Create one UserConsent
     * const UserConsent = await prisma.userConsent.create({
     *   data: {
     *     // ... data to create a UserConsent
     *   }
     * })
     * 
     */
    create<T extends UserConsentCreateArgs>(args: SelectSubset<T, UserConsentCreateArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserConsents.
     * @param {UserConsentCreateManyArgs} args - Arguments to create many UserConsents.
     * @example
     * // Create many UserConsents
     * const userConsent = await prisma.userConsent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserConsentCreateManyArgs>(args?: SelectSubset<T, UserConsentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserConsents and returns the data saved in the database.
     * @param {UserConsentCreateManyAndReturnArgs} args - Arguments to create many UserConsents.
     * @example
     * // Create many UserConsents
     * const userConsent = await prisma.userConsent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserConsents and only return the `user_id`
     * const userConsentWithUser_idOnly = await prisma.userConsent.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserConsentCreateManyAndReturnArgs>(args?: SelectSubset<T, UserConsentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserConsent.
     * @param {UserConsentDeleteArgs} args - Arguments to delete one UserConsent.
     * @example
     * // Delete one UserConsent
     * const UserConsent = await prisma.userConsent.delete({
     *   where: {
     *     // ... filter to delete one UserConsent
     *   }
     * })
     * 
     */
    delete<T extends UserConsentDeleteArgs>(args: SelectSubset<T, UserConsentDeleteArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserConsent.
     * @param {UserConsentUpdateArgs} args - Arguments to update one UserConsent.
     * @example
     * // Update one UserConsent
     * const userConsent = await prisma.userConsent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserConsentUpdateArgs>(args: SelectSubset<T, UserConsentUpdateArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserConsents.
     * @param {UserConsentDeleteManyArgs} args - Arguments to filter UserConsents to delete.
     * @example
     * // Delete a few UserConsents
     * const { count } = await prisma.userConsent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserConsentDeleteManyArgs>(args?: SelectSubset<T, UserConsentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserConsents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserConsents
     * const userConsent = await prisma.userConsent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserConsentUpdateManyArgs>(args: SelectSubset<T, UserConsentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserConsents and returns the data updated in the database.
     * @param {UserConsentUpdateManyAndReturnArgs} args - Arguments to update many UserConsents.
     * @example
     * // Update many UserConsents
     * const userConsent = await prisma.userConsent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserConsents and only return the `user_id`
     * const userConsentWithUser_idOnly = await prisma.userConsent.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserConsentUpdateManyAndReturnArgs>(args: SelectSubset<T, UserConsentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserConsent.
     * @param {UserConsentUpsertArgs} args - Arguments to update or create a UserConsent.
     * @example
     * // Update or create a UserConsent
     * const userConsent = await prisma.userConsent.upsert({
     *   create: {
     *     // ... data to create a UserConsent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserConsent we want to update
     *   }
     * })
     */
    upsert<T extends UserConsentUpsertArgs>(args: SelectSubset<T, UserConsentUpsertArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserConsents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentCountArgs} args - Arguments to filter UserConsents to count.
     * @example
     * // Count the number of UserConsents
     * const count = await prisma.userConsent.count({
     *   where: {
     *     // ... the filter for the UserConsents we want to count
     *   }
     * })
    **/
    count<T extends UserConsentCountArgs>(
      args?: Subset<T, UserConsentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserConsentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserConsent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserConsentAggregateArgs>(args: Subset<T, UserConsentAggregateArgs>): Prisma.PrismaPromise<GetUserConsentAggregateType<T>>

    /**
     * Group by UserConsent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserConsentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserConsentGroupByArgs['orderBy'] }
        : { orderBy?: UserConsentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserConsentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserConsentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserConsent model
   */
  readonly fields: UserConsentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserConsent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserConsentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserConsent model
   */
  interface UserConsentFieldRefs {
    readonly user_id: FieldRef<"UserConsent", 'String'>
    readonly kvkk_accepted_at: FieldRef<"UserConsent", 'DateTime'>
    readonly kvkk_version: FieldRef<"UserConsent", 'String'>
    readonly ip_address: FieldRef<"UserConsent", 'String'>
    readonly marketing_opt_in: FieldRef<"UserConsent", 'Boolean'>
    readonly created_at: FieldRef<"UserConsent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserConsent findUnique
   */
  export type UserConsentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter, which UserConsent to fetch.
     */
    where: UserConsentWhereUniqueInput
  }

  /**
   * UserConsent findUniqueOrThrow
   */
  export type UserConsentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter, which UserConsent to fetch.
     */
    where: UserConsentWhereUniqueInput
  }

  /**
   * UserConsent findFirst
   */
  export type UserConsentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter, which UserConsent to fetch.
     */
    where?: UserConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConsents to fetch.
     */
    orderBy?: UserConsentOrderByWithRelationInput | UserConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserConsents.
     */
    cursor?: UserConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserConsents.
     */
    distinct?: UserConsentScalarFieldEnum | UserConsentScalarFieldEnum[]
  }

  /**
   * UserConsent findFirstOrThrow
   */
  export type UserConsentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter, which UserConsent to fetch.
     */
    where?: UserConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConsents to fetch.
     */
    orderBy?: UserConsentOrderByWithRelationInput | UserConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserConsents.
     */
    cursor?: UserConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserConsents.
     */
    distinct?: UserConsentScalarFieldEnum | UserConsentScalarFieldEnum[]
  }

  /**
   * UserConsent findMany
   */
  export type UserConsentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter, which UserConsents to fetch.
     */
    where?: UserConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConsents to fetch.
     */
    orderBy?: UserConsentOrderByWithRelationInput | UserConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserConsents.
     */
    cursor?: UserConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConsents.
     */
    skip?: number
    distinct?: UserConsentScalarFieldEnum | UserConsentScalarFieldEnum[]
  }

  /**
   * UserConsent create
   */
  export type UserConsentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * The data needed to create a UserConsent.
     */
    data: XOR<UserConsentCreateInput, UserConsentUncheckedCreateInput>
  }

  /**
   * UserConsent createMany
   */
  export type UserConsentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserConsents.
     */
    data: UserConsentCreateManyInput | UserConsentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserConsent createManyAndReturn
   */
  export type UserConsentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * The data used to create many UserConsents.
     */
    data: UserConsentCreateManyInput | UserConsentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserConsent update
   */
  export type UserConsentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * The data needed to update a UserConsent.
     */
    data: XOR<UserConsentUpdateInput, UserConsentUncheckedUpdateInput>
    /**
     * Choose, which UserConsent to update.
     */
    where: UserConsentWhereUniqueInput
  }

  /**
   * UserConsent updateMany
   */
  export type UserConsentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserConsents.
     */
    data: XOR<UserConsentUpdateManyMutationInput, UserConsentUncheckedUpdateManyInput>
    /**
     * Filter which UserConsents to update
     */
    where?: UserConsentWhereInput
    /**
     * Limit how many UserConsents to update.
     */
    limit?: number
  }

  /**
   * UserConsent updateManyAndReturn
   */
  export type UserConsentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * The data used to update UserConsents.
     */
    data: XOR<UserConsentUpdateManyMutationInput, UserConsentUncheckedUpdateManyInput>
    /**
     * Filter which UserConsents to update
     */
    where?: UserConsentWhereInput
    /**
     * Limit how many UserConsents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserConsent upsert
   */
  export type UserConsentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * The filter to search for the UserConsent to update in case it exists.
     */
    where: UserConsentWhereUniqueInput
    /**
     * In case the UserConsent found by the `where` argument doesn't exist, create a new UserConsent with this data.
     */
    create: XOR<UserConsentCreateInput, UserConsentUncheckedCreateInput>
    /**
     * In case the UserConsent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserConsentUpdateInput, UserConsentUncheckedUpdateInput>
  }

  /**
   * UserConsent delete
   */
  export type UserConsentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter which UserConsent to delete.
     */
    where: UserConsentWhereUniqueInput
  }

  /**
   * UserConsent deleteMany
   */
  export type UserConsentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserConsents to delete
     */
    where?: UserConsentWhereInput
    /**
     * Limit how many UserConsents to delete.
     */
    limit?: number
  }

  /**
   * UserConsent without action
   */
  export type UserConsentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    full_name: 'full_name',
    role: 'role',
    password_hash: 'password_hash',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const MenteeScalarFieldEnum: {
    user_id: 'user_id',
    short_goal: 'short_goal',
    target_track: 'target_track',
    budget: 'budget',
    time_preference: 'time_preference',
    city: 'city',
    country: 'country',
    goal_type: 'goal_type',
    service_focus: 'service_focus',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type MenteeScalarFieldEnum = (typeof MenteeScalarFieldEnum)[keyof typeof MenteeScalarFieldEnum]


  export const MentorScalarFieldEnum: {
    user_id: 'user_id',
    mentor_type: 'mentor_type',
    display_name: 'display_name',
    title: 'title',
    years_experience: 'years_experience',
    hourly_rate_cents: 'hourly_rate_cents',
    meeting_preference: 'meeting_preference',
    bio_short: 'bio_short',
    bio_long: 'bio_long',
    city: 'city',
    country: 'country',
    rating_avg: 'rating_avg',
    total_reviews: 'total_reviews',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type MentorScalarFieldEnum = (typeof MentorScalarFieldEnum)[keyof typeof MentorScalarFieldEnum]


  export const ServiceFocusRefScalarFieldEnum: {
    id: 'id',
    label: 'label',
    active: 'active',
    sort_order: 'sort_order'
  };

  export type ServiceFocusRefScalarFieldEnum = (typeof ServiceFocusRefScalarFieldEnum)[keyof typeof ServiceFocusRefScalarFieldEnum]


  export const LanguageRefScalarFieldEnum: {
    id: 'id',
    label: 'label',
    active: 'active',
    sort_order: 'sort_order'
  };

  export type LanguageRefScalarFieldEnum = (typeof LanguageRefScalarFieldEnum)[keyof typeof LanguageRefScalarFieldEnum]


  export const DisciplineRefScalarFieldEnum: {
    id: 'id',
    label: 'label',
    active: 'active',
    sort_order: 'sort_order'
  };

  export type DisciplineRefScalarFieldEnum = (typeof DisciplineRefScalarFieldEnum)[keyof typeof DisciplineRefScalarFieldEnum]


  export const PreferenceRefScalarFieldEnum: {
    id: 'id',
    label: 'label',
    active: 'active',
    sort_order: 'sort_order'
  };

  export type PreferenceRefScalarFieldEnum = (typeof PreferenceRefScalarFieldEnum)[keyof typeof PreferenceRefScalarFieldEnum]


  export const MenteeLanguageScalarFieldEnum: {
    user_id: 'user_id',
    lang_code: 'lang_code'
  };

  export type MenteeLanguageScalarFieldEnum = (typeof MenteeLanguageScalarFieldEnum)[keyof typeof MenteeLanguageScalarFieldEnum]


  export const MenteeInterestScalarFieldEnum: {
    user_id: 'user_id',
    interest: 'interest',
    created_at: 'created_at'
  };

  export type MenteeInterestScalarFieldEnum = (typeof MenteeInterestScalarFieldEnum)[keyof typeof MenteeInterestScalarFieldEnum]


  export const MenteePriorityScalarFieldEnum: {
    user_id: 'user_id',
    priority: 'priority',
    created_at: 'created_at'
  };

  export type MenteePriorityScalarFieldEnum = (typeof MenteePriorityScalarFieldEnum)[keyof typeof MenteePriorityScalarFieldEnum]


  export const MentorLanguageScalarFieldEnum: {
    user_id: 'user_id',
    lang_code: 'lang_code'
  };

  export type MentorLanguageScalarFieldEnum = (typeof MentorLanguageScalarFieldEnum)[keyof typeof MentorLanguageScalarFieldEnum]


  export const MentorCategoryScalarFieldEnum: {
    user_id: 'user_id',
    category: 'category'
  };

  export type MentorCategoryScalarFieldEnum = (typeof MentorCategoryScalarFieldEnum)[keyof typeof MentorCategoryScalarFieldEnum]


  export const MentorSkillScalarFieldEnum: {
    user_id: 'user_id',
    skill: 'skill'
  };

  export type MentorSkillScalarFieldEnum = (typeof MentorSkillScalarFieldEnum)[keyof typeof MentorSkillScalarFieldEnum]


  export const MenteeServiceFocusScalarFieldEnum: {
    user_id: 'user_id',
    service_focus_id: 'service_focus_id'
  };

  export type MenteeServiceFocusScalarFieldEnum = (typeof MenteeServiceFocusScalarFieldEnum)[keyof typeof MenteeServiceFocusScalarFieldEnum]


  export const MenteeLanguageRefScalarFieldEnum: {
    user_id: 'user_id',
    language_id: 'language_id'
  };

  export type MenteeLanguageRefScalarFieldEnum = (typeof MenteeLanguageRefScalarFieldEnum)[keyof typeof MenteeLanguageRefScalarFieldEnum]


  export const MenteeDisciplineRefScalarFieldEnum: {
    user_id: 'user_id',
    discipline_id: 'discipline_id'
  };

  export type MenteeDisciplineRefScalarFieldEnum = (typeof MenteeDisciplineRefScalarFieldEnum)[keyof typeof MenteeDisciplineRefScalarFieldEnum]


  export const MenteePreferenceRefScalarFieldEnum: {
    user_id: 'user_id',
    preference_id: 'preference_id'
  };

  export type MenteePreferenceRefScalarFieldEnum = (typeof MenteePreferenceRefScalarFieldEnum)[keyof typeof MenteePreferenceRefScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    website: 'website',
    tax_id: 'tax_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const MentorCompanyMembershipScalarFieldEnum: {
    mentor_id: 'mentor_id',
    company_id: 'company_id',
    role_title: 'role_title',
    work_email: 'work_email',
    created_at: 'created_at'
  };

  export type MentorCompanyMembershipScalarFieldEnum = (typeof MentorCompanyMembershipScalarFieldEnum)[keyof typeof MentorCompanyMembershipScalarFieldEnum]


  export const UserConsentScalarFieldEnum: {
    user_id: 'user_id',
    kvkk_accepted_at: 'kvkk_accepted_at',
    kvkk_version: 'kvkk_version',
    ip_address: 'ip_address',
    marketing_opt_in: 'marketing_opt_in',
    created_at: 'created_at'
  };

  export type UserConsentScalarFieldEnum = (typeof UserConsentScalarFieldEnum)[keyof typeof UserConsentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'MentorType'
   */
  export type EnumMentorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MentorType'>
    


  /**
   * Reference to a field of type 'MentorType[]'
   */
  export type ListEnumMentorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MentorType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'MentorStatus'
   */
  export type EnumMentorStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MentorStatus'>
    


  /**
   * Reference to a field of type 'MentorStatus[]'
   */
  export type ListEnumMentorStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MentorStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: UuidFilter<"User"> | string
    email?: StringFilter<"User"> | string
    full_name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    password_hash?: StringFilter<"User"> | string
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    mentee_profile?: XOR<MenteeNullableScalarRelationFilter, MenteeWhereInput> | null
    mentor_profile?: XOR<MentorNullableScalarRelationFilter, MentorWhereInput> | null
    user_consent?: XOR<UserConsentNullableScalarRelationFilter, UserConsentWhereInput> | null
    mentee_languages?: MenteeLanguageListRelationFilter
    mentee_interests?: MenteeInterestListRelationFilter
    mentee_priorities?: MenteePriorityListRelationFilter
    mentor_languages?: MentorLanguageListRelationFilter
    mentor_categories?: MentorCategoryListRelationFilter
    mentor_skills?: MentorSkillListRelationFilter
    mentee_service_focus?: MenteeServiceFocusListRelationFilter
    mentee_languages_ref?: MenteeLanguageRefListRelationFilter
    mentee_disciplines_ref?: MenteeDisciplineRefListRelationFilter
    mentee_preferences_ref?: MenteePreferenceRefListRelationFilter
    mentor_company_membership?: MentorCompanyMembershipListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    full_name?: SortOrder
    role?: SortOrder
    password_hash?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    mentee_profile?: MenteeOrderByWithRelationInput
    mentor_profile?: MentorOrderByWithRelationInput
    user_consent?: UserConsentOrderByWithRelationInput
    mentee_languages?: MenteeLanguageOrderByRelationAggregateInput
    mentee_interests?: MenteeInterestOrderByRelationAggregateInput
    mentee_priorities?: MenteePriorityOrderByRelationAggregateInput
    mentor_languages?: MentorLanguageOrderByRelationAggregateInput
    mentor_categories?: MentorCategoryOrderByRelationAggregateInput
    mentor_skills?: MentorSkillOrderByRelationAggregateInput
    mentee_service_focus?: MenteeServiceFocusOrderByRelationAggregateInput
    mentee_languages_ref?: MenteeLanguageRefOrderByRelationAggregateInput
    mentee_disciplines_ref?: MenteeDisciplineRefOrderByRelationAggregateInput
    mentee_preferences_ref?: MenteePreferenceRefOrderByRelationAggregateInput
    mentor_company_membership?: MentorCompanyMembershipOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    full_name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    password_hash?: StringFilter<"User"> | string
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    mentee_profile?: XOR<MenteeNullableScalarRelationFilter, MenteeWhereInput> | null
    mentor_profile?: XOR<MentorNullableScalarRelationFilter, MentorWhereInput> | null
    user_consent?: XOR<UserConsentNullableScalarRelationFilter, UserConsentWhereInput> | null
    mentee_languages?: MenteeLanguageListRelationFilter
    mentee_interests?: MenteeInterestListRelationFilter
    mentee_priorities?: MenteePriorityListRelationFilter
    mentor_languages?: MentorLanguageListRelationFilter
    mentor_categories?: MentorCategoryListRelationFilter
    mentor_skills?: MentorSkillListRelationFilter
    mentee_service_focus?: MenteeServiceFocusListRelationFilter
    mentee_languages_ref?: MenteeLanguageRefListRelationFilter
    mentee_disciplines_ref?: MenteeDisciplineRefListRelationFilter
    mentee_preferences_ref?: MenteePreferenceRefListRelationFilter
    mentor_company_membership?: MentorCompanyMembershipListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    full_name?: SortOrder
    role?: SortOrder
    password_hash?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    full_name?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    password_hash?: StringWithAggregatesFilter<"User"> | string
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type MenteeWhereInput = {
    AND?: MenteeWhereInput | MenteeWhereInput[]
    OR?: MenteeWhereInput[]
    NOT?: MenteeWhereInput | MenteeWhereInput[]
    user_id?: UuidFilter<"Mentee"> | string
    short_goal?: StringFilter<"Mentee"> | string
    target_track?: StringFilter<"Mentee"> | string
    budget?: StringFilter<"Mentee"> | string
    time_preference?: StringFilter<"Mentee"> | string
    city?: StringNullableFilter<"Mentee"> | string | null
    country?: StringFilter<"Mentee"> | string
    goal_type?: StringNullableFilter<"Mentee"> | string | null
    service_focus?: StringNullableFilter<"Mentee"> | string | null
    created_at?: DateTimeFilter<"Mentee"> | Date | string
    updated_at?: DateTimeFilter<"Mentee"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MenteeOrderByWithRelationInput = {
    user_id?: SortOrder
    short_goal?: SortOrder
    target_track?: SortOrder
    budget?: SortOrder
    time_preference?: SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrder
    goal_type?: SortOrderInput | SortOrder
    service_focus?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MenteeWhereUniqueInput = Prisma.AtLeast<{
    user_id?: string
    AND?: MenteeWhereInput | MenteeWhereInput[]
    OR?: MenteeWhereInput[]
    NOT?: MenteeWhereInput | MenteeWhereInput[]
    short_goal?: StringFilter<"Mentee"> | string
    target_track?: StringFilter<"Mentee"> | string
    budget?: StringFilter<"Mentee"> | string
    time_preference?: StringFilter<"Mentee"> | string
    city?: StringNullableFilter<"Mentee"> | string | null
    country?: StringFilter<"Mentee"> | string
    goal_type?: StringNullableFilter<"Mentee"> | string | null
    service_focus?: StringNullableFilter<"Mentee"> | string | null
    created_at?: DateTimeFilter<"Mentee"> | Date | string
    updated_at?: DateTimeFilter<"Mentee"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "user_id">

  export type MenteeOrderByWithAggregationInput = {
    user_id?: SortOrder
    short_goal?: SortOrder
    target_track?: SortOrder
    budget?: SortOrder
    time_preference?: SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrder
    goal_type?: SortOrderInput | SortOrder
    service_focus?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: MenteeCountOrderByAggregateInput
    _max?: MenteeMaxOrderByAggregateInput
    _min?: MenteeMinOrderByAggregateInput
  }

  export type MenteeScalarWhereWithAggregatesInput = {
    AND?: MenteeScalarWhereWithAggregatesInput | MenteeScalarWhereWithAggregatesInput[]
    OR?: MenteeScalarWhereWithAggregatesInput[]
    NOT?: MenteeScalarWhereWithAggregatesInput | MenteeScalarWhereWithAggregatesInput[]
    user_id?: UuidWithAggregatesFilter<"Mentee"> | string
    short_goal?: StringWithAggregatesFilter<"Mentee"> | string
    target_track?: StringWithAggregatesFilter<"Mentee"> | string
    budget?: StringWithAggregatesFilter<"Mentee"> | string
    time_preference?: StringWithAggregatesFilter<"Mentee"> | string
    city?: StringNullableWithAggregatesFilter<"Mentee"> | string | null
    country?: StringWithAggregatesFilter<"Mentee"> | string
    goal_type?: StringNullableWithAggregatesFilter<"Mentee"> | string | null
    service_focus?: StringNullableWithAggregatesFilter<"Mentee"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Mentee"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Mentee"> | Date | string
  }

  export type MentorWhereInput = {
    AND?: MentorWhereInput | MentorWhereInput[]
    OR?: MentorWhereInput[]
    NOT?: MentorWhereInput | MentorWhereInput[]
    user_id?: UuidFilter<"Mentor"> | string
    mentor_type?: EnumMentorTypeFilter<"Mentor"> | $Enums.MentorType
    display_name?: StringFilter<"Mentor"> | string
    title?: StringFilter<"Mentor"> | string
    years_experience?: IntFilter<"Mentor"> | number
    hourly_rate_cents?: IntFilter<"Mentor"> | number
    meeting_preference?: StringFilter<"Mentor"> | string
    bio_short?: StringFilter<"Mentor"> | string
    bio_long?: StringFilter<"Mentor"> | string
    city?: StringNullableFilter<"Mentor"> | string | null
    country?: StringFilter<"Mentor"> | string
    rating_avg?: DecimalFilter<"Mentor"> | Decimal | DecimalJsLike | number | string
    total_reviews?: IntFilter<"Mentor"> | number
    status?: EnumMentorStatusFilter<"Mentor"> | $Enums.MentorStatus
    created_at?: DateTimeFilter<"Mentor"> | Date | string
    updated_at?: DateTimeFilter<"Mentor"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MentorOrderByWithRelationInput = {
    user_id?: SortOrder
    mentor_type?: SortOrder
    display_name?: SortOrder
    title?: SortOrder
    years_experience?: SortOrder
    hourly_rate_cents?: SortOrder
    meeting_preference?: SortOrder
    bio_short?: SortOrder
    bio_long?: SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrder
    rating_avg?: SortOrder
    total_reviews?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MentorWhereUniqueInput = Prisma.AtLeast<{
    user_id?: string
    AND?: MentorWhereInput | MentorWhereInput[]
    OR?: MentorWhereInput[]
    NOT?: MentorWhereInput | MentorWhereInput[]
    mentor_type?: EnumMentorTypeFilter<"Mentor"> | $Enums.MentorType
    display_name?: StringFilter<"Mentor"> | string
    title?: StringFilter<"Mentor"> | string
    years_experience?: IntFilter<"Mentor"> | number
    hourly_rate_cents?: IntFilter<"Mentor"> | number
    meeting_preference?: StringFilter<"Mentor"> | string
    bio_short?: StringFilter<"Mentor"> | string
    bio_long?: StringFilter<"Mentor"> | string
    city?: StringNullableFilter<"Mentor"> | string | null
    country?: StringFilter<"Mentor"> | string
    rating_avg?: DecimalFilter<"Mentor"> | Decimal | DecimalJsLike | number | string
    total_reviews?: IntFilter<"Mentor"> | number
    status?: EnumMentorStatusFilter<"Mentor"> | $Enums.MentorStatus
    created_at?: DateTimeFilter<"Mentor"> | Date | string
    updated_at?: DateTimeFilter<"Mentor"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "user_id">

  export type MentorOrderByWithAggregationInput = {
    user_id?: SortOrder
    mentor_type?: SortOrder
    display_name?: SortOrder
    title?: SortOrder
    years_experience?: SortOrder
    hourly_rate_cents?: SortOrder
    meeting_preference?: SortOrder
    bio_short?: SortOrder
    bio_long?: SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrder
    rating_avg?: SortOrder
    total_reviews?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: MentorCountOrderByAggregateInput
    _avg?: MentorAvgOrderByAggregateInput
    _max?: MentorMaxOrderByAggregateInput
    _min?: MentorMinOrderByAggregateInput
    _sum?: MentorSumOrderByAggregateInput
  }

  export type MentorScalarWhereWithAggregatesInput = {
    AND?: MentorScalarWhereWithAggregatesInput | MentorScalarWhereWithAggregatesInput[]
    OR?: MentorScalarWhereWithAggregatesInput[]
    NOT?: MentorScalarWhereWithAggregatesInput | MentorScalarWhereWithAggregatesInput[]
    user_id?: UuidWithAggregatesFilter<"Mentor"> | string
    mentor_type?: EnumMentorTypeWithAggregatesFilter<"Mentor"> | $Enums.MentorType
    display_name?: StringWithAggregatesFilter<"Mentor"> | string
    title?: StringWithAggregatesFilter<"Mentor"> | string
    years_experience?: IntWithAggregatesFilter<"Mentor"> | number
    hourly_rate_cents?: IntWithAggregatesFilter<"Mentor"> | number
    meeting_preference?: StringWithAggregatesFilter<"Mentor"> | string
    bio_short?: StringWithAggregatesFilter<"Mentor"> | string
    bio_long?: StringWithAggregatesFilter<"Mentor"> | string
    city?: StringNullableWithAggregatesFilter<"Mentor"> | string | null
    country?: StringWithAggregatesFilter<"Mentor"> | string
    rating_avg?: DecimalWithAggregatesFilter<"Mentor"> | Decimal | DecimalJsLike | number | string
    total_reviews?: IntWithAggregatesFilter<"Mentor"> | number
    status?: EnumMentorStatusWithAggregatesFilter<"Mentor"> | $Enums.MentorStatus
    created_at?: DateTimeWithAggregatesFilter<"Mentor"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Mentor"> | Date | string
  }

  export type ServiceFocusRefWhereInput = {
    AND?: ServiceFocusRefWhereInput | ServiceFocusRefWhereInput[]
    OR?: ServiceFocusRefWhereInput[]
    NOT?: ServiceFocusRefWhereInput | ServiceFocusRefWhereInput[]
    id?: StringFilter<"ServiceFocusRef"> | string
    label?: StringFilter<"ServiceFocusRef"> | string
    active?: BoolFilter<"ServiceFocusRef"> | boolean
    sort_order?: IntFilter<"ServiceFocusRef"> | number
    mentee_service_focus?: MenteeServiceFocusListRelationFilter
  }

  export type ServiceFocusRefOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    active?: SortOrder
    sort_order?: SortOrder
    mentee_service_focus?: MenteeServiceFocusOrderByRelationAggregateInput
  }

  export type ServiceFocusRefWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceFocusRefWhereInput | ServiceFocusRefWhereInput[]
    OR?: ServiceFocusRefWhereInput[]
    NOT?: ServiceFocusRefWhereInput | ServiceFocusRefWhereInput[]
    label?: StringFilter<"ServiceFocusRef"> | string
    active?: BoolFilter<"ServiceFocusRef"> | boolean
    sort_order?: IntFilter<"ServiceFocusRef"> | number
    mentee_service_focus?: MenteeServiceFocusListRelationFilter
  }, "id">

  export type ServiceFocusRefOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    active?: SortOrder
    sort_order?: SortOrder
    _count?: ServiceFocusRefCountOrderByAggregateInput
    _avg?: ServiceFocusRefAvgOrderByAggregateInput
    _max?: ServiceFocusRefMaxOrderByAggregateInput
    _min?: ServiceFocusRefMinOrderByAggregateInput
    _sum?: ServiceFocusRefSumOrderByAggregateInput
  }

  export type ServiceFocusRefScalarWhereWithAggregatesInput = {
    AND?: ServiceFocusRefScalarWhereWithAggregatesInput | ServiceFocusRefScalarWhereWithAggregatesInput[]
    OR?: ServiceFocusRefScalarWhereWithAggregatesInput[]
    NOT?: ServiceFocusRefScalarWhereWithAggregatesInput | ServiceFocusRefScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceFocusRef"> | string
    label?: StringWithAggregatesFilter<"ServiceFocusRef"> | string
    active?: BoolWithAggregatesFilter<"ServiceFocusRef"> | boolean
    sort_order?: IntWithAggregatesFilter<"ServiceFocusRef"> | number
  }

  export type LanguageRefWhereInput = {
    AND?: LanguageRefWhereInput | LanguageRefWhereInput[]
    OR?: LanguageRefWhereInput[]
    NOT?: LanguageRefWhereInput | LanguageRefWhereInput[]
    id?: StringFilter<"LanguageRef"> | string
    label?: StringFilter<"LanguageRef"> | string
    active?: BoolFilter<"LanguageRef"> | boolean
    sort_order?: IntFilter<"LanguageRef"> | number
    mentee_languages_ref?: MenteeLanguageRefListRelationFilter
  }

  export type LanguageRefOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    active?: SortOrder
    sort_order?: SortOrder
    mentee_languages_ref?: MenteeLanguageRefOrderByRelationAggregateInput
  }

  export type LanguageRefWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LanguageRefWhereInput | LanguageRefWhereInput[]
    OR?: LanguageRefWhereInput[]
    NOT?: LanguageRefWhereInput | LanguageRefWhereInput[]
    label?: StringFilter<"LanguageRef"> | string
    active?: BoolFilter<"LanguageRef"> | boolean
    sort_order?: IntFilter<"LanguageRef"> | number
    mentee_languages_ref?: MenteeLanguageRefListRelationFilter
  }, "id">

  export type LanguageRefOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    active?: SortOrder
    sort_order?: SortOrder
    _count?: LanguageRefCountOrderByAggregateInput
    _avg?: LanguageRefAvgOrderByAggregateInput
    _max?: LanguageRefMaxOrderByAggregateInput
    _min?: LanguageRefMinOrderByAggregateInput
    _sum?: LanguageRefSumOrderByAggregateInput
  }

  export type LanguageRefScalarWhereWithAggregatesInput = {
    AND?: LanguageRefScalarWhereWithAggregatesInput | LanguageRefScalarWhereWithAggregatesInput[]
    OR?: LanguageRefScalarWhereWithAggregatesInput[]
    NOT?: LanguageRefScalarWhereWithAggregatesInput | LanguageRefScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LanguageRef"> | string
    label?: StringWithAggregatesFilter<"LanguageRef"> | string
    active?: BoolWithAggregatesFilter<"LanguageRef"> | boolean
    sort_order?: IntWithAggregatesFilter<"LanguageRef"> | number
  }

  export type DisciplineRefWhereInput = {
    AND?: DisciplineRefWhereInput | DisciplineRefWhereInput[]
    OR?: DisciplineRefWhereInput[]
    NOT?: DisciplineRefWhereInput | DisciplineRefWhereInput[]
    id?: StringFilter<"DisciplineRef"> | string
    label?: StringFilter<"DisciplineRef"> | string
    active?: BoolFilter<"DisciplineRef"> | boolean
    sort_order?: IntFilter<"DisciplineRef"> | number
    mentee_disciplines_ref?: MenteeDisciplineRefListRelationFilter
  }

  export type DisciplineRefOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    active?: SortOrder
    sort_order?: SortOrder
    mentee_disciplines_ref?: MenteeDisciplineRefOrderByRelationAggregateInput
  }

  export type DisciplineRefWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DisciplineRefWhereInput | DisciplineRefWhereInput[]
    OR?: DisciplineRefWhereInput[]
    NOT?: DisciplineRefWhereInput | DisciplineRefWhereInput[]
    label?: StringFilter<"DisciplineRef"> | string
    active?: BoolFilter<"DisciplineRef"> | boolean
    sort_order?: IntFilter<"DisciplineRef"> | number
    mentee_disciplines_ref?: MenteeDisciplineRefListRelationFilter
  }, "id">

  export type DisciplineRefOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    active?: SortOrder
    sort_order?: SortOrder
    _count?: DisciplineRefCountOrderByAggregateInput
    _avg?: DisciplineRefAvgOrderByAggregateInput
    _max?: DisciplineRefMaxOrderByAggregateInput
    _min?: DisciplineRefMinOrderByAggregateInput
    _sum?: DisciplineRefSumOrderByAggregateInput
  }

  export type DisciplineRefScalarWhereWithAggregatesInput = {
    AND?: DisciplineRefScalarWhereWithAggregatesInput | DisciplineRefScalarWhereWithAggregatesInput[]
    OR?: DisciplineRefScalarWhereWithAggregatesInput[]
    NOT?: DisciplineRefScalarWhereWithAggregatesInput | DisciplineRefScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DisciplineRef"> | string
    label?: StringWithAggregatesFilter<"DisciplineRef"> | string
    active?: BoolWithAggregatesFilter<"DisciplineRef"> | boolean
    sort_order?: IntWithAggregatesFilter<"DisciplineRef"> | number
  }

  export type PreferenceRefWhereInput = {
    AND?: PreferenceRefWhereInput | PreferenceRefWhereInput[]
    OR?: PreferenceRefWhereInput[]
    NOT?: PreferenceRefWhereInput | PreferenceRefWhereInput[]
    id?: StringFilter<"PreferenceRef"> | string
    label?: StringFilter<"PreferenceRef"> | string
    active?: BoolFilter<"PreferenceRef"> | boolean
    sort_order?: IntFilter<"PreferenceRef"> | number
    mentee_preferences_ref?: MenteePreferenceRefListRelationFilter
  }

  export type PreferenceRefOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    active?: SortOrder
    sort_order?: SortOrder
    mentee_preferences_ref?: MenteePreferenceRefOrderByRelationAggregateInput
  }

  export type PreferenceRefWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PreferenceRefWhereInput | PreferenceRefWhereInput[]
    OR?: PreferenceRefWhereInput[]
    NOT?: PreferenceRefWhereInput | PreferenceRefWhereInput[]
    label?: StringFilter<"PreferenceRef"> | string
    active?: BoolFilter<"PreferenceRef"> | boolean
    sort_order?: IntFilter<"PreferenceRef"> | number
    mentee_preferences_ref?: MenteePreferenceRefListRelationFilter
  }, "id">

  export type PreferenceRefOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    active?: SortOrder
    sort_order?: SortOrder
    _count?: PreferenceRefCountOrderByAggregateInput
    _avg?: PreferenceRefAvgOrderByAggregateInput
    _max?: PreferenceRefMaxOrderByAggregateInput
    _min?: PreferenceRefMinOrderByAggregateInput
    _sum?: PreferenceRefSumOrderByAggregateInput
  }

  export type PreferenceRefScalarWhereWithAggregatesInput = {
    AND?: PreferenceRefScalarWhereWithAggregatesInput | PreferenceRefScalarWhereWithAggregatesInput[]
    OR?: PreferenceRefScalarWhereWithAggregatesInput[]
    NOT?: PreferenceRefScalarWhereWithAggregatesInput | PreferenceRefScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PreferenceRef"> | string
    label?: StringWithAggregatesFilter<"PreferenceRef"> | string
    active?: BoolWithAggregatesFilter<"PreferenceRef"> | boolean
    sort_order?: IntWithAggregatesFilter<"PreferenceRef"> | number
  }

  export type MenteeLanguageWhereInput = {
    AND?: MenteeLanguageWhereInput | MenteeLanguageWhereInput[]
    OR?: MenteeLanguageWhereInput[]
    NOT?: MenteeLanguageWhereInput | MenteeLanguageWhereInput[]
    user_id?: UuidFilter<"MenteeLanguage"> | string
    lang_code?: StringFilter<"MenteeLanguage"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MenteeLanguageOrderByWithRelationInput = {
    user_id?: SortOrder
    lang_code?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MenteeLanguageWhereUniqueInput = Prisma.AtLeast<{
    user_id_lang_code?: MenteeLanguageUser_idLang_codeCompoundUniqueInput
    AND?: MenteeLanguageWhereInput | MenteeLanguageWhereInput[]
    OR?: MenteeLanguageWhereInput[]
    NOT?: MenteeLanguageWhereInput | MenteeLanguageWhereInput[]
    user_id?: UuidFilter<"MenteeLanguage"> | string
    lang_code?: StringFilter<"MenteeLanguage"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "user_id_lang_code">

  export type MenteeLanguageOrderByWithAggregationInput = {
    user_id?: SortOrder
    lang_code?: SortOrder
    _count?: MenteeLanguageCountOrderByAggregateInput
    _max?: MenteeLanguageMaxOrderByAggregateInput
    _min?: MenteeLanguageMinOrderByAggregateInput
  }

  export type MenteeLanguageScalarWhereWithAggregatesInput = {
    AND?: MenteeLanguageScalarWhereWithAggregatesInput | MenteeLanguageScalarWhereWithAggregatesInput[]
    OR?: MenteeLanguageScalarWhereWithAggregatesInput[]
    NOT?: MenteeLanguageScalarWhereWithAggregatesInput | MenteeLanguageScalarWhereWithAggregatesInput[]
    user_id?: UuidWithAggregatesFilter<"MenteeLanguage"> | string
    lang_code?: StringWithAggregatesFilter<"MenteeLanguage"> | string
  }

  export type MenteeInterestWhereInput = {
    AND?: MenteeInterestWhereInput | MenteeInterestWhereInput[]
    OR?: MenteeInterestWhereInput[]
    NOT?: MenteeInterestWhereInput | MenteeInterestWhereInput[]
    user_id?: UuidFilter<"MenteeInterest"> | string
    interest?: StringFilter<"MenteeInterest"> | string
    created_at?: DateTimeFilter<"MenteeInterest"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MenteeInterestOrderByWithRelationInput = {
    user_id?: SortOrder
    interest?: SortOrder
    created_at?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MenteeInterestWhereUniqueInput = Prisma.AtLeast<{
    user_id_interest?: MenteeInterestUser_idInterestCompoundUniqueInput
    AND?: MenteeInterestWhereInput | MenteeInterestWhereInput[]
    OR?: MenteeInterestWhereInput[]
    NOT?: MenteeInterestWhereInput | MenteeInterestWhereInput[]
    user_id?: UuidFilter<"MenteeInterest"> | string
    interest?: StringFilter<"MenteeInterest"> | string
    created_at?: DateTimeFilter<"MenteeInterest"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "user_id_interest">

  export type MenteeInterestOrderByWithAggregationInput = {
    user_id?: SortOrder
    interest?: SortOrder
    created_at?: SortOrder
    _count?: MenteeInterestCountOrderByAggregateInput
    _max?: MenteeInterestMaxOrderByAggregateInput
    _min?: MenteeInterestMinOrderByAggregateInput
  }

  export type MenteeInterestScalarWhereWithAggregatesInput = {
    AND?: MenteeInterestScalarWhereWithAggregatesInput | MenteeInterestScalarWhereWithAggregatesInput[]
    OR?: MenteeInterestScalarWhereWithAggregatesInput[]
    NOT?: MenteeInterestScalarWhereWithAggregatesInput | MenteeInterestScalarWhereWithAggregatesInput[]
    user_id?: UuidWithAggregatesFilter<"MenteeInterest"> | string
    interest?: StringWithAggregatesFilter<"MenteeInterest"> | string
    created_at?: DateTimeWithAggregatesFilter<"MenteeInterest"> | Date | string
  }

  export type MenteePriorityWhereInput = {
    AND?: MenteePriorityWhereInput | MenteePriorityWhereInput[]
    OR?: MenteePriorityWhereInput[]
    NOT?: MenteePriorityWhereInput | MenteePriorityWhereInput[]
    user_id?: UuidFilter<"MenteePriority"> | string
    priority?: StringFilter<"MenteePriority"> | string
    created_at?: DateTimeFilter<"MenteePriority"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MenteePriorityOrderByWithRelationInput = {
    user_id?: SortOrder
    priority?: SortOrder
    created_at?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MenteePriorityWhereUniqueInput = Prisma.AtLeast<{
    user_id_priority?: MenteePriorityUser_idPriorityCompoundUniqueInput
    AND?: MenteePriorityWhereInput | MenteePriorityWhereInput[]
    OR?: MenteePriorityWhereInput[]
    NOT?: MenteePriorityWhereInput | MenteePriorityWhereInput[]
    user_id?: UuidFilter<"MenteePriority"> | string
    priority?: StringFilter<"MenteePriority"> | string
    created_at?: DateTimeFilter<"MenteePriority"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "user_id_priority">

  export type MenteePriorityOrderByWithAggregationInput = {
    user_id?: SortOrder
    priority?: SortOrder
    created_at?: SortOrder
    _count?: MenteePriorityCountOrderByAggregateInput
    _max?: MenteePriorityMaxOrderByAggregateInput
    _min?: MenteePriorityMinOrderByAggregateInput
  }

  export type MenteePriorityScalarWhereWithAggregatesInput = {
    AND?: MenteePriorityScalarWhereWithAggregatesInput | MenteePriorityScalarWhereWithAggregatesInput[]
    OR?: MenteePriorityScalarWhereWithAggregatesInput[]
    NOT?: MenteePriorityScalarWhereWithAggregatesInput | MenteePriorityScalarWhereWithAggregatesInput[]
    user_id?: UuidWithAggregatesFilter<"MenteePriority"> | string
    priority?: StringWithAggregatesFilter<"MenteePriority"> | string
    created_at?: DateTimeWithAggregatesFilter<"MenteePriority"> | Date | string
  }

  export type MentorLanguageWhereInput = {
    AND?: MentorLanguageWhereInput | MentorLanguageWhereInput[]
    OR?: MentorLanguageWhereInput[]
    NOT?: MentorLanguageWhereInput | MentorLanguageWhereInput[]
    user_id?: UuidFilter<"MentorLanguage"> | string
    lang_code?: StringFilter<"MentorLanguage"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MentorLanguageOrderByWithRelationInput = {
    user_id?: SortOrder
    lang_code?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MentorLanguageWhereUniqueInput = Prisma.AtLeast<{
    user_id_lang_code?: MentorLanguageUser_idLang_codeCompoundUniqueInput
    AND?: MentorLanguageWhereInput | MentorLanguageWhereInput[]
    OR?: MentorLanguageWhereInput[]
    NOT?: MentorLanguageWhereInput | MentorLanguageWhereInput[]
    user_id?: UuidFilter<"MentorLanguage"> | string
    lang_code?: StringFilter<"MentorLanguage"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "user_id_lang_code">

  export type MentorLanguageOrderByWithAggregationInput = {
    user_id?: SortOrder
    lang_code?: SortOrder
    _count?: MentorLanguageCountOrderByAggregateInput
    _max?: MentorLanguageMaxOrderByAggregateInput
    _min?: MentorLanguageMinOrderByAggregateInput
  }

  export type MentorLanguageScalarWhereWithAggregatesInput = {
    AND?: MentorLanguageScalarWhereWithAggregatesInput | MentorLanguageScalarWhereWithAggregatesInput[]
    OR?: MentorLanguageScalarWhereWithAggregatesInput[]
    NOT?: MentorLanguageScalarWhereWithAggregatesInput | MentorLanguageScalarWhereWithAggregatesInput[]
    user_id?: UuidWithAggregatesFilter<"MentorLanguage"> | string
    lang_code?: StringWithAggregatesFilter<"MentorLanguage"> | string
  }

  export type MentorCategoryWhereInput = {
    AND?: MentorCategoryWhereInput | MentorCategoryWhereInput[]
    OR?: MentorCategoryWhereInput[]
    NOT?: MentorCategoryWhereInput | MentorCategoryWhereInput[]
    user_id?: UuidFilter<"MentorCategory"> | string
    category?: StringFilter<"MentorCategory"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MentorCategoryOrderByWithRelationInput = {
    user_id?: SortOrder
    category?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MentorCategoryWhereUniqueInput = Prisma.AtLeast<{
    user_id_category?: MentorCategoryUser_idCategoryCompoundUniqueInput
    AND?: MentorCategoryWhereInput | MentorCategoryWhereInput[]
    OR?: MentorCategoryWhereInput[]
    NOT?: MentorCategoryWhereInput | MentorCategoryWhereInput[]
    user_id?: UuidFilter<"MentorCategory"> | string
    category?: StringFilter<"MentorCategory"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "user_id_category">

  export type MentorCategoryOrderByWithAggregationInput = {
    user_id?: SortOrder
    category?: SortOrder
    _count?: MentorCategoryCountOrderByAggregateInput
    _max?: MentorCategoryMaxOrderByAggregateInput
    _min?: MentorCategoryMinOrderByAggregateInput
  }

  export type MentorCategoryScalarWhereWithAggregatesInput = {
    AND?: MentorCategoryScalarWhereWithAggregatesInput | MentorCategoryScalarWhereWithAggregatesInput[]
    OR?: MentorCategoryScalarWhereWithAggregatesInput[]
    NOT?: MentorCategoryScalarWhereWithAggregatesInput | MentorCategoryScalarWhereWithAggregatesInput[]
    user_id?: UuidWithAggregatesFilter<"MentorCategory"> | string
    category?: StringWithAggregatesFilter<"MentorCategory"> | string
  }

  export type MentorSkillWhereInput = {
    AND?: MentorSkillWhereInput | MentorSkillWhereInput[]
    OR?: MentorSkillWhereInput[]
    NOT?: MentorSkillWhereInput | MentorSkillWhereInput[]
    user_id?: UuidFilter<"MentorSkill"> | string
    skill?: StringFilter<"MentorSkill"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MentorSkillOrderByWithRelationInput = {
    user_id?: SortOrder
    skill?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MentorSkillWhereUniqueInput = Prisma.AtLeast<{
    user_id_skill?: MentorSkillUser_idSkillCompoundUniqueInput
    AND?: MentorSkillWhereInput | MentorSkillWhereInput[]
    OR?: MentorSkillWhereInput[]
    NOT?: MentorSkillWhereInput | MentorSkillWhereInput[]
    user_id?: UuidFilter<"MentorSkill"> | string
    skill?: StringFilter<"MentorSkill"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "user_id_skill">

  export type MentorSkillOrderByWithAggregationInput = {
    user_id?: SortOrder
    skill?: SortOrder
    _count?: MentorSkillCountOrderByAggregateInput
    _max?: MentorSkillMaxOrderByAggregateInput
    _min?: MentorSkillMinOrderByAggregateInput
  }

  export type MentorSkillScalarWhereWithAggregatesInput = {
    AND?: MentorSkillScalarWhereWithAggregatesInput | MentorSkillScalarWhereWithAggregatesInput[]
    OR?: MentorSkillScalarWhereWithAggregatesInput[]
    NOT?: MentorSkillScalarWhereWithAggregatesInput | MentorSkillScalarWhereWithAggregatesInput[]
    user_id?: UuidWithAggregatesFilter<"MentorSkill"> | string
    skill?: StringWithAggregatesFilter<"MentorSkill"> | string
  }

  export type MenteeServiceFocusWhereInput = {
    AND?: MenteeServiceFocusWhereInput | MenteeServiceFocusWhereInput[]
    OR?: MenteeServiceFocusWhereInput[]
    NOT?: MenteeServiceFocusWhereInput | MenteeServiceFocusWhereInput[]
    user_id?: UuidFilter<"MenteeServiceFocus"> | string
    service_focus_id?: StringFilter<"MenteeServiceFocus"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    service_focus?: XOR<ServiceFocusRefScalarRelationFilter, ServiceFocusRefWhereInput>
  }

  export type MenteeServiceFocusOrderByWithRelationInput = {
    user_id?: SortOrder
    service_focus_id?: SortOrder
    user?: UserOrderByWithRelationInput
    service_focus?: ServiceFocusRefOrderByWithRelationInput
  }

  export type MenteeServiceFocusWhereUniqueInput = Prisma.AtLeast<{
    user_id_service_focus_id?: MenteeServiceFocusUser_idService_focus_idCompoundUniqueInput
    AND?: MenteeServiceFocusWhereInput | MenteeServiceFocusWhereInput[]
    OR?: MenteeServiceFocusWhereInput[]
    NOT?: MenteeServiceFocusWhereInput | MenteeServiceFocusWhereInput[]
    user_id?: UuidFilter<"MenteeServiceFocus"> | string
    service_focus_id?: StringFilter<"MenteeServiceFocus"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    service_focus?: XOR<ServiceFocusRefScalarRelationFilter, ServiceFocusRefWhereInput>
  }, "user_id_service_focus_id">

  export type MenteeServiceFocusOrderByWithAggregationInput = {
    user_id?: SortOrder
    service_focus_id?: SortOrder
    _count?: MenteeServiceFocusCountOrderByAggregateInput
    _max?: MenteeServiceFocusMaxOrderByAggregateInput
    _min?: MenteeServiceFocusMinOrderByAggregateInput
  }

  export type MenteeServiceFocusScalarWhereWithAggregatesInput = {
    AND?: MenteeServiceFocusScalarWhereWithAggregatesInput | MenteeServiceFocusScalarWhereWithAggregatesInput[]
    OR?: MenteeServiceFocusScalarWhereWithAggregatesInput[]
    NOT?: MenteeServiceFocusScalarWhereWithAggregatesInput | MenteeServiceFocusScalarWhereWithAggregatesInput[]
    user_id?: UuidWithAggregatesFilter<"MenteeServiceFocus"> | string
    service_focus_id?: StringWithAggregatesFilter<"MenteeServiceFocus"> | string
  }

  export type MenteeLanguageRefWhereInput = {
    AND?: MenteeLanguageRefWhereInput | MenteeLanguageRefWhereInput[]
    OR?: MenteeLanguageRefWhereInput[]
    NOT?: MenteeLanguageRefWhereInput | MenteeLanguageRefWhereInput[]
    user_id?: UuidFilter<"MenteeLanguageRef"> | string
    language_id?: StringFilter<"MenteeLanguageRef"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    language?: XOR<LanguageRefScalarRelationFilter, LanguageRefWhereInput>
  }

  export type MenteeLanguageRefOrderByWithRelationInput = {
    user_id?: SortOrder
    language_id?: SortOrder
    user?: UserOrderByWithRelationInput
    language?: LanguageRefOrderByWithRelationInput
  }

  export type MenteeLanguageRefWhereUniqueInput = Prisma.AtLeast<{
    user_id_language_id?: MenteeLanguageRefUser_idLanguage_idCompoundUniqueInput
    AND?: MenteeLanguageRefWhereInput | MenteeLanguageRefWhereInput[]
    OR?: MenteeLanguageRefWhereInput[]
    NOT?: MenteeLanguageRefWhereInput | MenteeLanguageRefWhereInput[]
    user_id?: UuidFilter<"MenteeLanguageRef"> | string
    language_id?: StringFilter<"MenteeLanguageRef"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    language?: XOR<LanguageRefScalarRelationFilter, LanguageRefWhereInput>
  }, "user_id_language_id">

  export type MenteeLanguageRefOrderByWithAggregationInput = {
    user_id?: SortOrder
    language_id?: SortOrder
    _count?: MenteeLanguageRefCountOrderByAggregateInput
    _max?: MenteeLanguageRefMaxOrderByAggregateInput
    _min?: MenteeLanguageRefMinOrderByAggregateInput
  }

  export type MenteeLanguageRefScalarWhereWithAggregatesInput = {
    AND?: MenteeLanguageRefScalarWhereWithAggregatesInput | MenteeLanguageRefScalarWhereWithAggregatesInput[]
    OR?: MenteeLanguageRefScalarWhereWithAggregatesInput[]
    NOT?: MenteeLanguageRefScalarWhereWithAggregatesInput | MenteeLanguageRefScalarWhereWithAggregatesInput[]
    user_id?: UuidWithAggregatesFilter<"MenteeLanguageRef"> | string
    language_id?: StringWithAggregatesFilter<"MenteeLanguageRef"> | string
  }

  export type MenteeDisciplineRefWhereInput = {
    AND?: MenteeDisciplineRefWhereInput | MenteeDisciplineRefWhereInput[]
    OR?: MenteeDisciplineRefWhereInput[]
    NOT?: MenteeDisciplineRefWhereInput | MenteeDisciplineRefWhereInput[]
    user_id?: UuidFilter<"MenteeDisciplineRef"> | string
    discipline_id?: StringFilter<"MenteeDisciplineRef"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    discipline?: XOR<DisciplineRefScalarRelationFilter, DisciplineRefWhereInput>
  }

  export type MenteeDisciplineRefOrderByWithRelationInput = {
    user_id?: SortOrder
    discipline_id?: SortOrder
    user?: UserOrderByWithRelationInput
    discipline?: DisciplineRefOrderByWithRelationInput
  }

  export type MenteeDisciplineRefWhereUniqueInput = Prisma.AtLeast<{
    user_id_discipline_id?: MenteeDisciplineRefUser_idDiscipline_idCompoundUniqueInput
    AND?: MenteeDisciplineRefWhereInput | MenteeDisciplineRefWhereInput[]
    OR?: MenteeDisciplineRefWhereInput[]
    NOT?: MenteeDisciplineRefWhereInput | MenteeDisciplineRefWhereInput[]
    user_id?: UuidFilter<"MenteeDisciplineRef"> | string
    discipline_id?: StringFilter<"MenteeDisciplineRef"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    discipline?: XOR<DisciplineRefScalarRelationFilter, DisciplineRefWhereInput>
  }, "user_id_discipline_id">

  export type MenteeDisciplineRefOrderByWithAggregationInput = {
    user_id?: SortOrder
    discipline_id?: SortOrder
    _count?: MenteeDisciplineRefCountOrderByAggregateInput
    _max?: MenteeDisciplineRefMaxOrderByAggregateInput
    _min?: MenteeDisciplineRefMinOrderByAggregateInput
  }

  export type MenteeDisciplineRefScalarWhereWithAggregatesInput = {
    AND?: MenteeDisciplineRefScalarWhereWithAggregatesInput | MenteeDisciplineRefScalarWhereWithAggregatesInput[]
    OR?: MenteeDisciplineRefScalarWhereWithAggregatesInput[]
    NOT?: MenteeDisciplineRefScalarWhereWithAggregatesInput | MenteeDisciplineRefScalarWhereWithAggregatesInput[]
    user_id?: UuidWithAggregatesFilter<"MenteeDisciplineRef"> | string
    discipline_id?: StringWithAggregatesFilter<"MenteeDisciplineRef"> | string
  }

  export type MenteePreferenceRefWhereInput = {
    AND?: MenteePreferenceRefWhereInput | MenteePreferenceRefWhereInput[]
    OR?: MenteePreferenceRefWhereInput[]
    NOT?: MenteePreferenceRefWhereInput | MenteePreferenceRefWhereInput[]
    user_id?: UuidFilter<"MenteePreferenceRef"> | string
    preference_id?: StringFilter<"MenteePreferenceRef"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    preference?: XOR<PreferenceRefScalarRelationFilter, PreferenceRefWhereInput>
  }

  export type MenteePreferenceRefOrderByWithRelationInput = {
    user_id?: SortOrder
    preference_id?: SortOrder
    user?: UserOrderByWithRelationInput
    preference?: PreferenceRefOrderByWithRelationInput
  }

  export type MenteePreferenceRefWhereUniqueInput = Prisma.AtLeast<{
    user_id_preference_id?: MenteePreferenceRefUser_idPreference_idCompoundUniqueInput
    AND?: MenteePreferenceRefWhereInput | MenteePreferenceRefWhereInput[]
    OR?: MenteePreferenceRefWhereInput[]
    NOT?: MenteePreferenceRefWhereInput | MenteePreferenceRefWhereInput[]
    user_id?: UuidFilter<"MenteePreferenceRef"> | string
    preference_id?: StringFilter<"MenteePreferenceRef"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    preference?: XOR<PreferenceRefScalarRelationFilter, PreferenceRefWhereInput>
  }, "user_id_preference_id">

  export type MenteePreferenceRefOrderByWithAggregationInput = {
    user_id?: SortOrder
    preference_id?: SortOrder
    _count?: MenteePreferenceRefCountOrderByAggregateInput
    _max?: MenteePreferenceRefMaxOrderByAggregateInput
    _min?: MenteePreferenceRefMinOrderByAggregateInput
  }

  export type MenteePreferenceRefScalarWhereWithAggregatesInput = {
    AND?: MenteePreferenceRefScalarWhereWithAggregatesInput | MenteePreferenceRefScalarWhereWithAggregatesInput[]
    OR?: MenteePreferenceRefScalarWhereWithAggregatesInput[]
    NOT?: MenteePreferenceRefScalarWhereWithAggregatesInput | MenteePreferenceRefScalarWhereWithAggregatesInput[]
    user_id?: UuidWithAggregatesFilter<"MenteePreferenceRef"> | string
    preference_id?: StringWithAggregatesFilter<"MenteePreferenceRef"> | string
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: UuidFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    website?: StringNullableFilter<"Company"> | string | null
    tax_id?: StringNullableFilter<"Company"> | string | null
    created_at?: DateTimeFilter<"Company"> | Date | string
    updated_at?: DateTimeFilter<"Company"> | Date | string
    mentor_company_membership?: MentorCompanyMembershipListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    website?: SortOrderInput | SortOrder
    tax_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    mentor_company_membership?: MentorCompanyMembershipOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    website?: StringNullableFilter<"Company"> | string | null
    tax_id?: StringNullableFilter<"Company"> | string | null
    created_at?: DateTimeFilter<"Company"> | Date | string
    updated_at?: DateTimeFilter<"Company"> | Date | string
    mentor_company_membership?: MentorCompanyMembershipListRelationFilter
  }, "id">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    website?: SortOrderInput | SortOrder
    tax_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    website?: StringNullableWithAggregatesFilter<"Company"> | string | null
    tax_id?: StringNullableWithAggregatesFilter<"Company"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Company"> | Date | string
  }

  export type MentorCompanyMembershipWhereInput = {
    AND?: MentorCompanyMembershipWhereInput | MentorCompanyMembershipWhereInput[]
    OR?: MentorCompanyMembershipWhereInput[]
    NOT?: MentorCompanyMembershipWhereInput | MentorCompanyMembershipWhereInput[]
    mentor_id?: UuidFilter<"MentorCompanyMembership"> | string
    company_id?: UuidFilter<"MentorCompanyMembership"> | string
    role_title?: StringNullableFilter<"MentorCompanyMembership"> | string | null
    work_email?: StringNullableFilter<"MentorCompanyMembership"> | string | null
    created_at?: DateTimeFilter<"MentorCompanyMembership"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type MentorCompanyMembershipOrderByWithRelationInput = {
    mentor_id?: SortOrder
    company_id?: SortOrder
    role_title?: SortOrderInput | SortOrder
    work_email?: SortOrderInput | SortOrder
    created_at?: SortOrder
    user?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type MentorCompanyMembershipWhereUniqueInput = Prisma.AtLeast<{
    mentor_id_company_id?: MentorCompanyMembershipMentor_idCompany_idCompoundUniqueInput
    AND?: MentorCompanyMembershipWhereInput | MentorCompanyMembershipWhereInput[]
    OR?: MentorCompanyMembershipWhereInput[]
    NOT?: MentorCompanyMembershipWhereInput | MentorCompanyMembershipWhereInput[]
    mentor_id?: UuidFilter<"MentorCompanyMembership"> | string
    company_id?: UuidFilter<"MentorCompanyMembership"> | string
    role_title?: StringNullableFilter<"MentorCompanyMembership"> | string | null
    work_email?: StringNullableFilter<"MentorCompanyMembership"> | string | null
    created_at?: DateTimeFilter<"MentorCompanyMembership"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "mentor_id_company_id">

  export type MentorCompanyMembershipOrderByWithAggregationInput = {
    mentor_id?: SortOrder
    company_id?: SortOrder
    role_title?: SortOrderInput | SortOrder
    work_email?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: MentorCompanyMembershipCountOrderByAggregateInput
    _max?: MentorCompanyMembershipMaxOrderByAggregateInput
    _min?: MentorCompanyMembershipMinOrderByAggregateInput
  }

  export type MentorCompanyMembershipScalarWhereWithAggregatesInput = {
    AND?: MentorCompanyMembershipScalarWhereWithAggregatesInput | MentorCompanyMembershipScalarWhereWithAggregatesInput[]
    OR?: MentorCompanyMembershipScalarWhereWithAggregatesInput[]
    NOT?: MentorCompanyMembershipScalarWhereWithAggregatesInput | MentorCompanyMembershipScalarWhereWithAggregatesInput[]
    mentor_id?: UuidWithAggregatesFilter<"MentorCompanyMembership"> | string
    company_id?: UuidWithAggregatesFilter<"MentorCompanyMembership"> | string
    role_title?: StringNullableWithAggregatesFilter<"MentorCompanyMembership"> | string | null
    work_email?: StringNullableWithAggregatesFilter<"MentorCompanyMembership"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"MentorCompanyMembership"> | Date | string
  }

  export type UserConsentWhereInput = {
    AND?: UserConsentWhereInput | UserConsentWhereInput[]
    OR?: UserConsentWhereInput[]
    NOT?: UserConsentWhereInput | UserConsentWhereInput[]
    user_id?: UuidFilter<"UserConsent"> | string
    kvkk_accepted_at?: DateTimeFilter<"UserConsent"> | Date | string
    kvkk_version?: StringNullableFilter<"UserConsent"> | string | null
    ip_address?: StringNullableFilter<"UserConsent"> | string | null
    marketing_opt_in?: BoolFilter<"UserConsent"> | boolean
    created_at?: DateTimeFilter<"UserConsent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserConsentOrderByWithRelationInput = {
    user_id?: SortOrder
    kvkk_accepted_at?: SortOrder
    kvkk_version?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    marketing_opt_in?: SortOrder
    created_at?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserConsentWhereUniqueInput = Prisma.AtLeast<{
    user_id?: string
    AND?: UserConsentWhereInput | UserConsentWhereInput[]
    OR?: UserConsentWhereInput[]
    NOT?: UserConsentWhereInput | UserConsentWhereInput[]
    kvkk_accepted_at?: DateTimeFilter<"UserConsent"> | Date | string
    kvkk_version?: StringNullableFilter<"UserConsent"> | string | null
    ip_address?: StringNullableFilter<"UserConsent"> | string | null
    marketing_opt_in?: BoolFilter<"UserConsent"> | boolean
    created_at?: DateTimeFilter<"UserConsent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "user_id">

  export type UserConsentOrderByWithAggregationInput = {
    user_id?: SortOrder
    kvkk_accepted_at?: SortOrder
    kvkk_version?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    marketing_opt_in?: SortOrder
    created_at?: SortOrder
    _count?: UserConsentCountOrderByAggregateInput
    _max?: UserConsentMaxOrderByAggregateInput
    _min?: UserConsentMinOrderByAggregateInput
  }

  export type UserConsentScalarWhereWithAggregatesInput = {
    AND?: UserConsentScalarWhereWithAggregatesInput | UserConsentScalarWhereWithAggregatesInput[]
    OR?: UserConsentScalarWhereWithAggregatesInput[]
    NOT?: UserConsentScalarWhereWithAggregatesInput | UserConsentScalarWhereWithAggregatesInput[]
    user_id?: UuidWithAggregatesFilter<"UserConsent"> | string
    kvkk_accepted_at?: DateTimeWithAggregatesFilter<"UserConsent"> | Date | string
    kvkk_version?: StringNullableWithAggregatesFilter<"UserConsent"> | string | null
    ip_address?: StringNullableWithAggregatesFilter<"UserConsent"> | string | null
    marketing_opt_in?: BoolWithAggregatesFilter<"UserConsent"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"UserConsent"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentee_profile?: MenteeCreateNestedOneWithoutUserInput
    mentor_profile?: MentorCreateNestedOneWithoutUserInput
    user_consent?: UserConsentCreateNestedOneWithoutUserInput
    mentee_languages?: MenteeLanguageCreateNestedManyWithoutUserInput
    mentee_interests?: MenteeInterestCreateNestedManyWithoutUserInput
    mentee_priorities?: MenteePriorityCreateNestedManyWithoutUserInput
    mentor_languages?: MentorLanguageCreateNestedManyWithoutUserInput
    mentor_categories?: MentorCategoryCreateNestedManyWithoutUserInput
    mentor_skills?: MentorSkillCreateNestedManyWithoutUserInput
    mentee_service_focus?: MenteeServiceFocusCreateNestedManyWithoutUserInput
    mentee_languages_ref?: MenteeLanguageRefCreateNestedManyWithoutUserInput
    mentee_disciplines_ref?: MenteeDisciplineRefCreateNestedManyWithoutUserInput
    mentee_preferences_ref?: MenteePreferenceRefCreateNestedManyWithoutUserInput
    mentor_company_membership?: MentorCompanyMembershipCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentee_profile?: MenteeUncheckedCreateNestedOneWithoutUserInput
    mentor_profile?: MentorUncheckedCreateNestedOneWithoutUserInput
    user_consent?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    mentee_languages?: MenteeLanguageUncheckedCreateNestedManyWithoutUserInput
    mentee_interests?: MenteeInterestUncheckedCreateNestedManyWithoutUserInput
    mentee_priorities?: MenteePriorityUncheckedCreateNestedManyWithoutUserInput
    mentor_languages?: MentorLanguageUncheckedCreateNestedManyWithoutUserInput
    mentor_categories?: MentorCategoryUncheckedCreateNestedManyWithoutUserInput
    mentor_skills?: MentorSkillUncheckedCreateNestedManyWithoutUserInput
    mentee_service_focus?: MenteeServiceFocusUncheckedCreateNestedManyWithoutUserInput
    mentee_languages_ref?: MenteeLanguageRefUncheckedCreateNestedManyWithoutUserInput
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedCreateNestedManyWithoutUserInput
    mentee_preferences_ref?: MenteePreferenceRefUncheckedCreateNestedManyWithoutUserInput
    mentor_company_membership?: MentorCompanyMembershipUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee_profile?: MenteeUpdateOneWithoutUserNestedInput
    mentor_profile?: MentorUpdateOneWithoutUserNestedInput
    user_consent?: UserConsentUpdateOneWithoutUserNestedInput
    mentee_languages?: MenteeLanguageUpdateManyWithoutUserNestedInput
    mentee_interests?: MenteeInterestUpdateManyWithoutUserNestedInput
    mentee_priorities?: MenteePriorityUpdateManyWithoutUserNestedInput
    mentor_languages?: MentorLanguageUpdateManyWithoutUserNestedInput
    mentor_categories?: MentorCategoryUpdateManyWithoutUserNestedInput
    mentor_skills?: MentorSkillUpdateManyWithoutUserNestedInput
    mentee_service_focus?: MenteeServiceFocusUpdateManyWithoutUserNestedInput
    mentee_languages_ref?: MenteeLanguageRefUpdateManyWithoutUserNestedInput
    mentee_disciplines_ref?: MenteeDisciplineRefUpdateManyWithoutUserNestedInput
    mentee_preferences_ref?: MenteePreferenceRefUpdateManyWithoutUserNestedInput
    mentor_company_membership?: MentorCompanyMembershipUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee_profile?: MenteeUncheckedUpdateOneWithoutUserNestedInput
    mentor_profile?: MentorUncheckedUpdateOneWithoutUserNestedInput
    user_consent?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    mentee_languages?: MenteeLanguageUncheckedUpdateManyWithoutUserNestedInput
    mentee_interests?: MenteeInterestUncheckedUpdateManyWithoutUserNestedInput
    mentee_priorities?: MenteePriorityUncheckedUpdateManyWithoutUserNestedInput
    mentor_languages?: MentorLanguageUncheckedUpdateManyWithoutUserNestedInput
    mentor_categories?: MentorCategoryUncheckedUpdateManyWithoutUserNestedInput
    mentor_skills?: MentorSkillUncheckedUpdateManyWithoutUserNestedInput
    mentee_service_focus?: MenteeServiceFocusUncheckedUpdateManyWithoutUserNestedInput
    mentee_languages_ref?: MenteeLanguageRefUncheckedUpdateManyWithoutUserNestedInput
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedUpdateManyWithoutUserNestedInput
    mentee_preferences_ref?: MenteePreferenceRefUncheckedUpdateManyWithoutUserNestedInput
    mentor_company_membership?: MentorCompanyMembershipUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenteeCreateInput = {
    short_goal: string
    target_track: string
    budget: string
    time_preference: string
    city?: string | null
    country?: string
    goal_type?: string | null
    service_focus?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutMentee_profileInput
  }

  export type MenteeUncheckedCreateInput = {
    user_id: string
    short_goal: string
    target_track: string
    budget: string
    time_preference: string
    city?: string | null
    country?: string
    goal_type?: string | null
    service_focus?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MenteeUpdateInput = {
    short_goal?: StringFieldUpdateOperationsInput | string
    target_track?: StringFieldUpdateOperationsInput | string
    budget?: StringFieldUpdateOperationsInput | string
    time_preference?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    goal_type?: NullableStringFieldUpdateOperationsInput | string | null
    service_focus?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMentee_profileNestedInput
  }

  export type MenteeUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    short_goal?: StringFieldUpdateOperationsInput | string
    target_track?: StringFieldUpdateOperationsInput | string
    budget?: StringFieldUpdateOperationsInput | string
    time_preference?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    goal_type?: NullableStringFieldUpdateOperationsInput | string | null
    service_focus?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenteeCreateManyInput = {
    user_id: string
    short_goal: string
    target_track: string
    budget: string
    time_preference: string
    city?: string | null
    country?: string
    goal_type?: string | null
    service_focus?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MenteeUpdateManyMutationInput = {
    short_goal?: StringFieldUpdateOperationsInput | string
    target_track?: StringFieldUpdateOperationsInput | string
    budget?: StringFieldUpdateOperationsInput | string
    time_preference?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    goal_type?: NullableStringFieldUpdateOperationsInput | string | null
    service_focus?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenteeUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    short_goal?: StringFieldUpdateOperationsInput | string
    target_track?: StringFieldUpdateOperationsInput | string
    budget?: StringFieldUpdateOperationsInput | string
    time_preference?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    goal_type?: NullableStringFieldUpdateOperationsInput | string | null
    service_focus?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentorCreateInput = {
    mentor_type: $Enums.MentorType
    display_name: string
    title: string
    years_experience?: number
    hourly_rate_cents: number
    meeting_preference: string
    bio_short: string
    bio_long: string
    city?: string | null
    country?: string
    rating_avg?: Decimal | DecimalJsLike | number | string
    total_reviews?: number
    status?: $Enums.MentorStatus
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutMentor_profileInput
  }

  export type MentorUncheckedCreateInput = {
    user_id: string
    mentor_type: $Enums.MentorType
    display_name: string
    title: string
    years_experience?: number
    hourly_rate_cents: number
    meeting_preference: string
    bio_short: string
    bio_long: string
    city?: string | null
    country?: string
    rating_avg?: Decimal | DecimalJsLike | number | string
    total_reviews?: number
    status?: $Enums.MentorStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MentorUpdateInput = {
    mentor_type?: EnumMentorTypeFieldUpdateOperationsInput | $Enums.MentorType
    display_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    years_experience?: IntFieldUpdateOperationsInput | number
    hourly_rate_cents?: IntFieldUpdateOperationsInput | number
    meeting_preference?: StringFieldUpdateOperationsInput | string
    bio_short?: StringFieldUpdateOperationsInput | string
    bio_long?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_reviews?: IntFieldUpdateOperationsInput | number
    status?: EnumMentorStatusFieldUpdateOperationsInput | $Enums.MentorStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMentor_profileNestedInput
  }

  export type MentorUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    mentor_type?: EnumMentorTypeFieldUpdateOperationsInput | $Enums.MentorType
    display_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    years_experience?: IntFieldUpdateOperationsInput | number
    hourly_rate_cents?: IntFieldUpdateOperationsInput | number
    meeting_preference?: StringFieldUpdateOperationsInput | string
    bio_short?: StringFieldUpdateOperationsInput | string
    bio_long?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_reviews?: IntFieldUpdateOperationsInput | number
    status?: EnumMentorStatusFieldUpdateOperationsInput | $Enums.MentorStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentorCreateManyInput = {
    user_id: string
    mentor_type: $Enums.MentorType
    display_name: string
    title: string
    years_experience?: number
    hourly_rate_cents: number
    meeting_preference: string
    bio_short: string
    bio_long: string
    city?: string | null
    country?: string
    rating_avg?: Decimal | DecimalJsLike | number | string
    total_reviews?: number
    status?: $Enums.MentorStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MentorUpdateManyMutationInput = {
    mentor_type?: EnumMentorTypeFieldUpdateOperationsInput | $Enums.MentorType
    display_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    years_experience?: IntFieldUpdateOperationsInput | number
    hourly_rate_cents?: IntFieldUpdateOperationsInput | number
    meeting_preference?: StringFieldUpdateOperationsInput | string
    bio_short?: StringFieldUpdateOperationsInput | string
    bio_long?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_reviews?: IntFieldUpdateOperationsInput | number
    status?: EnumMentorStatusFieldUpdateOperationsInput | $Enums.MentorStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentorUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    mentor_type?: EnumMentorTypeFieldUpdateOperationsInput | $Enums.MentorType
    display_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    years_experience?: IntFieldUpdateOperationsInput | number
    hourly_rate_cents?: IntFieldUpdateOperationsInput | number
    meeting_preference?: StringFieldUpdateOperationsInput | string
    bio_short?: StringFieldUpdateOperationsInput | string
    bio_long?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_reviews?: IntFieldUpdateOperationsInput | number
    status?: EnumMentorStatusFieldUpdateOperationsInput | $Enums.MentorStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceFocusRefCreateInput = {
    id: string
    label: string
    active?: boolean
    sort_order?: number
    mentee_service_focus?: MenteeServiceFocusCreateNestedManyWithoutService_focusInput
  }

  export type ServiceFocusRefUncheckedCreateInput = {
    id: string
    label: string
    active?: boolean
    sort_order?: number
    mentee_service_focus?: MenteeServiceFocusUncheckedCreateNestedManyWithoutService_focusInput
  }

  export type ServiceFocusRefUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    mentee_service_focus?: MenteeServiceFocusUpdateManyWithoutService_focusNestedInput
  }

  export type ServiceFocusRefUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    mentee_service_focus?: MenteeServiceFocusUncheckedUpdateManyWithoutService_focusNestedInput
  }

  export type ServiceFocusRefCreateManyInput = {
    id: string
    label: string
    active?: boolean
    sort_order?: number
  }

  export type ServiceFocusRefUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type ServiceFocusRefUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type LanguageRefCreateInput = {
    id: string
    label: string
    active?: boolean
    sort_order?: number
    mentee_languages_ref?: MenteeLanguageRefCreateNestedManyWithoutLanguageInput
  }

  export type LanguageRefUncheckedCreateInput = {
    id: string
    label: string
    active?: boolean
    sort_order?: number
    mentee_languages_ref?: MenteeLanguageRefUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageRefUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    mentee_languages_ref?: MenteeLanguageRefUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageRefUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    mentee_languages_ref?: MenteeLanguageRefUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageRefCreateManyInput = {
    id: string
    label: string
    active?: boolean
    sort_order?: number
  }

  export type LanguageRefUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type LanguageRefUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type DisciplineRefCreateInput = {
    id: string
    label: string
    active?: boolean
    sort_order?: number
    mentee_disciplines_ref?: MenteeDisciplineRefCreateNestedManyWithoutDisciplineInput
  }

  export type DisciplineRefUncheckedCreateInput = {
    id: string
    label: string
    active?: boolean
    sort_order?: number
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedCreateNestedManyWithoutDisciplineInput
  }

  export type DisciplineRefUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    mentee_disciplines_ref?: MenteeDisciplineRefUpdateManyWithoutDisciplineNestedInput
  }

  export type DisciplineRefUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedUpdateManyWithoutDisciplineNestedInput
  }

  export type DisciplineRefCreateManyInput = {
    id: string
    label: string
    active?: boolean
    sort_order?: number
  }

  export type DisciplineRefUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type DisciplineRefUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type PreferenceRefCreateInput = {
    id: string
    label: string
    active?: boolean
    sort_order?: number
    mentee_preferences_ref?: MenteePreferenceRefCreateNestedManyWithoutPreferenceInput
  }

  export type PreferenceRefUncheckedCreateInput = {
    id: string
    label: string
    active?: boolean
    sort_order?: number
    mentee_preferences_ref?: MenteePreferenceRefUncheckedCreateNestedManyWithoutPreferenceInput
  }

  export type PreferenceRefUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    mentee_preferences_ref?: MenteePreferenceRefUpdateManyWithoutPreferenceNestedInput
  }

  export type PreferenceRefUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    mentee_preferences_ref?: MenteePreferenceRefUncheckedUpdateManyWithoutPreferenceNestedInput
  }

  export type PreferenceRefCreateManyInput = {
    id: string
    label: string
    active?: boolean
    sort_order?: number
  }

  export type PreferenceRefUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type PreferenceRefUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type MenteeLanguageCreateInput = {
    lang_code: string
    user: UserCreateNestedOneWithoutMentee_languagesInput
  }

  export type MenteeLanguageUncheckedCreateInput = {
    user_id: string
    lang_code: string
  }

  export type MenteeLanguageUpdateInput = {
    lang_code?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutMentee_languagesNestedInput
  }

  export type MenteeLanguageUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    lang_code?: StringFieldUpdateOperationsInput | string
  }

  export type MenteeLanguageCreateManyInput = {
    user_id: string
    lang_code: string
  }

  export type MenteeLanguageUpdateManyMutationInput = {
    lang_code?: StringFieldUpdateOperationsInput | string
  }

  export type MenteeLanguageUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    lang_code?: StringFieldUpdateOperationsInput | string
  }

  export type MenteeInterestCreateInput = {
    interest: string
    created_at?: Date | string
    user: UserCreateNestedOneWithoutMentee_interestsInput
  }

  export type MenteeInterestUncheckedCreateInput = {
    user_id: string
    interest: string
    created_at?: Date | string
  }

  export type MenteeInterestUpdateInput = {
    interest?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMentee_interestsNestedInput
  }

  export type MenteeInterestUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    interest?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenteeInterestCreateManyInput = {
    user_id: string
    interest: string
    created_at?: Date | string
  }

  export type MenteeInterestUpdateManyMutationInput = {
    interest?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenteeInterestUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    interest?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenteePriorityCreateInput = {
    priority: string
    created_at?: Date | string
    user: UserCreateNestedOneWithoutMentee_prioritiesInput
  }

  export type MenteePriorityUncheckedCreateInput = {
    user_id: string
    priority: string
    created_at?: Date | string
  }

  export type MenteePriorityUpdateInput = {
    priority?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMentee_prioritiesNestedInput
  }

  export type MenteePriorityUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenteePriorityCreateManyInput = {
    user_id: string
    priority: string
    created_at?: Date | string
  }

  export type MenteePriorityUpdateManyMutationInput = {
    priority?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenteePriorityUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentorLanguageCreateInput = {
    lang_code: string
    user: UserCreateNestedOneWithoutMentor_languagesInput
  }

  export type MentorLanguageUncheckedCreateInput = {
    user_id: string
    lang_code: string
  }

  export type MentorLanguageUpdateInput = {
    lang_code?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutMentor_languagesNestedInput
  }

  export type MentorLanguageUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    lang_code?: StringFieldUpdateOperationsInput | string
  }

  export type MentorLanguageCreateManyInput = {
    user_id: string
    lang_code: string
  }

  export type MentorLanguageUpdateManyMutationInput = {
    lang_code?: StringFieldUpdateOperationsInput | string
  }

  export type MentorLanguageUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    lang_code?: StringFieldUpdateOperationsInput | string
  }

  export type MentorCategoryCreateInput = {
    category: string
    user: UserCreateNestedOneWithoutMentor_categoriesInput
  }

  export type MentorCategoryUncheckedCreateInput = {
    user_id: string
    category: string
  }

  export type MentorCategoryUpdateInput = {
    category?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutMentor_categoriesNestedInput
  }

  export type MentorCategoryUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
  }

  export type MentorCategoryCreateManyInput = {
    user_id: string
    category: string
  }

  export type MentorCategoryUpdateManyMutationInput = {
    category?: StringFieldUpdateOperationsInput | string
  }

  export type MentorCategoryUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
  }

  export type MentorSkillCreateInput = {
    skill: string
    user: UserCreateNestedOneWithoutMentor_skillsInput
  }

  export type MentorSkillUncheckedCreateInput = {
    user_id: string
    skill: string
  }

  export type MentorSkillUpdateInput = {
    skill?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutMentor_skillsNestedInput
  }

  export type MentorSkillUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
  }

  export type MentorSkillCreateManyInput = {
    user_id: string
    skill: string
  }

  export type MentorSkillUpdateManyMutationInput = {
    skill?: StringFieldUpdateOperationsInput | string
  }

  export type MentorSkillUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
  }

  export type MenteeServiceFocusCreateInput = {
    user: UserCreateNestedOneWithoutMentee_service_focusInput
    service_focus: ServiceFocusRefCreateNestedOneWithoutMentee_service_focusInput
  }

  export type MenteeServiceFocusUncheckedCreateInput = {
    user_id: string
    service_focus_id: string
  }

  export type MenteeServiceFocusUpdateInput = {
    user?: UserUpdateOneRequiredWithoutMentee_service_focusNestedInput
    service_focus?: ServiceFocusRefUpdateOneRequiredWithoutMentee_service_focusNestedInput
  }

  export type MenteeServiceFocusUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    service_focus_id?: StringFieldUpdateOperationsInput | string
  }

  export type MenteeServiceFocusCreateManyInput = {
    user_id: string
    service_focus_id: string
  }

  export type MenteeServiceFocusUpdateManyMutationInput = {

  }

  export type MenteeServiceFocusUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    service_focus_id?: StringFieldUpdateOperationsInput | string
  }

  export type MenteeLanguageRefCreateInput = {
    user: UserCreateNestedOneWithoutMentee_languages_refInput
    language: LanguageRefCreateNestedOneWithoutMentee_languages_refInput
  }

  export type MenteeLanguageRefUncheckedCreateInput = {
    user_id: string
    language_id: string
  }

  export type MenteeLanguageRefUpdateInput = {
    user?: UserUpdateOneRequiredWithoutMentee_languages_refNestedInput
    language?: LanguageRefUpdateOneRequiredWithoutMentee_languages_refNestedInput
  }

  export type MenteeLanguageRefUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    language_id?: StringFieldUpdateOperationsInput | string
  }

  export type MenteeLanguageRefCreateManyInput = {
    user_id: string
    language_id: string
  }

  export type MenteeLanguageRefUpdateManyMutationInput = {

  }

  export type MenteeLanguageRefUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    language_id?: StringFieldUpdateOperationsInput | string
  }

  export type MenteeDisciplineRefCreateInput = {
    user: UserCreateNestedOneWithoutMentee_disciplines_refInput
    discipline: DisciplineRefCreateNestedOneWithoutMentee_disciplines_refInput
  }

  export type MenteeDisciplineRefUncheckedCreateInput = {
    user_id: string
    discipline_id: string
  }

  export type MenteeDisciplineRefUpdateInput = {
    user?: UserUpdateOneRequiredWithoutMentee_disciplines_refNestedInput
    discipline?: DisciplineRefUpdateOneRequiredWithoutMentee_disciplines_refNestedInput
  }

  export type MenteeDisciplineRefUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    discipline_id?: StringFieldUpdateOperationsInput | string
  }

  export type MenteeDisciplineRefCreateManyInput = {
    user_id: string
    discipline_id: string
  }

  export type MenteeDisciplineRefUpdateManyMutationInput = {

  }

  export type MenteeDisciplineRefUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    discipline_id?: StringFieldUpdateOperationsInput | string
  }

  export type MenteePreferenceRefCreateInput = {
    user: UserCreateNestedOneWithoutMentee_preferences_refInput
    preference: PreferenceRefCreateNestedOneWithoutMentee_preferences_refInput
  }

  export type MenteePreferenceRefUncheckedCreateInput = {
    user_id: string
    preference_id: string
  }

  export type MenteePreferenceRefUpdateInput = {
    user?: UserUpdateOneRequiredWithoutMentee_preferences_refNestedInput
    preference?: PreferenceRefUpdateOneRequiredWithoutMentee_preferences_refNestedInput
  }

  export type MenteePreferenceRefUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    preference_id?: StringFieldUpdateOperationsInput | string
  }

  export type MenteePreferenceRefCreateManyInput = {
    user_id: string
    preference_id: string
  }

  export type MenteePreferenceRefUpdateManyMutationInput = {

  }

  export type MenteePreferenceRefUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    preference_id?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyCreateInput = {
    id?: string
    name: string
    website?: string | null
    tax_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    mentor_company_membership?: MentorCompanyMembershipCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    name: string
    website?: string | null
    tax_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    mentor_company_membership?: MentorCompanyMembershipUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentor_company_membership?: MentorCompanyMembershipUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentor_company_membership?: MentorCompanyMembershipUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    name: string
    website?: string | null
    tax_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentorCompanyMembershipCreateInput = {
    role_title?: string | null
    work_email?: string | null
    created_at?: Date | string
    user: UserCreateNestedOneWithoutMentor_company_membershipInput
    company: CompanyCreateNestedOneWithoutMentor_company_membershipInput
  }

  export type MentorCompanyMembershipUncheckedCreateInput = {
    mentor_id: string
    company_id: string
    role_title?: string | null
    work_email?: string | null
    created_at?: Date | string
  }

  export type MentorCompanyMembershipUpdateInput = {
    role_title?: NullableStringFieldUpdateOperationsInput | string | null
    work_email?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMentor_company_membershipNestedInput
    company?: CompanyUpdateOneRequiredWithoutMentor_company_membershipNestedInput
  }

  export type MentorCompanyMembershipUncheckedUpdateInput = {
    mentor_id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    role_title?: NullableStringFieldUpdateOperationsInput | string | null
    work_email?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentorCompanyMembershipCreateManyInput = {
    mentor_id: string
    company_id: string
    role_title?: string | null
    work_email?: string | null
    created_at?: Date | string
  }

  export type MentorCompanyMembershipUpdateManyMutationInput = {
    role_title?: NullableStringFieldUpdateOperationsInput | string | null
    work_email?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentorCompanyMembershipUncheckedUpdateManyInput = {
    mentor_id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    role_title?: NullableStringFieldUpdateOperationsInput | string | null
    work_email?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConsentCreateInput = {
    kvkk_accepted_at: Date | string
    kvkk_version?: string | null
    ip_address?: string | null
    marketing_opt_in?: boolean
    created_at?: Date | string
    user: UserCreateNestedOneWithoutUser_consentInput
  }

  export type UserConsentUncheckedCreateInput = {
    user_id: string
    kvkk_accepted_at: Date | string
    kvkk_version?: string | null
    ip_address?: string | null
    marketing_opt_in?: boolean
    created_at?: Date | string
  }

  export type UserConsentUpdateInput = {
    kvkk_accepted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kvkk_version?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    marketing_opt_in?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUser_consentNestedInput
  }

  export type UserConsentUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    kvkk_accepted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kvkk_version?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    marketing_opt_in?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConsentCreateManyInput = {
    user_id: string
    kvkk_accepted_at: Date | string
    kvkk_version?: string | null
    ip_address?: string | null
    marketing_opt_in?: boolean
    created_at?: Date | string
  }

  export type UserConsentUpdateManyMutationInput = {
    kvkk_accepted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kvkk_version?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    marketing_opt_in?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConsentUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    kvkk_accepted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kvkk_version?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    marketing_opt_in?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type MenteeNullableScalarRelationFilter = {
    is?: MenteeWhereInput | null
    isNot?: MenteeWhereInput | null
  }

  export type MentorNullableScalarRelationFilter = {
    is?: MentorWhereInput | null
    isNot?: MentorWhereInput | null
  }

  export type UserConsentNullableScalarRelationFilter = {
    is?: UserConsentWhereInput | null
    isNot?: UserConsentWhereInput | null
  }

  export type MenteeLanguageListRelationFilter = {
    every?: MenteeLanguageWhereInput
    some?: MenteeLanguageWhereInput
    none?: MenteeLanguageWhereInput
  }

  export type MenteeInterestListRelationFilter = {
    every?: MenteeInterestWhereInput
    some?: MenteeInterestWhereInput
    none?: MenteeInterestWhereInput
  }

  export type MenteePriorityListRelationFilter = {
    every?: MenteePriorityWhereInput
    some?: MenteePriorityWhereInput
    none?: MenteePriorityWhereInput
  }

  export type MentorLanguageListRelationFilter = {
    every?: MentorLanguageWhereInput
    some?: MentorLanguageWhereInput
    none?: MentorLanguageWhereInput
  }

  export type MentorCategoryListRelationFilter = {
    every?: MentorCategoryWhereInput
    some?: MentorCategoryWhereInput
    none?: MentorCategoryWhereInput
  }

  export type MentorSkillListRelationFilter = {
    every?: MentorSkillWhereInput
    some?: MentorSkillWhereInput
    none?: MentorSkillWhereInput
  }

  export type MenteeServiceFocusListRelationFilter = {
    every?: MenteeServiceFocusWhereInput
    some?: MenteeServiceFocusWhereInput
    none?: MenteeServiceFocusWhereInput
  }

  export type MenteeLanguageRefListRelationFilter = {
    every?: MenteeLanguageRefWhereInput
    some?: MenteeLanguageRefWhereInput
    none?: MenteeLanguageRefWhereInput
  }

  export type MenteeDisciplineRefListRelationFilter = {
    every?: MenteeDisciplineRefWhereInput
    some?: MenteeDisciplineRefWhereInput
    none?: MenteeDisciplineRefWhereInput
  }

  export type MenteePreferenceRefListRelationFilter = {
    every?: MenteePreferenceRefWhereInput
    some?: MenteePreferenceRefWhereInput
    none?: MenteePreferenceRefWhereInput
  }

  export type MentorCompanyMembershipListRelationFilter = {
    every?: MentorCompanyMembershipWhereInput
    some?: MentorCompanyMembershipWhereInput
    none?: MentorCompanyMembershipWhereInput
  }

  export type MenteeLanguageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MenteeInterestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MenteePriorityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MentorLanguageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MentorCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MentorSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MenteeServiceFocusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MenteeLanguageRefOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MenteeDisciplineRefOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MenteePreferenceRefOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MentorCompanyMembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    full_name?: SortOrder
    role?: SortOrder
    password_hash?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    full_name?: SortOrder
    role?: SortOrder
    password_hash?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    full_name?: SortOrder
    role?: SortOrder
    password_hash?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MenteeCountOrderByAggregateInput = {
    user_id?: SortOrder
    short_goal?: SortOrder
    target_track?: SortOrder
    budget?: SortOrder
    time_preference?: SortOrder
    city?: SortOrder
    country?: SortOrder
    goal_type?: SortOrder
    service_focus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MenteeMaxOrderByAggregateInput = {
    user_id?: SortOrder
    short_goal?: SortOrder
    target_track?: SortOrder
    budget?: SortOrder
    time_preference?: SortOrder
    city?: SortOrder
    country?: SortOrder
    goal_type?: SortOrder
    service_focus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MenteeMinOrderByAggregateInput = {
    user_id?: SortOrder
    short_goal?: SortOrder
    target_track?: SortOrder
    budget?: SortOrder
    time_preference?: SortOrder
    city?: SortOrder
    country?: SortOrder
    goal_type?: SortOrder
    service_focus?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumMentorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MentorType | EnumMentorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MentorType[] | ListEnumMentorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MentorType[] | ListEnumMentorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMentorTypeFilter<$PrismaModel> | $Enums.MentorType
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumMentorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MentorStatus | EnumMentorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MentorStatus[] | ListEnumMentorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MentorStatus[] | ListEnumMentorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMentorStatusFilter<$PrismaModel> | $Enums.MentorStatus
  }

  export type MentorCountOrderByAggregateInput = {
    user_id?: SortOrder
    mentor_type?: SortOrder
    display_name?: SortOrder
    title?: SortOrder
    years_experience?: SortOrder
    hourly_rate_cents?: SortOrder
    meeting_preference?: SortOrder
    bio_short?: SortOrder
    bio_long?: SortOrder
    city?: SortOrder
    country?: SortOrder
    rating_avg?: SortOrder
    total_reviews?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MentorAvgOrderByAggregateInput = {
    years_experience?: SortOrder
    hourly_rate_cents?: SortOrder
    rating_avg?: SortOrder
    total_reviews?: SortOrder
  }

  export type MentorMaxOrderByAggregateInput = {
    user_id?: SortOrder
    mentor_type?: SortOrder
    display_name?: SortOrder
    title?: SortOrder
    years_experience?: SortOrder
    hourly_rate_cents?: SortOrder
    meeting_preference?: SortOrder
    bio_short?: SortOrder
    bio_long?: SortOrder
    city?: SortOrder
    country?: SortOrder
    rating_avg?: SortOrder
    total_reviews?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MentorMinOrderByAggregateInput = {
    user_id?: SortOrder
    mentor_type?: SortOrder
    display_name?: SortOrder
    title?: SortOrder
    years_experience?: SortOrder
    hourly_rate_cents?: SortOrder
    meeting_preference?: SortOrder
    bio_short?: SortOrder
    bio_long?: SortOrder
    city?: SortOrder
    country?: SortOrder
    rating_avg?: SortOrder
    total_reviews?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MentorSumOrderByAggregateInput = {
    years_experience?: SortOrder
    hourly_rate_cents?: SortOrder
    rating_avg?: SortOrder
    total_reviews?: SortOrder
  }

  export type EnumMentorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MentorType | EnumMentorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MentorType[] | ListEnumMentorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MentorType[] | ListEnumMentorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMentorTypeWithAggregatesFilter<$PrismaModel> | $Enums.MentorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMentorTypeFilter<$PrismaModel>
    _max?: NestedEnumMentorTypeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumMentorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MentorStatus | EnumMentorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MentorStatus[] | ListEnumMentorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MentorStatus[] | ListEnumMentorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMentorStatusWithAggregatesFilter<$PrismaModel> | $Enums.MentorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMentorStatusFilter<$PrismaModel>
    _max?: NestedEnumMentorStatusFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ServiceFocusRefCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    active?: SortOrder
    sort_order?: SortOrder
  }

  export type ServiceFocusRefAvgOrderByAggregateInput = {
    sort_order?: SortOrder
  }

  export type ServiceFocusRefMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    active?: SortOrder
    sort_order?: SortOrder
  }

  export type ServiceFocusRefMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    active?: SortOrder
    sort_order?: SortOrder
  }

  export type ServiceFocusRefSumOrderByAggregateInput = {
    sort_order?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type LanguageRefCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    active?: SortOrder
    sort_order?: SortOrder
  }

  export type LanguageRefAvgOrderByAggregateInput = {
    sort_order?: SortOrder
  }

  export type LanguageRefMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    active?: SortOrder
    sort_order?: SortOrder
  }

  export type LanguageRefMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    active?: SortOrder
    sort_order?: SortOrder
  }

  export type LanguageRefSumOrderByAggregateInput = {
    sort_order?: SortOrder
  }

  export type DisciplineRefCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    active?: SortOrder
    sort_order?: SortOrder
  }

  export type DisciplineRefAvgOrderByAggregateInput = {
    sort_order?: SortOrder
  }

  export type DisciplineRefMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    active?: SortOrder
    sort_order?: SortOrder
  }

  export type DisciplineRefMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    active?: SortOrder
    sort_order?: SortOrder
  }

  export type DisciplineRefSumOrderByAggregateInput = {
    sort_order?: SortOrder
  }

  export type PreferenceRefCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    active?: SortOrder
    sort_order?: SortOrder
  }

  export type PreferenceRefAvgOrderByAggregateInput = {
    sort_order?: SortOrder
  }

  export type PreferenceRefMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    active?: SortOrder
    sort_order?: SortOrder
  }

  export type PreferenceRefMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    active?: SortOrder
    sort_order?: SortOrder
  }

  export type PreferenceRefSumOrderByAggregateInput = {
    sort_order?: SortOrder
  }

  export type MenteeLanguageUser_idLang_codeCompoundUniqueInput = {
    user_id: string
    lang_code: string
  }

  export type MenteeLanguageCountOrderByAggregateInput = {
    user_id?: SortOrder
    lang_code?: SortOrder
  }

  export type MenteeLanguageMaxOrderByAggregateInput = {
    user_id?: SortOrder
    lang_code?: SortOrder
  }

  export type MenteeLanguageMinOrderByAggregateInput = {
    user_id?: SortOrder
    lang_code?: SortOrder
  }

  export type MenteeInterestUser_idInterestCompoundUniqueInput = {
    user_id: string
    interest: string
  }

  export type MenteeInterestCountOrderByAggregateInput = {
    user_id?: SortOrder
    interest?: SortOrder
    created_at?: SortOrder
  }

  export type MenteeInterestMaxOrderByAggregateInput = {
    user_id?: SortOrder
    interest?: SortOrder
    created_at?: SortOrder
  }

  export type MenteeInterestMinOrderByAggregateInput = {
    user_id?: SortOrder
    interest?: SortOrder
    created_at?: SortOrder
  }

  export type MenteePriorityUser_idPriorityCompoundUniqueInput = {
    user_id: string
    priority: string
  }

  export type MenteePriorityCountOrderByAggregateInput = {
    user_id?: SortOrder
    priority?: SortOrder
    created_at?: SortOrder
  }

  export type MenteePriorityMaxOrderByAggregateInput = {
    user_id?: SortOrder
    priority?: SortOrder
    created_at?: SortOrder
  }

  export type MenteePriorityMinOrderByAggregateInput = {
    user_id?: SortOrder
    priority?: SortOrder
    created_at?: SortOrder
  }

  export type MentorLanguageUser_idLang_codeCompoundUniqueInput = {
    user_id: string
    lang_code: string
  }

  export type MentorLanguageCountOrderByAggregateInput = {
    user_id?: SortOrder
    lang_code?: SortOrder
  }

  export type MentorLanguageMaxOrderByAggregateInput = {
    user_id?: SortOrder
    lang_code?: SortOrder
  }

  export type MentorLanguageMinOrderByAggregateInput = {
    user_id?: SortOrder
    lang_code?: SortOrder
  }

  export type MentorCategoryUser_idCategoryCompoundUniqueInput = {
    user_id: string
    category: string
  }

  export type MentorCategoryCountOrderByAggregateInput = {
    user_id?: SortOrder
    category?: SortOrder
  }

  export type MentorCategoryMaxOrderByAggregateInput = {
    user_id?: SortOrder
    category?: SortOrder
  }

  export type MentorCategoryMinOrderByAggregateInput = {
    user_id?: SortOrder
    category?: SortOrder
  }

  export type MentorSkillUser_idSkillCompoundUniqueInput = {
    user_id: string
    skill: string
  }

  export type MentorSkillCountOrderByAggregateInput = {
    user_id?: SortOrder
    skill?: SortOrder
  }

  export type MentorSkillMaxOrderByAggregateInput = {
    user_id?: SortOrder
    skill?: SortOrder
  }

  export type MentorSkillMinOrderByAggregateInput = {
    user_id?: SortOrder
    skill?: SortOrder
  }

  export type ServiceFocusRefScalarRelationFilter = {
    is?: ServiceFocusRefWhereInput
    isNot?: ServiceFocusRefWhereInput
  }

  export type MenteeServiceFocusUser_idService_focus_idCompoundUniqueInput = {
    user_id: string
    service_focus_id: string
  }

  export type MenteeServiceFocusCountOrderByAggregateInput = {
    user_id?: SortOrder
    service_focus_id?: SortOrder
  }

  export type MenteeServiceFocusMaxOrderByAggregateInput = {
    user_id?: SortOrder
    service_focus_id?: SortOrder
  }

  export type MenteeServiceFocusMinOrderByAggregateInput = {
    user_id?: SortOrder
    service_focus_id?: SortOrder
  }

  export type LanguageRefScalarRelationFilter = {
    is?: LanguageRefWhereInput
    isNot?: LanguageRefWhereInput
  }

  export type MenteeLanguageRefUser_idLanguage_idCompoundUniqueInput = {
    user_id: string
    language_id: string
  }

  export type MenteeLanguageRefCountOrderByAggregateInput = {
    user_id?: SortOrder
    language_id?: SortOrder
  }

  export type MenteeLanguageRefMaxOrderByAggregateInput = {
    user_id?: SortOrder
    language_id?: SortOrder
  }

  export type MenteeLanguageRefMinOrderByAggregateInput = {
    user_id?: SortOrder
    language_id?: SortOrder
  }

  export type DisciplineRefScalarRelationFilter = {
    is?: DisciplineRefWhereInput
    isNot?: DisciplineRefWhereInput
  }

  export type MenteeDisciplineRefUser_idDiscipline_idCompoundUniqueInput = {
    user_id: string
    discipline_id: string
  }

  export type MenteeDisciplineRefCountOrderByAggregateInput = {
    user_id?: SortOrder
    discipline_id?: SortOrder
  }

  export type MenteeDisciplineRefMaxOrderByAggregateInput = {
    user_id?: SortOrder
    discipline_id?: SortOrder
  }

  export type MenteeDisciplineRefMinOrderByAggregateInput = {
    user_id?: SortOrder
    discipline_id?: SortOrder
  }

  export type PreferenceRefScalarRelationFilter = {
    is?: PreferenceRefWhereInput
    isNot?: PreferenceRefWhereInput
  }

  export type MenteePreferenceRefUser_idPreference_idCompoundUniqueInput = {
    user_id: string
    preference_id: string
  }

  export type MenteePreferenceRefCountOrderByAggregateInput = {
    user_id?: SortOrder
    preference_id?: SortOrder
  }

  export type MenteePreferenceRefMaxOrderByAggregateInput = {
    user_id?: SortOrder
    preference_id?: SortOrder
  }

  export type MenteePreferenceRefMinOrderByAggregateInput = {
    user_id?: SortOrder
    preference_id?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    website?: SortOrder
    tax_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    website?: SortOrder
    tax_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    website?: SortOrder
    tax_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CompanyScalarRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type MentorCompanyMembershipMentor_idCompany_idCompoundUniqueInput = {
    mentor_id: string
    company_id: string
  }

  export type MentorCompanyMembershipCountOrderByAggregateInput = {
    mentor_id?: SortOrder
    company_id?: SortOrder
    role_title?: SortOrder
    work_email?: SortOrder
    created_at?: SortOrder
  }

  export type MentorCompanyMembershipMaxOrderByAggregateInput = {
    mentor_id?: SortOrder
    company_id?: SortOrder
    role_title?: SortOrder
    work_email?: SortOrder
    created_at?: SortOrder
  }

  export type MentorCompanyMembershipMinOrderByAggregateInput = {
    mentor_id?: SortOrder
    company_id?: SortOrder
    role_title?: SortOrder
    work_email?: SortOrder
    created_at?: SortOrder
  }

  export type UserConsentCountOrderByAggregateInput = {
    user_id?: SortOrder
    kvkk_accepted_at?: SortOrder
    kvkk_version?: SortOrder
    ip_address?: SortOrder
    marketing_opt_in?: SortOrder
    created_at?: SortOrder
  }

  export type UserConsentMaxOrderByAggregateInput = {
    user_id?: SortOrder
    kvkk_accepted_at?: SortOrder
    kvkk_version?: SortOrder
    ip_address?: SortOrder
    marketing_opt_in?: SortOrder
    created_at?: SortOrder
  }

  export type UserConsentMinOrderByAggregateInput = {
    user_id?: SortOrder
    kvkk_accepted_at?: SortOrder
    kvkk_version?: SortOrder
    ip_address?: SortOrder
    marketing_opt_in?: SortOrder
    created_at?: SortOrder
  }

  export type MenteeCreateNestedOneWithoutUserInput = {
    create?: XOR<MenteeCreateWithoutUserInput, MenteeUncheckedCreateWithoutUserInput>
    connectOrCreate?: MenteeCreateOrConnectWithoutUserInput
    connect?: MenteeWhereUniqueInput
  }

  export type MentorCreateNestedOneWithoutUserInput = {
    create?: XOR<MentorCreateWithoutUserInput, MentorUncheckedCreateWithoutUserInput>
    connectOrCreate?: MentorCreateOrConnectWithoutUserInput
    connect?: MentorWhereUniqueInput
  }

  export type UserConsentCreateNestedOneWithoutUserInput = {
    create?: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserConsentCreateOrConnectWithoutUserInput
    connect?: UserConsentWhereUniqueInput
  }

  export type MenteeLanguageCreateNestedManyWithoutUserInput = {
    create?: XOR<MenteeLanguageCreateWithoutUserInput, MenteeLanguageUncheckedCreateWithoutUserInput> | MenteeLanguageCreateWithoutUserInput[] | MenteeLanguageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenteeLanguageCreateOrConnectWithoutUserInput | MenteeLanguageCreateOrConnectWithoutUserInput[]
    createMany?: MenteeLanguageCreateManyUserInputEnvelope
    connect?: MenteeLanguageWhereUniqueInput | MenteeLanguageWhereUniqueInput[]
  }

  export type MenteeInterestCreateNestedManyWithoutUserInput = {
    create?: XOR<MenteeInterestCreateWithoutUserInput, MenteeInterestUncheckedCreateWithoutUserInput> | MenteeInterestCreateWithoutUserInput[] | MenteeInterestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenteeInterestCreateOrConnectWithoutUserInput | MenteeInterestCreateOrConnectWithoutUserInput[]
    createMany?: MenteeInterestCreateManyUserInputEnvelope
    connect?: MenteeInterestWhereUniqueInput | MenteeInterestWhereUniqueInput[]
  }

  export type MenteePriorityCreateNestedManyWithoutUserInput = {
    create?: XOR<MenteePriorityCreateWithoutUserInput, MenteePriorityUncheckedCreateWithoutUserInput> | MenteePriorityCreateWithoutUserInput[] | MenteePriorityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenteePriorityCreateOrConnectWithoutUserInput | MenteePriorityCreateOrConnectWithoutUserInput[]
    createMany?: MenteePriorityCreateManyUserInputEnvelope
    connect?: MenteePriorityWhereUniqueInput | MenteePriorityWhereUniqueInput[]
  }

  export type MentorLanguageCreateNestedManyWithoutUserInput = {
    create?: XOR<MentorLanguageCreateWithoutUserInput, MentorLanguageUncheckedCreateWithoutUserInput> | MentorLanguageCreateWithoutUserInput[] | MentorLanguageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MentorLanguageCreateOrConnectWithoutUserInput | MentorLanguageCreateOrConnectWithoutUserInput[]
    createMany?: MentorLanguageCreateManyUserInputEnvelope
    connect?: MentorLanguageWhereUniqueInput | MentorLanguageWhereUniqueInput[]
  }

  export type MentorCategoryCreateNestedManyWithoutUserInput = {
    create?: XOR<MentorCategoryCreateWithoutUserInput, MentorCategoryUncheckedCreateWithoutUserInput> | MentorCategoryCreateWithoutUserInput[] | MentorCategoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MentorCategoryCreateOrConnectWithoutUserInput | MentorCategoryCreateOrConnectWithoutUserInput[]
    createMany?: MentorCategoryCreateManyUserInputEnvelope
    connect?: MentorCategoryWhereUniqueInput | MentorCategoryWhereUniqueInput[]
  }

  export type MentorSkillCreateNestedManyWithoutUserInput = {
    create?: XOR<MentorSkillCreateWithoutUserInput, MentorSkillUncheckedCreateWithoutUserInput> | MentorSkillCreateWithoutUserInput[] | MentorSkillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MentorSkillCreateOrConnectWithoutUserInput | MentorSkillCreateOrConnectWithoutUserInput[]
    createMany?: MentorSkillCreateManyUserInputEnvelope
    connect?: MentorSkillWhereUniqueInput | MentorSkillWhereUniqueInput[]
  }

  export type MenteeServiceFocusCreateNestedManyWithoutUserInput = {
    create?: XOR<MenteeServiceFocusCreateWithoutUserInput, MenteeServiceFocusUncheckedCreateWithoutUserInput> | MenteeServiceFocusCreateWithoutUserInput[] | MenteeServiceFocusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenteeServiceFocusCreateOrConnectWithoutUserInput | MenteeServiceFocusCreateOrConnectWithoutUserInput[]
    createMany?: MenteeServiceFocusCreateManyUserInputEnvelope
    connect?: MenteeServiceFocusWhereUniqueInput | MenteeServiceFocusWhereUniqueInput[]
  }

  export type MenteeLanguageRefCreateNestedManyWithoutUserInput = {
    create?: XOR<MenteeLanguageRefCreateWithoutUserInput, MenteeLanguageRefUncheckedCreateWithoutUserInput> | MenteeLanguageRefCreateWithoutUserInput[] | MenteeLanguageRefUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenteeLanguageRefCreateOrConnectWithoutUserInput | MenteeLanguageRefCreateOrConnectWithoutUserInput[]
    createMany?: MenteeLanguageRefCreateManyUserInputEnvelope
    connect?: MenteeLanguageRefWhereUniqueInput | MenteeLanguageRefWhereUniqueInput[]
  }

  export type MenteeDisciplineRefCreateNestedManyWithoutUserInput = {
    create?: XOR<MenteeDisciplineRefCreateWithoutUserInput, MenteeDisciplineRefUncheckedCreateWithoutUserInput> | MenteeDisciplineRefCreateWithoutUserInput[] | MenteeDisciplineRefUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenteeDisciplineRefCreateOrConnectWithoutUserInput | MenteeDisciplineRefCreateOrConnectWithoutUserInput[]
    createMany?: MenteeDisciplineRefCreateManyUserInputEnvelope
    connect?: MenteeDisciplineRefWhereUniqueInput | MenteeDisciplineRefWhereUniqueInput[]
  }

  export type MenteePreferenceRefCreateNestedManyWithoutUserInput = {
    create?: XOR<MenteePreferenceRefCreateWithoutUserInput, MenteePreferenceRefUncheckedCreateWithoutUserInput> | MenteePreferenceRefCreateWithoutUserInput[] | MenteePreferenceRefUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenteePreferenceRefCreateOrConnectWithoutUserInput | MenteePreferenceRefCreateOrConnectWithoutUserInput[]
    createMany?: MenteePreferenceRefCreateManyUserInputEnvelope
    connect?: MenteePreferenceRefWhereUniqueInput | MenteePreferenceRefWhereUniqueInput[]
  }

  export type MentorCompanyMembershipCreateNestedManyWithoutUserInput = {
    create?: XOR<MentorCompanyMembershipCreateWithoutUserInput, MentorCompanyMembershipUncheckedCreateWithoutUserInput> | MentorCompanyMembershipCreateWithoutUserInput[] | MentorCompanyMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MentorCompanyMembershipCreateOrConnectWithoutUserInput | MentorCompanyMembershipCreateOrConnectWithoutUserInput[]
    createMany?: MentorCompanyMembershipCreateManyUserInputEnvelope
    connect?: MentorCompanyMembershipWhereUniqueInput | MentorCompanyMembershipWhereUniqueInput[]
  }

  export type MenteeUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<MenteeCreateWithoutUserInput, MenteeUncheckedCreateWithoutUserInput>
    connectOrCreate?: MenteeCreateOrConnectWithoutUserInput
    connect?: MenteeWhereUniqueInput
  }

  export type MentorUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<MentorCreateWithoutUserInput, MentorUncheckedCreateWithoutUserInput>
    connectOrCreate?: MentorCreateOrConnectWithoutUserInput
    connect?: MentorWhereUniqueInput
  }

  export type UserConsentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserConsentCreateOrConnectWithoutUserInput
    connect?: UserConsentWhereUniqueInput
  }

  export type MenteeLanguageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MenteeLanguageCreateWithoutUserInput, MenteeLanguageUncheckedCreateWithoutUserInput> | MenteeLanguageCreateWithoutUserInput[] | MenteeLanguageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenteeLanguageCreateOrConnectWithoutUserInput | MenteeLanguageCreateOrConnectWithoutUserInput[]
    createMany?: MenteeLanguageCreateManyUserInputEnvelope
    connect?: MenteeLanguageWhereUniqueInput | MenteeLanguageWhereUniqueInput[]
  }

  export type MenteeInterestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MenteeInterestCreateWithoutUserInput, MenteeInterestUncheckedCreateWithoutUserInput> | MenteeInterestCreateWithoutUserInput[] | MenteeInterestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenteeInterestCreateOrConnectWithoutUserInput | MenteeInterestCreateOrConnectWithoutUserInput[]
    createMany?: MenteeInterestCreateManyUserInputEnvelope
    connect?: MenteeInterestWhereUniqueInput | MenteeInterestWhereUniqueInput[]
  }

  export type MenteePriorityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MenteePriorityCreateWithoutUserInput, MenteePriorityUncheckedCreateWithoutUserInput> | MenteePriorityCreateWithoutUserInput[] | MenteePriorityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenteePriorityCreateOrConnectWithoutUserInput | MenteePriorityCreateOrConnectWithoutUserInput[]
    createMany?: MenteePriorityCreateManyUserInputEnvelope
    connect?: MenteePriorityWhereUniqueInput | MenteePriorityWhereUniqueInput[]
  }

  export type MentorLanguageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MentorLanguageCreateWithoutUserInput, MentorLanguageUncheckedCreateWithoutUserInput> | MentorLanguageCreateWithoutUserInput[] | MentorLanguageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MentorLanguageCreateOrConnectWithoutUserInput | MentorLanguageCreateOrConnectWithoutUserInput[]
    createMany?: MentorLanguageCreateManyUserInputEnvelope
    connect?: MentorLanguageWhereUniqueInput | MentorLanguageWhereUniqueInput[]
  }

  export type MentorCategoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MentorCategoryCreateWithoutUserInput, MentorCategoryUncheckedCreateWithoutUserInput> | MentorCategoryCreateWithoutUserInput[] | MentorCategoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MentorCategoryCreateOrConnectWithoutUserInput | MentorCategoryCreateOrConnectWithoutUserInput[]
    createMany?: MentorCategoryCreateManyUserInputEnvelope
    connect?: MentorCategoryWhereUniqueInput | MentorCategoryWhereUniqueInput[]
  }

  export type MentorSkillUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MentorSkillCreateWithoutUserInput, MentorSkillUncheckedCreateWithoutUserInput> | MentorSkillCreateWithoutUserInput[] | MentorSkillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MentorSkillCreateOrConnectWithoutUserInput | MentorSkillCreateOrConnectWithoutUserInput[]
    createMany?: MentorSkillCreateManyUserInputEnvelope
    connect?: MentorSkillWhereUniqueInput | MentorSkillWhereUniqueInput[]
  }

  export type MenteeServiceFocusUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MenteeServiceFocusCreateWithoutUserInput, MenteeServiceFocusUncheckedCreateWithoutUserInput> | MenteeServiceFocusCreateWithoutUserInput[] | MenteeServiceFocusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenteeServiceFocusCreateOrConnectWithoutUserInput | MenteeServiceFocusCreateOrConnectWithoutUserInput[]
    createMany?: MenteeServiceFocusCreateManyUserInputEnvelope
    connect?: MenteeServiceFocusWhereUniqueInput | MenteeServiceFocusWhereUniqueInput[]
  }

  export type MenteeLanguageRefUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MenteeLanguageRefCreateWithoutUserInput, MenteeLanguageRefUncheckedCreateWithoutUserInput> | MenteeLanguageRefCreateWithoutUserInput[] | MenteeLanguageRefUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenteeLanguageRefCreateOrConnectWithoutUserInput | MenteeLanguageRefCreateOrConnectWithoutUserInput[]
    createMany?: MenteeLanguageRefCreateManyUserInputEnvelope
    connect?: MenteeLanguageRefWhereUniqueInput | MenteeLanguageRefWhereUniqueInput[]
  }

  export type MenteeDisciplineRefUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MenteeDisciplineRefCreateWithoutUserInput, MenteeDisciplineRefUncheckedCreateWithoutUserInput> | MenteeDisciplineRefCreateWithoutUserInput[] | MenteeDisciplineRefUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenteeDisciplineRefCreateOrConnectWithoutUserInput | MenteeDisciplineRefCreateOrConnectWithoutUserInput[]
    createMany?: MenteeDisciplineRefCreateManyUserInputEnvelope
    connect?: MenteeDisciplineRefWhereUniqueInput | MenteeDisciplineRefWhereUniqueInput[]
  }

  export type MenteePreferenceRefUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MenteePreferenceRefCreateWithoutUserInput, MenteePreferenceRefUncheckedCreateWithoutUserInput> | MenteePreferenceRefCreateWithoutUserInput[] | MenteePreferenceRefUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenteePreferenceRefCreateOrConnectWithoutUserInput | MenteePreferenceRefCreateOrConnectWithoutUserInput[]
    createMany?: MenteePreferenceRefCreateManyUserInputEnvelope
    connect?: MenteePreferenceRefWhereUniqueInput | MenteePreferenceRefWhereUniqueInput[]
  }

  export type MentorCompanyMembershipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MentorCompanyMembershipCreateWithoutUserInput, MentorCompanyMembershipUncheckedCreateWithoutUserInput> | MentorCompanyMembershipCreateWithoutUserInput[] | MentorCompanyMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MentorCompanyMembershipCreateOrConnectWithoutUserInput | MentorCompanyMembershipCreateOrConnectWithoutUserInput[]
    createMany?: MentorCompanyMembershipCreateManyUserInputEnvelope
    connect?: MentorCompanyMembershipWhereUniqueInput | MentorCompanyMembershipWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type MenteeUpdateOneWithoutUserNestedInput = {
    create?: XOR<MenteeCreateWithoutUserInput, MenteeUncheckedCreateWithoutUserInput>
    connectOrCreate?: MenteeCreateOrConnectWithoutUserInput
    upsert?: MenteeUpsertWithoutUserInput
    disconnect?: MenteeWhereInput | boolean
    delete?: MenteeWhereInput | boolean
    connect?: MenteeWhereUniqueInput
    update?: XOR<XOR<MenteeUpdateToOneWithWhereWithoutUserInput, MenteeUpdateWithoutUserInput>, MenteeUncheckedUpdateWithoutUserInput>
  }

  export type MentorUpdateOneWithoutUserNestedInput = {
    create?: XOR<MentorCreateWithoutUserInput, MentorUncheckedCreateWithoutUserInput>
    connectOrCreate?: MentorCreateOrConnectWithoutUserInput
    upsert?: MentorUpsertWithoutUserInput
    disconnect?: MentorWhereInput | boolean
    delete?: MentorWhereInput | boolean
    connect?: MentorWhereUniqueInput
    update?: XOR<XOR<MentorUpdateToOneWithWhereWithoutUserInput, MentorUpdateWithoutUserInput>, MentorUncheckedUpdateWithoutUserInput>
  }

  export type UserConsentUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserConsentCreateOrConnectWithoutUserInput
    upsert?: UserConsentUpsertWithoutUserInput
    disconnect?: UserConsentWhereInput | boolean
    delete?: UserConsentWhereInput | boolean
    connect?: UserConsentWhereUniqueInput
    update?: XOR<XOR<UserConsentUpdateToOneWithWhereWithoutUserInput, UserConsentUpdateWithoutUserInput>, UserConsentUncheckedUpdateWithoutUserInput>
  }

  export type MenteeLanguageUpdateManyWithoutUserNestedInput = {
    create?: XOR<MenteeLanguageCreateWithoutUserInput, MenteeLanguageUncheckedCreateWithoutUserInput> | MenteeLanguageCreateWithoutUserInput[] | MenteeLanguageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenteeLanguageCreateOrConnectWithoutUserInput | MenteeLanguageCreateOrConnectWithoutUserInput[]
    upsert?: MenteeLanguageUpsertWithWhereUniqueWithoutUserInput | MenteeLanguageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MenteeLanguageCreateManyUserInputEnvelope
    set?: MenteeLanguageWhereUniqueInput | MenteeLanguageWhereUniqueInput[]
    disconnect?: MenteeLanguageWhereUniqueInput | MenteeLanguageWhereUniqueInput[]
    delete?: MenteeLanguageWhereUniqueInput | MenteeLanguageWhereUniqueInput[]
    connect?: MenteeLanguageWhereUniqueInput | MenteeLanguageWhereUniqueInput[]
    update?: MenteeLanguageUpdateWithWhereUniqueWithoutUserInput | MenteeLanguageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MenteeLanguageUpdateManyWithWhereWithoutUserInput | MenteeLanguageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MenteeLanguageScalarWhereInput | MenteeLanguageScalarWhereInput[]
  }

  export type MenteeInterestUpdateManyWithoutUserNestedInput = {
    create?: XOR<MenteeInterestCreateWithoutUserInput, MenteeInterestUncheckedCreateWithoutUserInput> | MenteeInterestCreateWithoutUserInput[] | MenteeInterestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenteeInterestCreateOrConnectWithoutUserInput | MenteeInterestCreateOrConnectWithoutUserInput[]
    upsert?: MenteeInterestUpsertWithWhereUniqueWithoutUserInput | MenteeInterestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MenteeInterestCreateManyUserInputEnvelope
    set?: MenteeInterestWhereUniqueInput | MenteeInterestWhereUniqueInput[]
    disconnect?: MenteeInterestWhereUniqueInput | MenteeInterestWhereUniqueInput[]
    delete?: MenteeInterestWhereUniqueInput | MenteeInterestWhereUniqueInput[]
    connect?: MenteeInterestWhereUniqueInput | MenteeInterestWhereUniqueInput[]
    update?: MenteeInterestUpdateWithWhereUniqueWithoutUserInput | MenteeInterestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MenteeInterestUpdateManyWithWhereWithoutUserInput | MenteeInterestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MenteeInterestScalarWhereInput | MenteeInterestScalarWhereInput[]
  }

  export type MenteePriorityUpdateManyWithoutUserNestedInput = {
    create?: XOR<MenteePriorityCreateWithoutUserInput, MenteePriorityUncheckedCreateWithoutUserInput> | MenteePriorityCreateWithoutUserInput[] | MenteePriorityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenteePriorityCreateOrConnectWithoutUserInput | MenteePriorityCreateOrConnectWithoutUserInput[]
    upsert?: MenteePriorityUpsertWithWhereUniqueWithoutUserInput | MenteePriorityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MenteePriorityCreateManyUserInputEnvelope
    set?: MenteePriorityWhereUniqueInput | MenteePriorityWhereUniqueInput[]
    disconnect?: MenteePriorityWhereUniqueInput | MenteePriorityWhereUniqueInput[]
    delete?: MenteePriorityWhereUniqueInput | MenteePriorityWhereUniqueInput[]
    connect?: MenteePriorityWhereUniqueInput | MenteePriorityWhereUniqueInput[]
    update?: MenteePriorityUpdateWithWhereUniqueWithoutUserInput | MenteePriorityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MenteePriorityUpdateManyWithWhereWithoutUserInput | MenteePriorityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MenteePriorityScalarWhereInput | MenteePriorityScalarWhereInput[]
  }

  export type MentorLanguageUpdateManyWithoutUserNestedInput = {
    create?: XOR<MentorLanguageCreateWithoutUserInput, MentorLanguageUncheckedCreateWithoutUserInput> | MentorLanguageCreateWithoutUserInput[] | MentorLanguageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MentorLanguageCreateOrConnectWithoutUserInput | MentorLanguageCreateOrConnectWithoutUserInput[]
    upsert?: MentorLanguageUpsertWithWhereUniqueWithoutUserInput | MentorLanguageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MentorLanguageCreateManyUserInputEnvelope
    set?: MentorLanguageWhereUniqueInput | MentorLanguageWhereUniqueInput[]
    disconnect?: MentorLanguageWhereUniqueInput | MentorLanguageWhereUniqueInput[]
    delete?: MentorLanguageWhereUniqueInput | MentorLanguageWhereUniqueInput[]
    connect?: MentorLanguageWhereUniqueInput | MentorLanguageWhereUniqueInput[]
    update?: MentorLanguageUpdateWithWhereUniqueWithoutUserInput | MentorLanguageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MentorLanguageUpdateManyWithWhereWithoutUserInput | MentorLanguageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MentorLanguageScalarWhereInput | MentorLanguageScalarWhereInput[]
  }

  export type MentorCategoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<MentorCategoryCreateWithoutUserInput, MentorCategoryUncheckedCreateWithoutUserInput> | MentorCategoryCreateWithoutUserInput[] | MentorCategoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MentorCategoryCreateOrConnectWithoutUserInput | MentorCategoryCreateOrConnectWithoutUserInput[]
    upsert?: MentorCategoryUpsertWithWhereUniqueWithoutUserInput | MentorCategoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MentorCategoryCreateManyUserInputEnvelope
    set?: MentorCategoryWhereUniqueInput | MentorCategoryWhereUniqueInput[]
    disconnect?: MentorCategoryWhereUniqueInput | MentorCategoryWhereUniqueInput[]
    delete?: MentorCategoryWhereUniqueInput | MentorCategoryWhereUniqueInput[]
    connect?: MentorCategoryWhereUniqueInput | MentorCategoryWhereUniqueInput[]
    update?: MentorCategoryUpdateWithWhereUniqueWithoutUserInput | MentorCategoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MentorCategoryUpdateManyWithWhereWithoutUserInput | MentorCategoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MentorCategoryScalarWhereInput | MentorCategoryScalarWhereInput[]
  }

  export type MentorSkillUpdateManyWithoutUserNestedInput = {
    create?: XOR<MentorSkillCreateWithoutUserInput, MentorSkillUncheckedCreateWithoutUserInput> | MentorSkillCreateWithoutUserInput[] | MentorSkillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MentorSkillCreateOrConnectWithoutUserInput | MentorSkillCreateOrConnectWithoutUserInput[]
    upsert?: MentorSkillUpsertWithWhereUniqueWithoutUserInput | MentorSkillUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MentorSkillCreateManyUserInputEnvelope
    set?: MentorSkillWhereUniqueInput | MentorSkillWhereUniqueInput[]
    disconnect?: MentorSkillWhereUniqueInput | MentorSkillWhereUniqueInput[]
    delete?: MentorSkillWhereUniqueInput | MentorSkillWhereUniqueInput[]
    connect?: MentorSkillWhereUniqueInput | MentorSkillWhereUniqueInput[]
    update?: MentorSkillUpdateWithWhereUniqueWithoutUserInput | MentorSkillUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MentorSkillUpdateManyWithWhereWithoutUserInput | MentorSkillUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MentorSkillScalarWhereInput | MentorSkillScalarWhereInput[]
  }

  export type MenteeServiceFocusUpdateManyWithoutUserNestedInput = {
    create?: XOR<MenteeServiceFocusCreateWithoutUserInput, MenteeServiceFocusUncheckedCreateWithoutUserInput> | MenteeServiceFocusCreateWithoutUserInput[] | MenteeServiceFocusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenteeServiceFocusCreateOrConnectWithoutUserInput | MenteeServiceFocusCreateOrConnectWithoutUserInput[]
    upsert?: MenteeServiceFocusUpsertWithWhereUniqueWithoutUserInput | MenteeServiceFocusUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MenteeServiceFocusCreateManyUserInputEnvelope
    set?: MenteeServiceFocusWhereUniqueInput | MenteeServiceFocusWhereUniqueInput[]
    disconnect?: MenteeServiceFocusWhereUniqueInput | MenteeServiceFocusWhereUniqueInput[]
    delete?: MenteeServiceFocusWhereUniqueInput | MenteeServiceFocusWhereUniqueInput[]
    connect?: MenteeServiceFocusWhereUniqueInput | MenteeServiceFocusWhereUniqueInput[]
    update?: MenteeServiceFocusUpdateWithWhereUniqueWithoutUserInput | MenteeServiceFocusUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MenteeServiceFocusUpdateManyWithWhereWithoutUserInput | MenteeServiceFocusUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MenteeServiceFocusScalarWhereInput | MenteeServiceFocusScalarWhereInput[]
  }

  export type MenteeLanguageRefUpdateManyWithoutUserNestedInput = {
    create?: XOR<MenteeLanguageRefCreateWithoutUserInput, MenteeLanguageRefUncheckedCreateWithoutUserInput> | MenteeLanguageRefCreateWithoutUserInput[] | MenteeLanguageRefUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenteeLanguageRefCreateOrConnectWithoutUserInput | MenteeLanguageRefCreateOrConnectWithoutUserInput[]
    upsert?: MenteeLanguageRefUpsertWithWhereUniqueWithoutUserInput | MenteeLanguageRefUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MenteeLanguageRefCreateManyUserInputEnvelope
    set?: MenteeLanguageRefWhereUniqueInput | MenteeLanguageRefWhereUniqueInput[]
    disconnect?: MenteeLanguageRefWhereUniqueInput | MenteeLanguageRefWhereUniqueInput[]
    delete?: MenteeLanguageRefWhereUniqueInput | MenteeLanguageRefWhereUniqueInput[]
    connect?: MenteeLanguageRefWhereUniqueInput | MenteeLanguageRefWhereUniqueInput[]
    update?: MenteeLanguageRefUpdateWithWhereUniqueWithoutUserInput | MenteeLanguageRefUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MenteeLanguageRefUpdateManyWithWhereWithoutUserInput | MenteeLanguageRefUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MenteeLanguageRefScalarWhereInput | MenteeLanguageRefScalarWhereInput[]
  }

  export type MenteeDisciplineRefUpdateManyWithoutUserNestedInput = {
    create?: XOR<MenteeDisciplineRefCreateWithoutUserInput, MenteeDisciplineRefUncheckedCreateWithoutUserInput> | MenteeDisciplineRefCreateWithoutUserInput[] | MenteeDisciplineRefUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenteeDisciplineRefCreateOrConnectWithoutUserInput | MenteeDisciplineRefCreateOrConnectWithoutUserInput[]
    upsert?: MenteeDisciplineRefUpsertWithWhereUniqueWithoutUserInput | MenteeDisciplineRefUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MenteeDisciplineRefCreateManyUserInputEnvelope
    set?: MenteeDisciplineRefWhereUniqueInput | MenteeDisciplineRefWhereUniqueInput[]
    disconnect?: MenteeDisciplineRefWhereUniqueInput | MenteeDisciplineRefWhereUniqueInput[]
    delete?: MenteeDisciplineRefWhereUniqueInput | MenteeDisciplineRefWhereUniqueInput[]
    connect?: MenteeDisciplineRefWhereUniqueInput | MenteeDisciplineRefWhereUniqueInput[]
    update?: MenteeDisciplineRefUpdateWithWhereUniqueWithoutUserInput | MenteeDisciplineRefUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MenteeDisciplineRefUpdateManyWithWhereWithoutUserInput | MenteeDisciplineRefUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MenteeDisciplineRefScalarWhereInput | MenteeDisciplineRefScalarWhereInput[]
  }

  export type MenteePreferenceRefUpdateManyWithoutUserNestedInput = {
    create?: XOR<MenteePreferenceRefCreateWithoutUserInput, MenteePreferenceRefUncheckedCreateWithoutUserInput> | MenteePreferenceRefCreateWithoutUserInput[] | MenteePreferenceRefUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenteePreferenceRefCreateOrConnectWithoutUserInput | MenteePreferenceRefCreateOrConnectWithoutUserInput[]
    upsert?: MenteePreferenceRefUpsertWithWhereUniqueWithoutUserInput | MenteePreferenceRefUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MenteePreferenceRefCreateManyUserInputEnvelope
    set?: MenteePreferenceRefWhereUniqueInput | MenteePreferenceRefWhereUniqueInput[]
    disconnect?: MenteePreferenceRefWhereUniqueInput | MenteePreferenceRefWhereUniqueInput[]
    delete?: MenteePreferenceRefWhereUniqueInput | MenteePreferenceRefWhereUniqueInput[]
    connect?: MenteePreferenceRefWhereUniqueInput | MenteePreferenceRefWhereUniqueInput[]
    update?: MenteePreferenceRefUpdateWithWhereUniqueWithoutUserInput | MenteePreferenceRefUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MenteePreferenceRefUpdateManyWithWhereWithoutUserInput | MenteePreferenceRefUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MenteePreferenceRefScalarWhereInput | MenteePreferenceRefScalarWhereInput[]
  }

  export type MentorCompanyMembershipUpdateManyWithoutUserNestedInput = {
    create?: XOR<MentorCompanyMembershipCreateWithoutUserInput, MentorCompanyMembershipUncheckedCreateWithoutUserInput> | MentorCompanyMembershipCreateWithoutUserInput[] | MentorCompanyMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MentorCompanyMembershipCreateOrConnectWithoutUserInput | MentorCompanyMembershipCreateOrConnectWithoutUserInput[]
    upsert?: MentorCompanyMembershipUpsertWithWhereUniqueWithoutUserInput | MentorCompanyMembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MentorCompanyMembershipCreateManyUserInputEnvelope
    set?: MentorCompanyMembershipWhereUniqueInput | MentorCompanyMembershipWhereUniqueInput[]
    disconnect?: MentorCompanyMembershipWhereUniqueInput | MentorCompanyMembershipWhereUniqueInput[]
    delete?: MentorCompanyMembershipWhereUniqueInput | MentorCompanyMembershipWhereUniqueInput[]
    connect?: MentorCompanyMembershipWhereUniqueInput | MentorCompanyMembershipWhereUniqueInput[]
    update?: MentorCompanyMembershipUpdateWithWhereUniqueWithoutUserInput | MentorCompanyMembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MentorCompanyMembershipUpdateManyWithWhereWithoutUserInput | MentorCompanyMembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MentorCompanyMembershipScalarWhereInput | MentorCompanyMembershipScalarWhereInput[]
  }

  export type MenteeUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<MenteeCreateWithoutUserInput, MenteeUncheckedCreateWithoutUserInput>
    connectOrCreate?: MenteeCreateOrConnectWithoutUserInput
    upsert?: MenteeUpsertWithoutUserInput
    disconnect?: MenteeWhereInput | boolean
    delete?: MenteeWhereInput | boolean
    connect?: MenteeWhereUniqueInput
    update?: XOR<XOR<MenteeUpdateToOneWithWhereWithoutUserInput, MenteeUpdateWithoutUserInput>, MenteeUncheckedUpdateWithoutUserInput>
  }

  export type MentorUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<MentorCreateWithoutUserInput, MentorUncheckedCreateWithoutUserInput>
    connectOrCreate?: MentorCreateOrConnectWithoutUserInput
    upsert?: MentorUpsertWithoutUserInput
    disconnect?: MentorWhereInput | boolean
    delete?: MentorWhereInput | boolean
    connect?: MentorWhereUniqueInput
    update?: XOR<XOR<MentorUpdateToOneWithWhereWithoutUserInput, MentorUpdateWithoutUserInput>, MentorUncheckedUpdateWithoutUserInput>
  }

  export type UserConsentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserConsentCreateOrConnectWithoutUserInput
    upsert?: UserConsentUpsertWithoutUserInput
    disconnect?: UserConsentWhereInput | boolean
    delete?: UserConsentWhereInput | boolean
    connect?: UserConsentWhereUniqueInput
    update?: XOR<XOR<UserConsentUpdateToOneWithWhereWithoutUserInput, UserConsentUpdateWithoutUserInput>, UserConsentUncheckedUpdateWithoutUserInput>
  }

  export type MenteeLanguageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MenteeLanguageCreateWithoutUserInput, MenteeLanguageUncheckedCreateWithoutUserInput> | MenteeLanguageCreateWithoutUserInput[] | MenteeLanguageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenteeLanguageCreateOrConnectWithoutUserInput | MenteeLanguageCreateOrConnectWithoutUserInput[]
    upsert?: MenteeLanguageUpsertWithWhereUniqueWithoutUserInput | MenteeLanguageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MenteeLanguageCreateManyUserInputEnvelope
    set?: MenteeLanguageWhereUniqueInput | MenteeLanguageWhereUniqueInput[]
    disconnect?: MenteeLanguageWhereUniqueInput | MenteeLanguageWhereUniqueInput[]
    delete?: MenteeLanguageWhereUniqueInput | MenteeLanguageWhereUniqueInput[]
    connect?: MenteeLanguageWhereUniqueInput | MenteeLanguageWhereUniqueInput[]
    update?: MenteeLanguageUpdateWithWhereUniqueWithoutUserInput | MenteeLanguageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MenteeLanguageUpdateManyWithWhereWithoutUserInput | MenteeLanguageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MenteeLanguageScalarWhereInput | MenteeLanguageScalarWhereInput[]
  }

  export type MenteeInterestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MenteeInterestCreateWithoutUserInput, MenteeInterestUncheckedCreateWithoutUserInput> | MenteeInterestCreateWithoutUserInput[] | MenteeInterestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenteeInterestCreateOrConnectWithoutUserInput | MenteeInterestCreateOrConnectWithoutUserInput[]
    upsert?: MenteeInterestUpsertWithWhereUniqueWithoutUserInput | MenteeInterestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MenteeInterestCreateManyUserInputEnvelope
    set?: MenteeInterestWhereUniqueInput | MenteeInterestWhereUniqueInput[]
    disconnect?: MenteeInterestWhereUniqueInput | MenteeInterestWhereUniqueInput[]
    delete?: MenteeInterestWhereUniqueInput | MenteeInterestWhereUniqueInput[]
    connect?: MenteeInterestWhereUniqueInput | MenteeInterestWhereUniqueInput[]
    update?: MenteeInterestUpdateWithWhereUniqueWithoutUserInput | MenteeInterestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MenteeInterestUpdateManyWithWhereWithoutUserInput | MenteeInterestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MenteeInterestScalarWhereInput | MenteeInterestScalarWhereInput[]
  }

  export type MenteePriorityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MenteePriorityCreateWithoutUserInput, MenteePriorityUncheckedCreateWithoutUserInput> | MenteePriorityCreateWithoutUserInput[] | MenteePriorityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenteePriorityCreateOrConnectWithoutUserInput | MenteePriorityCreateOrConnectWithoutUserInput[]
    upsert?: MenteePriorityUpsertWithWhereUniqueWithoutUserInput | MenteePriorityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MenteePriorityCreateManyUserInputEnvelope
    set?: MenteePriorityWhereUniqueInput | MenteePriorityWhereUniqueInput[]
    disconnect?: MenteePriorityWhereUniqueInput | MenteePriorityWhereUniqueInput[]
    delete?: MenteePriorityWhereUniqueInput | MenteePriorityWhereUniqueInput[]
    connect?: MenteePriorityWhereUniqueInput | MenteePriorityWhereUniqueInput[]
    update?: MenteePriorityUpdateWithWhereUniqueWithoutUserInput | MenteePriorityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MenteePriorityUpdateManyWithWhereWithoutUserInput | MenteePriorityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MenteePriorityScalarWhereInput | MenteePriorityScalarWhereInput[]
  }

  export type MentorLanguageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MentorLanguageCreateWithoutUserInput, MentorLanguageUncheckedCreateWithoutUserInput> | MentorLanguageCreateWithoutUserInput[] | MentorLanguageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MentorLanguageCreateOrConnectWithoutUserInput | MentorLanguageCreateOrConnectWithoutUserInput[]
    upsert?: MentorLanguageUpsertWithWhereUniqueWithoutUserInput | MentorLanguageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MentorLanguageCreateManyUserInputEnvelope
    set?: MentorLanguageWhereUniqueInput | MentorLanguageWhereUniqueInput[]
    disconnect?: MentorLanguageWhereUniqueInput | MentorLanguageWhereUniqueInput[]
    delete?: MentorLanguageWhereUniqueInput | MentorLanguageWhereUniqueInput[]
    connect?: MentorLanguageWhereUniqueInput | MentorLanguageWhereUniqueInput[]
    update?: MentorLanguageUpdateWithWhereUniqueWithoutUserInput | MentorLanguageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MentorLanguageUpdateManyWithWhereWithoutUserInput | MentorLanguageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MentorLanguageScalarWhereInput | MentorLanguageScalarWhereInput[]
  }

  export type MentorCategoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MentorCategoryCreateWithoutUserInput, MentorCategoryUncheckedCreateWithoutUserInput> | MentorCategoryCreateWithoutUserInput[] | MentorCategoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MentorCategoryCreateOrConnectWithoutUserInput | MentorCategoryCreateOrConnectWithoutUserInput[]
    upsert?: MentorCategoryUpsertWithWhereUniqueWithoutUserInput | MentorCategoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MentorCategoryCreateManyUserInputEnvelope
    set?: MentorCategoryWhereUniqueInput | MentorCategoryWhereUniqueInput[]
    disconnect?: MentorCategoryWhereUniqueInput | MentorCategoryWhereUniqueInput[]
    delete?: MentorCategoryWhereUniqueInput | MentorCategoryWhereUniqueInput[]
    connect?: MentorCategoryWhereUniqueInput | MentorCategoryWhereUniqueInput[]
    update?: MentorCategoryUpdateWithWhereUniqueWithoutUserInput | MentorCategoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MentorCategoryUpdateManyWithWhereWithoutUserInput | MentorCategoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MentorCategoryScalarWhereInput | MentorCategoryScalarWhereInput[]
  }

  export type MentorSkillUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MentorSkillCreateWithoutUserInput, MentorSkillUncheckedCreateWithoutUserInput> | MentorSkillCreateWithoutUserInput[] | MentorSkillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MentorSkillCreateOrConnectWithoutUserInput | MentorSkillCreateOrConnectWithoutUserInput[]
    upsert?: MentorSkillUpsertWithWhereUniqueWithoutUserInput | MentorSkillUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MentorSkillCreateManyUserInputEnvelope
    set?: MentorSkillWhereUniqueInput | MentorSkillWhereUniqueInput[]
    disconnect?: MentorSkillWhereUniqueInput | MentorSkillWhereUniqueInput[]
    delete?: MentorSkillWhereUniqueInput | MentorSkillWhereUniqueInput[]
    connect?: MentorSkillWhereUniqueInput | MentorSkillWhereUniqueInput[]
    update?: MentorSkillUpdateWithWhereUniqueWithoutUserInput | MentorSkillUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MentorSkillUpdateManyWithWhereWithoutUserInput | MentorSkillUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MentorSkillScalarWhereInput | MentorSkillScalarWhereInput[]
  }

  export type MenteeServiceFocusUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MenteeServiceFocusCreateWithoutUserInput, MenteeServiceFocusUncheckedCreateWithoutUserInput> | MenteeServiceFocusCreateWithoutUserInput[] | MenteeServiceFocusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenteeServiceFocusCreateOrConnectWithoutUserInput | MenteeServiceFocusCreateOrConnectWithoutUserInput[]
    upsert?: MenteeServiceFocusUpsertWithWhereUniqueWithoutUserInput | MenteeServiceFocusUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MenteeServiceFocusCreateManyUserInputEnvelope
    set?: MenteeServiceFocusWhereUniqueInput | MenteeServiceFocusWhereUniqueInput[]
    disconnect?: MenteeServiceFocusWhereUniqueInput | MenteeServiceFocusWhereUniqueInput[]
    delete?: MenteeServiceFocusWhereUniqueInput | MenteeServiceFocusWhereUniqueInput[]
    connect?: MenteeServiceFocusWhereUniqueInput | MenteeServiceFocusWhereUniqueInput[]
    update?: MenteeServiceFocusUpdateWithWhereUniqueWithoutUserInput | MenteeServiceFocusUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MenteeServiceFocusUpdateManyWithWhereWithoutUserInput | MenteeServiceFocusUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MenteeServiceFocusScalarWhereInput | MenteeServiceFocusScalarWhereInput[]
  }

  export type MenteeLanguageRefUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MenteeLanguageRefCreateWithoutUserInput, MenteeLanguageRefUncheckedCreateWithoutUserInput> | MenteeLanguageRefCreateWithoutUserInput[] | MenteeLanguageRefUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenteeLanguageRefCreateOrConnectWithoutUserInput | MenteeLanguageRefCreateOrConnectWithoutUserInput[]
    upsert?: MenteeLanguageRefUpsertWithWhereUniqueWithoutUserInput | MenteeLanguageRefUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MenteeLanguageRefCreateManyUserInputEnvelope
    set?: MenteeLanguageRefWhereUniqueInput | MenteeLanguageRefWhereUniqueInput[]
    disconnect?: MenteeLanguageRefWhereUniqueInput | MenteeLanguageRefWhereUniqueInput[]
    delete?: MenteeLanguageRefWhereUniqueInput | MenteeLanguageRefWhereUniqueInput[]
    connect?: MenteeLanguageRefWhereUniqueInput | MenteeLanguageRefWhereUniqueInput[]
    update?: MenteeLanguageRefUpdateWithWhereUniqueWithoutUserInput | MenteeLanguageRefUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MenteeLanguageRefUpdateManyWithWhereWithoutUserInput | MenteeLanguageRefUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MenteeLanguageRefScalarWhereInput | MenteeLanguageRefScalarWhereInput[]
  }

  export type MenteeDisciplineRefUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MenteeDisciplineRefCreateWithoutUserInput, MenteeDisciplineRefUncheckedCreateWithoutUserInput> | MenteeDisciplineRefCreateWithoutUserInput[] | MenteeDisciplineRefUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenteeDisciplineRefCreateOrConnectWithoutUserInput | MenteeDisciplineRefCreateOrConnectWithoutUserInput[]
    upsert?: MenteeDisciplineRefUpsertWithWhereUniqueWithoutUserInput | MenteeDisciplineRefUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MenteeDisciplineRefCreateManyUserInputEnvelope
    set?: MenteeDisciplineRefWhereUniqueInput | MenteeDisciplineRefWhereUniqueInput[]
    disconnect?: MenteeDisciplineRefWhereUniqueInput | MenteeDisciplineRefWhereUniqueInput[]
    delete?: MenteeDisciplineRefWhereUniqueInput | MenteeDisciplineRefWhereUniqueInput[]
    connect?: MenteeDisciplineRefWhereUniqueInput | MenteeDisciplineRefWhereUniqueInput[]
    update?: MenteeDisciplineRefUpdateWithWhereUniqueWithoutUserInput | MenteeDisciplineRefUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MenteeDisciplineRefUpdateManyWithWhereWithoutUserInput | MenteeDisciplineRefUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MenteeDisciplineRefScalarWhereInput | MenteeDisciplineRefScalarWhereInput[]
  }

  export type MenteePreferenceRefUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MenteePreferenceRefCreateWithoutUserInput, MenteePreferenceRefUncheckedCreateWithoutUserInput> | MenteePreferenceRefCreateWithoutUserInput[] | MenteePreferenceRefUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MenteePreferenceRefCreateOrConnectWithoutUserInput | MenteePreferenceRefCreateOrConnectWithoutUserInput[]
    upsert?: MenteePreferenceRefUpsertWithWhereUniqueWithoutUserInput | MenteePreferenceRefUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MenteePreferenceRefCreateManyUserInputEnvelope
    set?: MenteePreferenceRefWhereUniqueInput | MenteePreferenceRefWhereUniqueInput[]
    disconnect?: MenteePreferenceRefWhereUniqueInput | MenteePreferenceRefWhereUniqueInput[]
    delete?: MenteePreferenceRefWhereUniqueInput | MenteePreferenceRefWhereUniqueInput[]
    connect?: MenteePreferenceRefWhereUniqueInput | MenteePreferenceRefWhereUniqueInput[]
    update?: MenteePreferenceRefUpdateWithWhereUniqueWithoutUserInput | MenteePreferenceRefUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MenteePreferenceRefUpdateManyWithWhereWithoutUserInput | MenteePreferenceRefUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MenteePreferenceRefScalarWhereInput | MenteePreferenceRefScalarWhereInput[]
  }

  export type MentorCompanyMembershipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MentorCompanyMembershipCreateWithoutUserInput, MentorCompanyMembershipUncheckedCreateWithoutUserInput> | MentorCompanyMembershipCreateWithoutUserInput[] | MentorCompanyMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MentorCompanyMembershipCreateOrConnectWithoutUserInput | MentorCompanyMembershipCreateOrConnectWithoutUserInput[]
    upsert?: MentorCompanyMembershipUpsertWithWhereUniqueWithoutUserInput | MentorCompanyMembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MentorCompanyMembershipCreateManyUserInputEnvelope
    set?: MentorCompanyMembershipWhereUniqueInput | MentorCompanyMembershipWhereUniqueInput[]
    disconnect?: MentorCompanyMembershipWhereUniqueInput | MentorCompanyMembershipWhereUniqueInput[]
    delete?: MentorCompanyMembershipWhereUniqueInput | MentorCompanyMembershipWhereUniqueInput[]
    connect?: MentorCompanyMembershipWhereUniqueInput | MentorCompanyMembershipWhereUniqueInput[]
    update?: MentorCompanyMembershipUpdateWithWhereUniqueWithoutUserInput | MentorCompanyMembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MentorCompanyMembershipUpdateManyWithWhereWithoutUserInput | MentorCompanyMembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MentorCompanyMembershipScalarWhereInput | MentorCompanyMembershipScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMentee_profileInput = {
    create?: XOR<UserCreateWithoutMentee_profileInput, UserUncheckedCreateWithoutMentee_profileInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentee_profileInput
    connect?: UserWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdateOneRequiredWithoutMentee_profileNestedInput = {
    create?: XOR<UserCreateWithoutMentee_profileInput, UserUncheckedCreateWithoutMentee_profileInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentee_profileInput
    upsert?: UserUpsertWithoutMentee_profileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMentee_profileInput, UserUpdateWithoutMentee_profileInput>, UserUncheckedUpdateWithoutMentee_profileInput>
  }

  export type UserCreateNestedOneWithoutMentor_profileInput = {
    create?: XOR<UserCreateWithoutMentor_profileInput, UserUncheckedCreateWithoutMentor_profileInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentor_profileInput
    connect?: UserWhereUniqueInput
  }

  export type EnumMentorTypeFieldUpdateOperationsInput = {
    set?: $Enums.MentorType
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumMentorStatusFieldUpdateOperationsInput = {
    set?: $Enums.MentorStatus
  }

  export type UserUpdateOneRequiredWithoutMentor_profileNestedInput = {
    create?: XOR<UserCreateWithoutMentor_profileInput, UserUncheckedCreateWithoutMentor_profileInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentor_profileInput
    upsert?: UserUpsertWithoutMentor_profileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMentor_profileInput, UserUpdateWithoutMentor_profileInput>, UserUncheckedUpdateWithoutMentor_profileInput>
  }

  export type MenteeServiceFocusCreateNestedManyWithoutService_focusInput = {
    create?: XOR<MenteeServiceFocusCreateWithoutService_focusInput, MenteeServiceFocusUncheckedCreateWithoutService_focusInput> | MenteeServiceFocusCreateWithoutService_focusInput[] | MenteeServiceFocusUncheckedCreateWithoutService_focusInput[]
    connectOrCreate?: MenteeServiceFocusCreateOrConnectWithoutService_focusInput | MenteeServiceFocusCreateOrConnectWithoutService_focusInput[]
    createMany?: MenteeServiceFocusCreateManyService_focusInputEnvelope
    connect?: MenteeServiceFocusWhereUniqueInput | MenteeServiceFocusWhereUniqueInput[]
  }

  export type MenteeServiceFocusUncheckedCreateNestedManyWithoutService_focusInput = {
    create?: XOR<MenteeServiceFocusCreateWithoutService_focusInput, MenteeServiceFocusUncheckedCreateWithoutService_focusInput> | MenteeServiceFocusCreateWithoutService_focusInput[] | MenteeServiceFocusUncheckedCreateWithoutService_focusInput[]
    connectOrCreate?: MenteeServiceFocusCreateOrConnectWithoutService_focusInput | MenteeServiceFocusCreateOrConnectWithoutService_focusInput[]
    createMany?: MenteeServiceFocusCreateManyService_focusInputEnvelope
    connect?: MenteeServiceFocusWhereUniqueInput | MenteeServiceFocusWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type MenteeServiceFocusUpdateManyWithoutService_focusNestedInput = {
    create?: XOR<MenteeServiceFocusCreateWithoutService_focusInput, MenteeServiceFocusUncheckedCreateWithoutService_focusInput> | MenteeServiceFocusCreateWithoutService_focusInput[] | MenteeServiceFocusUncheckedCreateWithoutService_focusInput[]
    connectOrCreate?: MenteeServiceFocusCreateOrConnectWithoutService_focusInput | MenteeServiceFocusCreateOrConnectWithoutService_focusInput[]
    upsert?: MenteeServiceFocusUpsertWithWhereUniqueWithoutService_focusInput | MenteeServiceFocusUpsertWithWhereUniqueWithoutService_focusInput[]
    createMany?: MenteeServiceFocusCreateManyService_focusInputEnvelope
    set?: MenteeServiceFocusWhereUniqueInput | MenteeServiceFocusWhereUniqueInput[]
    disconnect?: MenteeServiceFocusWhereUniqueInput | MenteeServiceFocusWhereUniqueInput[]
    delete?: MenteeServiceFocusWhereUniqueInput | MenteeServiceFocusWhereUniqueInput[]
    connect?: MenteeServiceFocusWhereUniqueInput | MenteeServiceFocusWhereUniqueInput[]
    update?: MenteeServiceFocusUpdateWithWhereUniqueWithoutService_focusInput | MenteeServiceFocusUpdateWithWhereUniqueWithoutService_focusInput[]
    updateMany?: MenteeServiceFocusUpdateManyWithWhereWithoutService_focusInput | MenteeServiceFocusUpdateManyWithWhereWithoutService_focusInput[]
    deleteMany?: MenteeServiceFocusScalarWhereInput | MenteeServiceFocusScalarWhereInput[]
  }

  export type MenteeServiceFocusUncheckedUpdateManyWithoutService_focusNestedInput = {
    create?: XOR<MenteeServiceFocusCreateWithoutService_focusInput, MenteeServiceFocusUncheckedCreateWithoutService_focusInput> | MenteeServiceFocusCreateWithoutService_focusInput[] | MenteeServiceFocusUncheckedCreateWithoutService_focusInput[]
    connectOrCreate?: MenteeServiceFocusCreateOrConnectWithoutService_focusInput | MenteeServiceFocusCreateOrConnectWithoutService_focusInput[]
    upsert?: MenteeServiceFocusUpsertWithWhereUniqueWithoutService_focusInput | MenteeServiceFocusUpsertWithWhereUniqueWithoutService_focusInput[]
    createMany?: MenteeServiceFocusCreateManyService_focusInputEnvelope
    set?: MenteeServiceFocusWhereUniqueInput | MenteeServiceFocusWhereUniqueInput[]
    disconnect?: MenteeServiceFocusWhereUniqueInput | MenteeServiceFocusWhereUniqueInput[]
    delete?: MenteeServiceFocusWhereUniqueInput | MenteeServiceFocusWhereUniqueInput[]
    connect?: MenteeServiceFocusWhereUniqueInput | MenteeServiceFocusWhereUniqueInput[]
    update?: MenteeServiceFocusUpdateWithWhereUniqueWithoutService_focusInput | MenteeServiceFocusUpdateWithWhereUniqueWithoutService_focusInput[]
    updateMany?: MenteeServiceFocusUpdateManyWithWhereWithoutService_focusInput | MenteeServiceFocusUpdateManyWithWhereWithoutService_focusInput[]
    deleteMany?: MenteeServiceFocusScalarWhereInput | MenteeServiceFocusScalarWhereInput[]
  }

  export type MenteeLanguageRefCreateNestedManyWithoutLanguageInput = {
    create?: XOR<MenteeLanguageRefCreateWithoutLanguageInput, MenteeLanguageRefUncheckedCreateWithoutLanguageInput> | MenteeLanguageRefCreateWithoutLanguageInput[] | MenteeLanguageRefUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: MenteeLanguageRefCreateOrConnectWithoutLanguageInput | MenteeLanguageRefCreateOrConnectWithoutLanguageInput[]
    createMany?: MenteeLanguageRefCreateManyLanguageInputEnvelope
    connect?: MenteeLanguageRefWhereUniqueInput | MenteeLanguageRefWhereUniqueInput[]
  }

  export type MenteeLanguageRefUncheckedCreateNestedManyWithoutLanguageInput = {
    create?: XOR<MenteeLanguageRefCreateWithoutLanguageInput, MenteeLanguageRefUncheckedCreateWithoutLanguageInput> | MenteeLanguageRefCreateWithoutLanguageInput[] | MenteeLanguageRefUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: MenteeLanguageRefCreateOrConnectWithoutLanguageInput | MenteeLanguageRefCreateOrConnectWithoutLanguageInput[]
    createMany?: MenteeLanguageRefCreateManyLanguageInputEnvelope
    connect?: MenteeLanguageRefWhereUniqueInput | MenteeLanguageRefWhereUniqueInput[]
  }

  export type MenteeLanguageRefUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<MenteeLanguageRefCreateWithoutLanguageInput, MenteeLanguageRefUncheckedCreateWithoutLanguageInput> | MenteeLanguageRefCreateWithoutLanguageInput[] | MenteeLanguageRefUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: MenteeLanguageRefCreateOrConnectWithoutLanguageInput | MenteeLanguageRefCreateOrConnectWithoutLanguageInput[]
    upsert?: MenteeLanguageRefUpsertWithWhereUniqueWithoutLanguageInput | MenteeLanguageRefUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: MenteeLanguageRefCreateManyLanguageInputEnvelope
    set?: MenteeLanguageRefWhereUniqueInput | MenteeLanguageRefWhereUniqueInput[]
    disconnect?: MenteeLanguageRefWhereUniqueInput | MenteeLanguageRefWhereUniqueInput[]
    delete?: MenteeLanguageRefWhereUniqueInput | MenteeLanguageRefWhereUniqueInput[]
    connect?: MenteeLanguageRefWhereUniqueInput | MenteeLanguageRefWhereUniqueInput[]
    update?: MenteeLanguageRefUpdateWithWhereUniqueWithoutLanguageInput | MenteeLanguageRefUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: MenteeLanguageRefUpdateManyWithWhereWithoutLanguageInput | MenteeLanguageRefUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: MenteeLanguageRefScalarWhereInput | MenteeLanguageRefScalarWhereInput[]
  }

  export type MenteeLanguageRefUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<MenteeLanguageRefCreateWithoutLanguageInput, MenteeLanguageRefUncheckedCreateWithoutLanguageInput> | MenteeLanguageRefCreateWithoutLanguageInput[] | MenteeLanguageRefUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: MenteeLanguageRefCreateOrConnectWithoutLanguageInput | MenteeLanguageRefCreateOrConnectWithoutLanguageInput[]
    upsert?: MenteeLanguageRefUpsertWithWhereUniqueWithoutLanguageInput | MenteeLanguageRefUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: MenteeLanguageRefCreateManyLanguageInputEnvelope
    set?: MenteeLanguageRefWhereUniqueInput | MenteeLanguageRefWhereUniqueInput[]
    disconnect?: MenteeLanguageRefWhereUniqueInput | MenteeLanguageRefWhereUniqueInput[]
    delete?: MenteeLanguageRefWhereUniqueInput | MenteeLanguageRefWhereUniqueInput[]
    connect?: MenteeLanguageRefWhereUniqueInput | MenteeLanguageRefWhereUniqueInput[]
    update?: MenteeLanguageRefUpdateWithWhereUniqueWithoutLanguageInput | MenteeLanguageRefUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: MenteeLanguageRefUpdateManyWithWhereWithoutLanguageInput | MenteeLanguageRefUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: MenteeLanguageRefScalarWhereInput | MenteeLanguageRefScalarWhereInput[]
  }

  export type MenteeDisciplineRefCreateNestedManyWithoutDisciplineInput = {
    create?: XOR<MenteeDisciplineRefCreateWithoutDisciplineInput, MenteeDisciplineRefUncheckedCreateWithoutDisciplineInput> | MenteeDisciplineRefCreateWithoutDisciplineInput[] | MenteeDisciplineRefUncheckedCreateWithoutDisciplineInput[]
    connectOrCreate?: MenteeDisciplineRefCreateOrConnectWithoutDisciplineInput | MenteeDisciplineRefCreateOrConnectWithoutDisciplineInput[]
    createMany?: MenteeDisciplineRefCreateManyDisciplineInputEnvelope
    connect?: MenteeDisciplineRefWhereUniqueInput | MenteeDisciplineRefWhereUniqueInput[]
  }

  export type MenteeDisciplineRefUncheckedCreateNestedManyWithoutDisciplineInput = {
    create?: XOR<MenteeDisciplineRefCreateWithoutDisciplineInput, MenteeDisciplineRefUncheckedCreateWithoutDisciplineInput> | MenteeDisciplineRefCreateWithoutDisciplineInput[] | MenteeDisciplineRefUncheckedCreateWithoutDisciplineInput[]
    connectOrCreate?: MenteeDisciplineRefCreateOrConnectWithoutDisciplineInput | MenteeDisciplineRefCreateOrConnectWithoutDisciplineInput[]
    createMany?: MenteeDisciplineRefCreateManyDisciplineInputEnvelope
    connect?: MenteeDisciplineRefWhereUniqueInput | MenteeDisciplineRefWhereUniqueInput[]
  }

  export type MenteeDisciplineRefUpdateManyWithoutDisciplineNestedInput = {
    create?: XOR<MenteeDisciplineRefCreateWithoutDisciplineInput, MenteeDisciplineRefUncheckedCreateWithoutDisciplineInput> | MenteeDisciplineRefCreateWithoutDisciplineInput[] | MenteeDisciplineRefUncheckedCreateWithoutDisciplineInput[]
    connectOrCreate?: MenteeDisciplineRefCreateOrConnectWithoutDisciplineInput | MenteeDisciplineRefCreateOrConnectWithoutDisciplineInput[]
    upsert?: MenteeDisciplineRefUpsertWithWhereUniqueWithoutDisciplineInput | MenteeDisciplineRefUpsertWithWhereUniqueWithoutDisciplineInput[]
    createMany?: MenteeDisciplineRefCreateManyDisciplineInputEnvelope
    set?: MenteeDisciplineRefWhereUniqueInput | MenteeDisciplineRefWhereUniqueInput[]
    disconnect?: MenteeDisciplineRefWhereUniqueInput | MenteeDisciplineRefWhereUniqueInput[]
    delete?: MenteeDisciplineRefWhereUniqueInput | MenteeDisciplineRefWhereUniqueInput[]
    connect?: MenteeDisciplineRefWhereUniqueInput | MenteeDisciplineRefWhereUniqueInput[]
    update?: MenteeDisciplineRefUpdateWithWhereUniqueWithoutDisciplineInput | MenteeDisciplineRefUpdateWithWhereUniqueWithoutDisciplineInput[]
    updateMany?: MenteeDisciplineRefUpdateManyWithWhereWithoutDisciplineInput | MenteeDisciplineRefUpdateManyWithWhereWithoutDisciplineInput[]
    deleteMany?: MenteeDisciplineRefScalarWhereInput | MenteeDisciplineRefScalarWhereInput[]
  }

  export type MenteeDisciplineRefUncheckedUpdateManyWithoutDisciplineNestedInput = {
    create?: XOR<MenteeDisciplineRefCreateWithoutDisciplineInput, MenteeDisciplineRefUncheckedCreateWithoutDisciplineInput> | MenteeDisciplineRefCreateWithoutDisciplineInput[] | MenteeDisciplineRefUncheckedCreateWithoutDisciplineInput[]
    connectOrCreate?: MenteeDisciplineRefCreateOrConnectWithoutDisciplineInput | MenteeDisciplineRefCreateOrConnectWithoutDisciplineInput[]
    upsert?: MenteeDisciplineRefUpsertWithWhereUniqueWithoutDisciplineInput | MenteeDisciplineRefUpsertWithWhereUniqueWithoutDisciplineInput[]
    createMany?: MenteeDisciplineRefCreateManyDisciplineInputEnvelope
    set?: MenteeDisciplineRefWhereUniqueInput | MenteeDisciplineRefWhereUniqueInput[]
    disconnect?: MenteeDisciplineRefWhereUniqueInput | MenteeDisciplineRefWhereUniqueInput[]
    delete?: MenteeDisciplineRefWhereUniqueInput | MenteeDisciplineRefWhereUniqueInput[]
    connect?: MenteeDisciplineRefWhereUniqueInput | MenteeDisciplineRefWhereUniqueInput[]
    update?: MenteeDisciplineRefUpdateWithWhereUniqueWithoutDisciplineInput | MenteeDisciplineRefUpdateWithWhereUniqueWithoutDisciplineInput[]
    updateMany?: MenteeDisciplineRefUpdateManyWithWhereWithoutDisciplineInput | MenteeDisciplineRefUpdateManyWithWhereWithoutDisciplineInput[]
    deleteMany?: MenteeDisciplineRefScalarWhereInput | MenteeDisciplineRefScalarWhereInput[]
  }

  export type MenteePreferenceRefCreateNestedManyWithoutPreferenceInput = {
    create?: XOR<MenteePreferenceRefCreateWithoutPreferenceInput, MenteePreferenceRefUncheckedCreateWithoutPreferenceInput> | MenteePreferenceRefCreateWithoutPreferenceInput[] | MenteePreferenceRefUncheckedCreateWithoutPreferenceInput[]
    connectOrCreate?: MenteePreferenceRefCreateOrConnectWithoutPreferenceInput | MenteePreferenceRefCreateOrConnectWithoutPreferenceInput[]
    createMany?: MenteePreferenceRefCreateManyPreferenceInputEnvelope
    connect?: MenteePreferenceRefWhereUniqueInput | MenteePreferenceRefWhereUniqueInput[]
  }

  export type MenteePreferenceRefUncheckedCreateNestedManyWithoutPreferenceInput = {
    create?: XOR<MenteePreferenceRefCreateWithoutPreferenceInput, MenteePreferenceRefUncheckedCreateWithoutPreferenceInput> | MenteePreferenceRefCreateWithoutPreferenceInput[] | MenteePreferenceRefUncheckedCreateWithoutPreferenceInput[]
    connectOrCreate?: MenteePreferenceRefCreateOrConnectWithoutPreferenceInput | MenteePreferenceRefCreateOrConnectWithoutPreferenceInput[]
    createMany?: MenteePreferenceRefCreateManyPreferenceInputEnvelope
    connect?: MenteePreferenceRefWhereUniqueInput | MenteePreferenceRefWhereUniqueInput[]
  }

  export type MenteePreferenceRefUpdateManyWithoutPreferenceNestedInput = {
    create?: XOR<MenteePreferenceRefCreateWithoutPreferenceInput, MenteePreferenceRefUncheckedCreateWithoutPreferenceInput> | MenteePreferenceRefCreateWithoutPreferenceInput[] | MenteePreferenceRefUncheckedCreateWithoutPreferenceInput[]
    connectOrCreate?: MenteePreferenceRefCreateOrConnectWithoutPreferenceInput | MenteePreferenceRefCreateOrConnectWithoutPreferenceInput[]
    upsert?: MenteePreferenceRefUpsertWithWhereUniqueWithoutPreferenceInput | MenteePreferenceRefUpsertWithWhereUniqueWithoutPreferenceInput[]
    createMany?: MenteePreferenceRefCreateManyPreferenceInputEnvelope
    set?: MenteePreferenceRefWhereUniqueInput | MenteePreferenceRefWhereUniqueInput[]
    disconnect?: MenteePreferenceRefWhereUniqueInput | MenteePreferenceRefWhereUniqueInput[]
    delete?: MenteePreferenceRefWhereUniqueInput | MenteePreferenceRefWhereUniqueInput[]
    connect?: MenteePreferenceRefWhereUniqueInput | MenteePreferenceRefWhereUniqueInput[]
    update?: MenteePreferenceRefUpdateWithWhereUniqueWithoutPreferenceInput | MenteePreferenceRefUpdateWithWhereUniqueWithoutPreferenceInput[]
    updateMany?: MenteePreferenceRefUpdateManyWithWhereWithoutPreferenceInput | MenteePreferenceRefUpdateManyWithWhereWithoutPreferenceInput[]
    deleteMany?: MenteePreferenceRefScalarWhereInput | MenteePreferenceRefScalarWhereInput[]
  }

  export type MenteePreferenceRefUncheckedUpdateManyWithoutPreferenceNestedInput = {
    create?: XOR<MenteePreferenceRefCreateWithoutPreferenceInput, MenteePreferenceRefUncheckedCreateWithoutPreferenceInput> | MenteePreferenceRefCreateWithoutPreferenceInput[] | MenteePreferenceRefUncheckedCreateWithoutPreferenceInput[]
    connectOrCreate?: MenteePreferenceRefCreateOrConnectWithoutPreferenceInput | MenteePreferenceRefCreateOrConnectWithoutPreferenceInput[]
    upsert?: MenteePreferenceRefUpsertWithWhereUniqueWithoutPreferenceInput | MenteePreferenceRefUpsertWithWhereUniqueWithoutPreferenceInput[]
    createMany?: MenteePreferenceRefCreateManyPreferenceInputEnvelope
    set?: MenteePreferenceRefWhereUniqueInput | MenteePreferenceRefWhereUniqueInput[]
    disconnect?: MenteePreferenceRefWhereUniqueInput | MenteePreferenceRefWhereUniqueInput[]
    delete?: MenteePreferenceRefWhereUniqueInput | MenteePreferenceRefWhereUniqueInput[]
    connect?: MenteePreferenceRefWhereUniqueInput | MenteePreferenceRefWhereUniqueInput[]
    update?: MenteePreferenceRefUpdateWithWhereUniqueWithoutPreferenceInput | MenteePreferenceRefUpdateWithWhereUniqueWithoutPreferenceInput[]
    updateMany?: MenteePreferenceRefUpdateManyWithWhereWithoutPreferenceInput | MenteePreferenceRefUpdateManyWithWhereWithoutPreferenceInput[]
    deleteMany?: MenteePreferenceRefScalarWhereInput | MenteePreferenceRefScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMentee_languagesInput = {
    create?: XOR<UserCreateWithoutMentee_languagesInput, UserUncheckedCreateWithoutMentee_languagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentee_languagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMentee_languagesNestedInput = {
    create?: XOR<UserCreateWithoutMentee_languagesInput, UserUncheckedCreateWithoutMentee_languagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentee_languagesInput
    upsert?: UserUpsertWithoutMentee_languagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMentee_languagesInput, UserUpdateWithoutMentee_languagesInput>, UserUncheckedUpdateWithoutMentee_languagesInput>
  }

  export type UserCreateNestedOneWithoutMentee_interestsInput = {
    create?: XOR<UserCreateWithoutMentee_interestsInput, UserUncheckedCreateWithoutMentee_interestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentee_interestsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMentee_interestsNestedInput = {
    create?: XOR<UserCreateWithoutMentee_interestsInput, UserUncheckedCreateWithoutMentee_interestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentee_interestsInput
    upsert?: UserUpsertWithoutMentee_interestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMentee_interestsInput, UserUpdateWithoutMentee_interestsInput>, UserUncheckedUpdateWithoutMentee_interestsInput>
  }

  export type UserCreateNestedOneWithoutMentee_prioritiesInput = {
    create?: XOR<UserCreateWithoutMentee_prioritiesInput, UserUncheckedCreateWithoutMentee_prioritiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentee_prioritiesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMentee_prioritiesNestedInput = {
    create?: XOR<UserCreateWithoutMentee_prioritiesInput, UserUncheckedCreateWithoutMentee_prioritiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentee_prioritiesInput
    upsert?: UserUpsertWithoutMentee_prioritiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMentee_prioritiesInput, UserUpdateWithoutMentee_prioritiesInput>, UserUncheckedUpdateWithoutMentee_prioritiesInput>
  }

  export type UserCreateNestedOneWithoutMentor_languagesInput = {
    create?: XOR<UserCreateWithoutMentor_languagesInput, UserUncheckedCreateWithoutMentor_languagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentor_languagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMentor_languagesNestedInput = {
    create?: XOR<UserCreateWithoutMentor_languagesInput, UserUncheckedCreateWithoutMentor_languagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentor_languagesInput
    upsert?: UserUpsertWithoutMentor_languagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMentor_languagesInput, UserUpdateWithoutMentor_languagesInput>, UserUncheckedUpdateWithoutMentor_languagesInput>
  }

  export type UserCreateNestedOneWithoutMentor_categoriesInput = {
    create?: XOR<UserCreateWithoutMentor_categoriesInput, UserUncheckedCreateWithoutMentor_categoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentor_categoriesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMentor_categoriesNestedInput = {
    create?: XOR<UserCreateWithoutMentor_categoriesInput, UserUncheckedCreateWithoutMentor_categoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentor_categoriesInput
    upsert?: UserUpsertWithoutMentor_categoriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMentor_categoriesInput, UserUpdateWithoutMentor_categoriesInput>, UserUncheckedUpdateWithoutMentor_categoriesInput>
  }

  export type UserCreateNestedOneWithoutMentor_skillsInput = {
    create?: XOR<UserCreateWithoutMentor_skillsInput, UserUncheckedCreateWithoutMentor_skillsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentor_skillsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMentor_skillsNestedInput = {
    create?: XOR<UserCreateWithoutMentor_skillsInput, UserUncheckedCreateWithoutMentor_skillsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentor_skillsInput
    upsert?: UserUpsertWithoutMentor_skillsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMentor_skillsInput, UserUpdateWithoutMentor_skillsInput>, UserUncheckedUpdateWithoutMentor_skillsInput>
  }

  export type UserCreateNestedOneWithoutMentee_service_focusInput = {
    create?: XOR<UserCreateWithoutMentee_service_focusInput, UserUncheckedCreateWithoutMentee_service_focusInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentee_service_focusInput
    connect?: UserWhereUniqueInput
  }

  export type ServiceFocusRefCreateNestedOneWithoutMentee_service_focusInput = {
    create?: XOR<ServiceFocusRefCreateWithoutMentee_service_focusInput, ServiceFocusRefUncheckedCreateWithoutMentee_service_focusInput>
    connectOrCreate?: ServiceFocusRefCreateOrConnectWithoutMentee_service_focusInput
    connect?: ServiceFocusRefWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMentee_service_focusNestedInput = {
    create?: XOR<UserCreateWithoutMentee_service_focusInput, UserUncheckedCreateWithoutMentee_service_focusInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentee_service_focusInput
    upsert?: UserUpsertWithoutMentee_service_focusInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMentee_service_focusInput, UserUpdateWithoutMentee_service_focusInput>, UserUncheckedUpdateWithoutMentee_service_focusInput>
  }

  export type ServiceFocusRefUpdateOneRequiredWithoutMentee_service_focusNestedInput = {
    create?: XOR<ServiceFocusRefCreateWithoutMentee_service_focusInput, ServiceFocusRefUncheckedCreateWithoutMentee_service_focusInput>
    connectOrCreate?: ServiceFocusRefCreateOrConnectWithoutMentee_service_focusInput
    upsert?: ServiceFocusRefUpsertWithoutMentee_service_focusInput
    connect?: ServiceFocusRefWhereUniqueInput
    update?: XOR<XOR<ServiceFocusRefUpdateToOneWithWhereWithoutMentee_service_focusInput, ServiceFocusRefUpdateWithoutMentee_service_focusInput>, ServiceFocusRefUncheckedUpdateWithoutMentee_service_focusInput>
  }

  export type UserCreateNestedOneWithoutMentee_languages_refInput = {
    create?: XOR<UserCreateWithoutMentee_languages_refInput, UserUncheckedCreateWithoutMentee_languages_refInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentee_languages_refInput
    connect?: UserWhereUniqueInput
  }

  export type LanguageRefCreateNestedOneWithoutMentee_languages_refInput = {
    create?: XOR<LanguageRefCreateWithoutMentee_languages_refInput, LanguageRefUncheckedCreateWithoutMentee_languages_refInput>
    connectOrCreate?: LanguageRefCreateOrConnectWithoutMentee_languages_refInput
    connect?: LanguageRefWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMentee_languages_refNestedInput = {
    create?: XOR<UserCreateWithoutMentee_languages_refInput, UserUncheckedCreateWithoutMentee_languages_refInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentee_languages_refInput
    upsert?: UserUpsertWithoutMentee_languages_refInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMentee_languages_refInput, UserUpdateWithoutMentee_languages_refInput>, UserUncheckedUpdateWithoutMentee_languages_refInput>
  }

  export type LanguageRefUpdateOneRequiredWithoutMentee_languages_refNestedInput = {
    create?: XOR<LanguageRefCreateWithoutMentee_languages_refInput, LanguageRefUncheckedCreateWithoutMentee_languages_refInput>
    connectOrCreate?: LanguageRefCreateOrConnectWithoutMentee_languages_refInput
    upsert?: LanguageRefUpsertWithoutMentee_languages_refInput
    connect?: LanguageRefWhereUniqueInput
    update?: XOR<XOR<LanguageRefUpdateToOneWithWhereWithoutMentee_languages_refInput, LanguageRefUpdateWithoutMentee_languages_refInput>, LanguageRefUncheckedUpdateWithoutMentee_languages_refInput>
  }

  export type UserCreateNestedOneWithoutMentee_disciplines_refInput = {
    create?: XOR<UserCreateWithoutMentee_disciplines_refInput, UserUncheckedCreateWithoutMentee_disciplines_refInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentee_disciplines_refInput
    connect?: UserWhereUniqueInput
  }

  export type DisciplineRefCreateNestedOneWithoutMentee_disciplines_refInput = {
    create?: XOR<DisciplineRefCreateWithoutMentee_disciplines_refInput, DisciplineRefUncheckedCreateWithoutMentee_disciplines_refInput>
    connectOrCreate?: DisciplineRefCreateOrConnectWithoutMentee_disciplines_refInput
    connect?: DisciplineRefWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMentee_disciplines_refNestedInput = {
    create?: XOR<UserCreateWithoutMentee_disciplines_refInput, UserUncheckedCreateWithoutMentee_disciplines_refInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentee_disciplines_refInput
    upsert?: UserUpsertWithoutMentee_disciplines_refInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMentee_disciplines_refInput, UserUpdateWithoutMentee_disciplines_refInput>, UserUncheckedUpdateWithoutMentee_disciplines_refInput>
  }

  export type DisciplineRefUpdateOneRequiredWithoutMentee_disciplines_refNestedInput = {
    create?: XOR<DisciplineRefCreateWithoutMentee_disciplines_refInput, DisciplineRefUncheckedCreateWithoutMentee_disciplines_refInput>
    connectOrCreate?: DisciplineRefCreateOrConnectWithoutMentee_disciplines_refInput
    upsert?: DisciplineRefUpsertWithoutMentee_disciplines_refInput
    connect?: DisciplineRefWhereUniqueInput
    update?: XOR<XOR<DisciplineRefUpdateToOneWithWhereWithoutMentee_disciplines_refInput, DisciplineRefUpdateWithoutMentee_disciplines_refInput>, DisciplineRefUncheckedUpdateWithoutMentee_disciplines_refInput>
  }

  export type UserCreateNestedOneWithoutMentee_preferences_refInput = {
    create?: XOR<UserCreateWithoutMentee_preferences_refInput, UserUncheckedCreateWithoutMentee_preferences_refInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentee_preferences_refInput
    connect?: UserWhereUniqueInput
  }

  export type PreferenceRefCreateNestedOneWithoutMentee_preferences_refInput = {
    create?: XOR<PreferenceRefCreateWithoutMentee_preferences_refInput, PreferenceRefUncheckedCreateWithoutMentee_preferences_refInput>
    connectOrCreate?: PreferenceRefCreateOrConnectWithoutMentee_preferences_refInput
    connect?: PreferenceRefWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMentee_preferences_refNestedInput = {
    create?: XOR<UserCreateWithoutMentee_preferences_refInput, UserUncheckedCreateWithoutMentee_preferences_refInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentee_preferences_refInput
    upsert?: UserUpsertWithoutMentee_preferences_refInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMentee_preferences_refInput, UserUpdateWithoutMentee_preferences_refInput>, UserUncheckedUpdateWithoutMentee_preferences_refInput>
  }

  export type PreferenceRefUpdateOneRequiredWithoutMentee_preferences_refNestedInput = {
    create?: XOR<PreferenceRefCreateWithoutMentee_preferences_refInput, PreferenceRefUncheckedCreateWithoutMentee_preferences_refInput>
    connectOrCreate?: PreferenceRefCreateOrConnectWithoutMentee_preferences_refInput
    upsert?: PreferenceRefUpsertWithoutMentee_preferences_refInput
    connect?: PreferenceRefWhereUniqueInput
    update?: XOR<XOR<PreferenceRefUpdateToOneWithWhereWithoutMentee_preferences_refInput, PreferenceRefUpdateWithoutMentee_preferences_refInput>, PreferenceRefUncheckedUpdateWithoutMentee_preferences_refInput>
  }

  export type MentorCompanyMembershipCreateNestedManyWithoutCompanyInput = {
    create?: XOR<MentorCompanyMembershipCreateWithoutCompanyInput, MentorCompanyMembershipUncheckedCreateWithoutCompanyInput> | MentorCompanyMembershipCreateWithoutCompanyInput[] | MentorCompanyMembershipUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: MentorCompanyMembershipCreateOrConnectWithoutCompanyInput | MentorCompanyMembershipCreateOrConnectWithoutCompanyInput[]
    createMany?: MentorCompanyMembershipCreateManyCompanyInputEnvelope
    connect?: MentorCompanyMembershipWhereUniqueInput | MentorCompanyMembershipWhereUniqueInput[]
  }

  export type MentorCompanyMembershipUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<MentorCompanyMembershipCreateWithoutCompanyInput, MentorCompanyMembershipUncheckedCreateWithoutCompanyInput> | MentorCompanyMembershipCreateWithoutCompanyInput[] | MentorCompanyMembershipUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: MentorCompanyMembershipCreateOrConnectWithoutCompanyInput | MentorCompanyMembershipCreateOrConnectWithoutCompanyInput[]
    createMany?: MentorCompanyMembershipCreateManyCompanyInputEnvelope
    connect?: MentorCompanyMembershipWhereUniqueInput | MentorCompanyMembershipWhereUniqueInput[]
  }

  export type MentorCompanyMembershipUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<MentorCompanyMembershipCreateWithoutCompanyInput, MentorCompanyMembershipUncheckedCreateWithoutCompanyInput> | MentorCompanyMembershipCreateWithoutCompanyInput[] | MentorCompanyMembershipUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: MentorCompanyMembershipCreateOrConnectWithoutCompanyInput | MentorCompanyMembershipCreateOrConnectWithoutCompanyInput[]
    upsert?: MentorCompanyMembershipUpsertWithWhereUniqueWithoutCompanyInput | MentorCompanyMembershipUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: MentorCompanyMembershipCreateManyCompanyInputEnvelope
    set?: MentorCompanyMembershipWhereUniqueInput | MentorCompanyMembershipWhereUniqueInput[]
    disconnect?: MentorCompanyMembershipWhereUniqueInput | MentorCompanyMembershipWhereUniqueInput[]
    delete?: MentorCompanyMembershipWhereUniqueInput | MentorCompanyMembershipWhereUniqueInput[]
    connect?: MentorCompanyMembershipWhereUniqueInput | MentorCompanyMembershipWhereUniqueInput[]
    update?: MentorCompanyMembershipUpdateWithWhereUniqueWithoutCompanyInput | MentorCompanyMembershipUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: MentorCompanyMembershipUpdateManyWithWhereWithoutCompanyInput | MentorCompanyMembershipUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: MentorCompanyMembershipScalarWhereInput | MentorCompanyMembershipScalarWhereInput[]
  }

  export type MentorCompanyMembershipUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<MentorCompanyMembershipCreateWithoutCompanyInput, MentorCompanyMembershipUncheckedCreateWithoutCompanyInput> | MentorCompanyMembershipCreateWithoutCompanyInput[] | MentorCompanyMembershipUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: MentorCompanyMembershipCreateOrConnectWithoutCompanyInput | MentorCompanyMembershipCreateOrConnectWithoutCompanyInput[]
    upsert?: MentorCompanyMembershipUpsertWithWhereUniqueWithoutCompanyInput | MentorCompanyMembershipUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: MentorCompanyMembershipCreateManyCompanyInputEnvelope
    set?: MentorCompanyMembershipWhereUniqueInput | MentorCompanyMembershipWhereUniqueInput[]
    disconnect?: MentorCompanyMembershipWhereUniqueInput | MentorCompanyMembershipWhereUniqueInput[]
    delete?: MentorCompanyMembershipWhereUniqueInput | MentorCompanyMembershipWhereUniqueInput[]
    connect?: MentorCompanyMembershipWhereUniqueInput | MentorCompanyMembershipWhereUniqueInput[]
    update?: MentorCompanyMembershipUpdateWithWhereUniqueWithoutCompanyInput | MentorCompanyMembershipUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: MentorCompanyMembershipUpdateManyWithWhereWithoutCompanyInput | MentorCompanyMembershipUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: MentorCompanyMembershipScalarWhereInput | MentorCompanyMembershipScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMentor_company_membershipInput = {
    create?: XOR<UserCreateWithoutMentor_company_membershipInput, UserUncheckedCreateWithoutMentor_company_membershipInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentor_company_membershipInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutMentor_company_membershipInput = {
    create?: XOR<CompanyCreateWithoutMentor_company_membershipInput, CompanyUncheckedCreateWithoutMentor_company_membershipInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutMentor_company_membershipInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMentor_company_membershipNestedInput = {
    create?: XOR<UserCreateWithoutMentor_company_membershipInput, UserUncheckedCreateWithoutMentor_company_membershipInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentor_company_membershipInput
    upsert?: UserUpsertWithoutMentor_company_membershipInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMentor_company_membershipInput, UserUpdateWithoutMentor_company_membershipInput>, UserUncheckedUpdateWithoutMentor_company_membershipInput>
  }

  export type CompanyUpdateOneRequiredWithoutMentor_company_membershipNestedInput = {
    create?: XOR<CompanyCreateWithoutMentor_company_membershipInput, CompanyUncheckedCreateWithoutMentor_company_membershipInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutMentor_company_membershipInput
    upsert?: CompanyUpsertWithoutMentor_company_membershipInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutMentor_company_membershipInput, CompanyUpdateWithoutMentor_company_membershipInput>, CompanyUncheckedUpdateWithoutMentor_company_membershipInput>
  }

  export type UserCreateNestedOneWithoutUser_consentInput = {
    create?: XOR<UserCreateWithoutUser_consentInput, UserUncheckedCreateWithoutUser_consentInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_consentInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUser_consentNestedInput = {
    create?: XOR<UserCreateWithoutUser_consentInput, UserUncheckedCreateWithoutUser_consentInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_consentInput
    upsert?: UserUpsertWithoutUser_consentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUser_consentInput, UserUpdateWithoutUser_consentInput>, UserUncheckedUpdateWithoutUser_consentInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumMentorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MentorType | EnumMentorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MentorType[] | ListEnumMentorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MentorType[] | ListEnumMentorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMentorTypeFilter<$PrismaModel> | $Enums.MentorType
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumMentorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MentorStatus | EnumMentorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MentorStatus[] | ListEnumMentorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MentorStatus[] | ListEnumMentorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMentorStatusFilter<$PrismaModel> | $Enums.MentorStatus
  }

  export type NestedEnumMentorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MentorType | EnumMentorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MentorType[] | ListEnumMentorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MentorType[] | ListEnumMentorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMentorTypeWithAggregatesFilter<$PrismaModel> | $Enums.MentorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMentorTypeFilter<$PrismaModel>
    _max?: NestedEnumMentorTypeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumMentorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MentorStatus | EnumMentorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MentorStatus[] | ListEnumMentorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MentorStatus[] | ListEnumMentorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMentorStatusWithAggregatesFilter<$PrismaModel> | $Enums.MentorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMentorStatusFilter<$PrismaModel>
    _max?: NestedEnumMentorStatusFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type MenteeCreateWithoutUserInput = {
    short_goal: string
    target_track: string
    budget: string
    time_preference: string
    city?: string | null
    country?: string
    goal_type?: string | null
    service_focus?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MenteeUncheckedCreateWithoutUserInput = {
    short_goal: string
    target_track: string
    budget: string
    time_preference: string
    city?: string | null
    country?: string
    goal_type?: string | null
    service_focus?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MenteeCreateOrConnectWithoutUserInput = {
    where: MenteeWhereUniqueInput
    create: XOR<MenteeCreateWithoutUserInput, MenteeUncheckedCreateWithoutUserInput>
  }

  export type MentorCreateWithoutUserInput = {
    mentor_type: $Enums.MentorType
    display_name: string
    title: string
    years_experience?: number
    hourly_rate_cents: number
    meeting_preference: string
    bio_short: string
    bio_long: string
    city?: string | null
    country?: string
    rating_avg?: Decimal | DecimalJsLike | number | string
    total_reviews?: number
    status?: $Enums.MentorStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MentorUncheckedCreateWithoutUserInput = {
    mentor_type: $Enums.MentorType
    display_name: string
    title: string
    years_experience?: number
    hourly_rate_cents: number
    meeting_preference: string
    bio_short: string
    bio_long: string
    city?: string | null
    country?: string
    rating_avg?: Decimal | DecimalJsLike | number | string
    total_reviews?: number
    status?: $Enums.MentorStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MentorCreateOrConnectWithoutUserInput = {
    where: MentorWhereUniqueInput
    create: XOR<MentorCreateWithoutUserInput, MentorUncheckedCreateWithoutUserInput>
  }

  export type UserConsentCreateWithoutUserInput = {
    kvkk_accepted_at: Date | string
    kvkk_version?: string | null
    ip_address?: string | null
    marketing_opt_in?: boolean
    created_at?: Date | string
  }

  export type UserConsentUncheckedCreateWithoutUserInput = {
    kvkk_accepted_at: Date | string
    kvkk_version?: string | null
    ip_address?: string | null
    marketing_opt_in?: boolean
    created_at?: Date | string
  }

  export type UserConsentCreateOrConnectWithoutUserInput = {
    where: UserConsentWhereUniqueInput
    create: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput>
  }

  export type MenteeLanguageCreateWithoutUserInput = {
    lang_code: string
  }

  export type MenteeLanguageUncheckedCreateWithoutUserInput = {
    lang_code: string
  }

  export type MenteeLanguageCreateOrConnectWithoutUserInput = {
    where: MenteeLanguageWhereUniqueInput
    create: XOR<MenteeLanguageCreateWithoutUserInput, MenteeLanguageUncheckedCreateWithoutUserInput>
  }

  export type MenteeLanguageCreateManyUserInputEnvelope = {
    data: MenteeLanguageCreateManyUserInput | MenteeLanguageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MenteeInterestCreateWithoutUserInput = {
    interest: string
    created_at?: Date | string
  }

  export type MenteeInterestUncheckedCreateWithoutUserInput = {
    interest: string
    created_at?: Date | string
  }

  export type MenteeInterestCreateOrConnectWithoutUserInput = {
    where: MenteeInterestWhereUniqueInput
    create: XOR<MenteeInterestCreateWithoutUserInput, MenteeInterestUncheckedCreateWithoutUserInput>
  }

  export type MenteeInterestCreateManyUserInputEnvelope = {
    data: MenteeInterestCreateManyUserInput | MenteeInterestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MenteePriorityCreateWithoutUserInput = {
    priority: string
    created_at?: Date | string
  }

  export type MenteePriorityUncheckedCreateWithoutUserInput = {
    priority: string
    created_at?: Date | string
  }

  export type MenteePriorityCreateOrConnectWithoutUserInput = {
    where: MenteePriorityWhereUniqueInput
    create: XOR<MenteePriorityCreateWithoutUserInput, MenteePriorityUncheckedCreateWithoutUserInput>
  }

  export type MenteePriorityCreateManyUserInputEnvelope = {
    data: MenteePriorityCreateManyUserInput | MenteePriorityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MentorLanguageCreateWithoutUserInput = {
    lang_code: string
  }

  export type MentorLanguageUncheckedCreateWithoutUserInput = {
    lang_code: string
  }

  export type MentorLanguageCreateOrConnectWithoutUserInput = {
    where: MentorLanguageWhereUniqueInput
    create: XOR<MentorLanguageCreateWithoutUserInput, MentorLanguageUncheckedCreateWithoutUserInput>
  }

  export type MentorLanguageCreateManyUserInputEnvelope = {
    data: MentorLanguageCreateManyUserInput | MentorLanguageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MentorCategoryCreateWithoutUserInput = {
    category: string
  }

  export type MentorCategoryUncheckedCreateWithoutUserInput = {
    category: string
  }

  export type MentorCategoryCreateOrConnectWithoutUserInput = {
    where: MentorCategoryWhereUniqueInput
    create: XOR<MentorCategoryCreateWithoutUserInput, MentorCategoryUncheckedCreateWithoutUserInput>
  }

  export type MentorCategoryCreateManyUserInputEnvelope = {
    data: MentorCategoryCreateManyUserInput | MentorCategoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MentorSkillCreateWithoutUserInput = {
    skill: string
  }

  export type MentorSkillUncheckedCreateWithoutUserInput = {
    skill: string
  }

  export type MentorSkillCreateOrConnectWithoutUserInput = {
    where: MentorSkillWhereUniqueInput
    create: XOR<MentorSkillCreateWithoutUserInput, MentorSkillUncheckedCreateWithoutUserInput>
  }

  export type MentorSkillCreateManyUserInputEnvelope = {
    data: MentorSkillCreateManyUserInput | MentorSkillCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MenteeServiceFocusCreateWithoutUserInput = {
    service_focus: ServiceFocusRefCreateNestedOneWithoutMentee_service_focusInput
  }

  export type MenteeServiceFocusUncheckedCreateWithoutUserInput = {
    service_focus_id: string
  }

  export type MenteeServiceFocusCreateOrConnectWithoutUserInput = {
    where: MenteeServiceFocusWhereUniqueInput
    create: XOR<MenteeServiceFocusCreateWithoutUserInput, MenteeServiceFocusUncheckedCreateWithoutUserInput>
  }

  export type MenteeServiceFocusCreateManyUserInputEnvelope = {
    data: MenteeServiceFocusCreateManyUserInput | MenteeServiceFocusCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MenteeLanguageRefCreateWithoutUserInput = {
    language: LanguageRefCreateNestedOneWithoutMentee_languages_refInput
  }

  export type MenteeLanguageRefUncheckedCreateWithoutUserInput = {
    language_id: string
  }

  export type MenteeLanguageRefCreateOrConnectWithoutUserInput = {
    where: MenteeLanguageRefWhereUniqueInput
    create: XOR<MenteeLanguageRefCreateWithoutUserInput, MenteeLanguageRefUncheckedCreateWithoutUserInput>
  }

  export type MenteeLanguageRefCreateManyUserInputEnvelope = {
    data: MenteeLanguageRefCreateManyUserInput | MenteeLanguageRefCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MenteeDisciplineRefCreateWithoutUserInput = {
    discipline: DisciplineRefCreateNestedOneWithoutMentee_disciplines_refInput
  }

  export type MenteeDisciplineRefUncheckedCreateWithoutUserInput = {
    discipline_id: string
  }

  export type MenteeDisciplineRefCreateOrConnectWithoutUserInput = {
    where: MenteeDisciplineRefWhereUniqueInput
    create: XOR<MenteeDisciplineRefCreateWithoutUserInput, MenteeDisciplineRefUncheckedCreateWithoutUserInput>
  }

  export type MenteeDisciplineRefCreateManyUserInputEnvelope = {
    data: MenteeDisciplineRefCreateManyUserInput | MenteeDisciplineRefCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MenteePreferenceRefCreateWithoutUserInput = {
    preference: PreferenceRefCreateNestedOneWithoutMentee_preferences_refInput
  }

  export type MenteePreferenceRefUncheckedCreateWithoutUserInput = {
    preference_id: string
  }

  export type MenteePreferenceRefCreateOrConnectWithoutUserInput = {
    where: MenteePreferenceRefWhereUniqueInput
    create: XOR<MenteePreferenceRefCreateWithoutUserInput, MenteePreferenceRefUncheckedCreateWithoutUserInput>
  }

  export type MenteePreferenceRefCreateManyUserInputEnvelope = {
    data: MenteePreferenceRefCreateManyUserInput | MenteePreferenceRefCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MentorCompanyMembershipCreateWithoutUserInput = {
    role_title?: string | null
    work_email?: string | null
    created_at?: Date | string
    company: CompanyCreateNestedOneWithoutMentor_company_membershipInput
  }

  export type MentorCompanyMembershipUncheckedCreateWithoutUserInput = {
    company_id: string
    role_title?: string | null
    work_email?: string | null
    created_at?: Date | string
  }

  export type MentorCompanyMembershipCreateOrConnectWithoutUserInput = {
    where: MentorCompanyMembershipWhereUniqueInput
    create: XOR<MentorCompanyMembershipCreateWithoutUserInput, MentorCompanyMembershipUncheckedCreateWithoutUserInput>
  }

  export type MentorCompanyMembershipCreateManyUserInputEnvelope = {
    data: MentorCompanyMembershipCreateManyUserInput | MentorCompanyMembershipCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MenteeUpsertWithoutUserInput = {
    update: XOR<MenteeUpdateWithoutUserInput, MenteeUncheckedUpdateWithoutUserInput>
    create: XOR<MenteeCreateWithoutUserInput, MenteeUncheckedCreateWithoutUserInput>
    where?: MenteeWhereInput
  }

  export type MenteeUpdateToOneWithWhereWithoutUserInput = {
    where?: MenteeWhereInput
    data: XOR<MenteeUpdateWithoutUserInput, MenteeUncheckedUpdateWithoutUserInput>
  }

  export type MenteeUpdateWithoutUserInput = {
    short_goal?: StringFieldUpdateOperationsInput | string
    target_track?: StringFieldUpdateOperationsInput | string
    budget?: StringFieldUpdateOperationsInput | string
    time_preference?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    goal_type?: NullableStringFieldUpdateOperationsInput | string | null
    service_focus?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenteeUncheckedUpdateWithoutUserInput = {
    short_goal?: StringFieldUpdateOperationsInput | string
    target_track?: StringFieldUpdateOperationsInput | string
    budget?: StringFieldUpdateOperationsInput | string
    time_preference?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    goal_type?: NullableStringFieldUpdateOperationsInput | string | null
    service_focus?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentorUpsertWithoutUserInput = {
    update: XOR<MentorUpdateWithoutUserInput, MentorUncheckedUpdateWithoutUserInput>
    create: XOR<MentorCreateWithoutUserInput, MentorUncheckedCreateWithoutUserInput>
    where?: MentorWhereInput
  }

  export type MentorUpdateToOneWithWhereWithoutUserInput = {
    where?: MentorWhereInput
    data: XOR<MentorUpdateWithoutUserInput, MentorUncheckedUpdateWithoutUserInput>
  }

  export type MentorUpdateWithoutUserInput = {
    mentor_type?: EnumMentorTypeFieldUpdateOperationsInput | $Enums.MentorType
    display_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    years_experience?: IntFieldUpdateOperationsInput | number
    hourly_rate_cents?: IntFieldUpdateOperationsInput | number
    meeting_preference?: StringFieldUpdateOperationsInput | string
    bio_short?: StringFieldUpdateOperationsInput | string
    bio_long?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_reviews?: IntFieldUpdateOperationsInput | number
    status?: EnumMentorStatusFieldUpdateOperationsInput | $Enums.MentorStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentorUncheckedUpdateWithoutUserInput = {
    mentor_type?: EnumMentorTypeFieldUpdateOperationsInput | $Enums.MentorType
    display_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    years_experience?: IntFieldUpdateOperationsInput | number
    hourly_rate_cents?: IntFieldUpdateOperationsInput | number
    meeting_preference?: StringFieldUpdateOperationsInput | string
    bio_short?: StringFieldUpdateOperationsInput | string
    bio_long?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_reviews?: IntFieldUpdateOperationsInput | number
    status?: EnumMentorStatusFieldUpdateOperationsInput | $Enums.MentorStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConsentUpsertWithoutUserInput = {
    update: XOR<UserConsentUpdateWithoutUserInput, UserConsentUncheckedUpdateWithoutUserInput>
    create: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput>
    where?: UserConsentWhereInput
  }

  export type UserConsentUpdateToOneWithWhereWithoutUserInput = {
    where?: UserConsentWhereInput
    data: XOR<UserConsentUpdateWithoutUserInput, UserConsentUncheckedUpdateWithoutUserInput>
  }

  export type UserConsentUpdateWithoutUserInput = {
    kvkk_accepted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kvkk_version?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    marketing_opt_in?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConsentUncheckedUpdateWithoutUserInput = {
    kvkk_accepted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kvkk_version?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    marketing_opt_in?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenteeLanguageUpsertWithWhereUniqueWithoutUserInput = {
    where: MenteeLanguageWhereUniqueInput
    update: XOR<MenteeLanguageUpdateWithoutUserInput, MenteeLanguageUncheckedUpdateWithoutUserInput>
    create: XOR<MenteeLanguageCreateWithoutUserInput, MenteeLanguageUncheckedCreateWithoutUserInput>
  }

  export type MenteeLanguageUpdateWithWhereUniqueWithoutUserInput = {
    where: MenteeLanguageWhereUniqueInput
    data: XOR<MenteeLanguageUpdateWithoutUserInput, MenteeLanguageUncheckedUpdateWithoutUserInput>
  }

  export type MenteeLanguageUpdateManyWithWhereWithoutUserInput = {
    where: MenteeLanguageScalarWhereInput
    data: XOR<MenteeLanguageUpdateManyMutationInput, MenteeLanguageUncheckedUpdateManyWithoutUserInput>
  }

  export type MenteeLanguageScalarWhereInput = {
    AND?: MenteeLanguageScalarWhereInput | MenteeLanguageScalarWhereInput[]
    OR?: MenteeLanguageScalarWhereInput[]
    NOT?: MenteeLanguageScalarWhereInput | MenteeLanguageScalarWhereInput[]
    user_id?: UuidFilter<"MenteeLanguage"> | string
    lang_code?: StringFilter<"MenteeLanguage"> | string
  }

  export type MenteeInterestUpsertWithWhereUniqueWithoutUserInput = {
    where: MenteeInterestWhereUniqueInput
    update: XOR<MenteeInterestUpdateWithoutUserInput, MenteeInterestUncheckedUpdateWithoutUserInput>
    create: XOR<MenteeInterestCreateWithoutUserInput, MenteeInterestUncheckedCreateWithoutUserInput>
  }

  export type MenteeInterestUpdateWithWhereUniqueWithoutUserInput = {
    where: MenteeInterestWhereUniqueInput
    data: XOR<MenteeInterestUpdateWithoutUserInput, MenteeInterestUncheckedUpdateWithoutUserInput>
  }

  export type MenteeInterestUpdateManyWithWhereWithoutUserInput = {
    where: MenteeInterestScalarWhereInput
    data: XOR<MenteeInterestUpdateManyMutationInput, MenteeInterestUncheckedUpdateManyWithoutUserInput>
  }

  export type MenteeInterestScalarWhereInput = {
    AND?: MenteeInterestScalarWhereInput | MenteeInterestScalarWhereInput[]
    OR?: MenteeInterestScalarWhereInput[]
    NOT?: MenteeInterestScalarWhereInput | MenteeInterestScalarWhereInput[]
    user_id?: UuidFilter<"MenteeInterest"> | string
    interest?: StringFilter<"MenteeInterest"> | string
    created_at?: DateTimeFilter<"MenteeInterest"> | Date | string
  }

  export type MenteePriorityUpsertWithWhereUniqueWithoutUserInput = {
    where: MenteePriorityWhereUniqueInput
    update: XOR<MenteePriorityUpdateWithoutUserInput, MenteePriorityUncheckedUpdateWithoutUserInput>
    create: XOR<MenteePriorityCreateWithoutUserInput, MenteePriorityUncheckedCreateWithoutUserInput>
  }

  export type MenteePriorityUpdateWithWhereUniqueWithoutUserInput = {
    where: MenteePriorityWhereUniqueInput
    data: XOR<MenteePriorityUpdateWithoutUserInput, MenteePriorityUncheckedUpdateWithoutUserInput>
  }

  export type MenteePriorityUpdateManyWithWhereWithoutUserInput = {
    where: MenteePriorityScalarWhereInput
    data: XOR<MenteePriorityUpdateManyMutationInput, MenteePriorityUncheckedUpdateManyWithoutUserInput>
  }

  export type MenteePriorityScalarWhereInput = {
    AND?: MenteePriorityScalarWhereInput | MenteePriorityScalarWhereInput[]
    OR?: MenteePriorityScalarWhereInput[]
    NOT?: MenteePriorityScalarWhereInput | MenteePriorityScalarWhereInput[]
    user_id?: UuidFilter<"MenteePriority"> | string
    priority?: StringFilter<"MenteePriority"> | string
    created_at?: DateTimeFilter<"MenteePriority"> | Date | string
  }

  export type MentorLanguageUpsertWithWhereUniqueWithoutUserInput = {
    where: MentorLanguageWhereUniqueInput
    update: XOR<MentorLanguageUpdateWithoutUserInput, MentorLanguageUncheckedUpdateWithoutUserInput>
    create: XOR<MentorLanguageCreateWithoutUserInput, MentorLanguageUncheckedCreateWithoutUserInput>
  }

  export type MentorLanguageUpdateWithWhereUniqueWithoutUserInput = {
    where: MentorLanguageWhereUniqueInput
    data: XOR<MentorLanguageUpdateWithoutUserInput, MentorLanguageUncheckedUpdateWithoutUserInput>
  }

  export type MentorLanguageUpdateManyWithWhereWithoutUserInput = {
    where: MentorLanguageScalarWhereInput
    data: XOR<MentorLanguageUpdateManyMutationInput, MentorLanguageUncheckedUpdateManyWithoutUserInput>
  }

  export type MentorLanguageScalarWhereInput = {
    AND?: MentorLanguageScalarWhereInput | MentorLanguageScalarWhereInput[]
    OR?: MentorLanguageScalarWhereInput[]
    NOT?: MentorLanguageScalarWhereInput | MentorLanguageScalarWhereInput[]
    user_id?: UuidFilter<"MentorLanguage"> | string
    lang_code?: StringFilter<"MentorLanguage"> | string
  }

  export type MentorCategoryUpsertWithWhereUniqueWithoutUserInput = {
    where: MentorCategoryWhereUniqueInput
    update: XOR<MentorCategoryUpdateWithoutUserInput, MentorCategoryUncheckedUpdateWithoutUserInput>
    create: XOR<MentorCategoryCreateWithoutUserInput, MentorCategoryUncheckedCreateWithoutUserInput>
  }

  export type MentorCategoryUpdateWithWhereUniqueWithoutUserInput = {
    where: MentorCategoryWhereUniqueInput
    data: XOR<MentorCategoryUpdateWithoutUserInput, MentorCategoryUncheckedUpdateWithoutUserInput>
  }

  export type MentorCategoryUpdateManyWithWhereWithoutUserInput = {
    where: MentorCategoryScalarWhereInput
    data: XOR<MentorCategoryUpdateManyMutationInput, MentorCategoryUncheckedUpdateManyWithoutUserInput>
  }

  export type MentorCategoryScalarWhereInput = {
    AND?: MentorCategoryScalarWhereInput | MentorCategoryScalarWhereInput[]
    OR?: MentorCategoryScalarWhereInput[]
    NOT?: MentorCategoryScalarWhereInput | MentorCategoryScalarWhereInput[]
    user_id?: UuidFilter<"MentorCategory"> | string
    category?: StringFilter<"MentorCategory"> | string
  }

  export type MentorSkillUpsertWithWhereUniqueWithoutUserInput = {
    where: MentorSkillWhereUniqueInput
    update: XOR<MentorSkillUpdateWithoutUserInput, MentorSkillUncheckedUpdateWithoutUserInput>
    create: XOR<MentorSkillCreateWithoutUserInput, MentorSkillUncheckedCreateWithoutUserInput>
  }

  export type MentorSkillUpdateWithWhereUniqueWithoutUserInput = {
    where: MentorSkillWhereUniqueInput
    data: XOR<MentorSkillUpdateWithoutUserInput, MentorSkillUncheckedUpdateWithoutUserInput>
  }

  export type MentorSkillUpdateManyWithWhereWithoutUserInput = {
    where: MentorSkillScalarWhereInput
    data: XOR<MentorSkillUpdateManyMutationInput, MentorSkillUncheckedUpdateManyWithoutUserInput>
  }

  export type MentorSkillScalarWhereInput = {
    AND?: MentorSkillScalarWhereInput | MentorSkillScalarWhereInput[]
    OR?: MentorSkillScalarWhereInput[]
    NOT?: MentorSkillScalarWhereInput | MentorSkillScalarWhereInput[]
    user_id?: UuidFilter<"MentorSkill"> | string
    skill?: StringFilter<"MentorSkill"> | string
  }

  export type MenteeServiceFocusUpsertWithWhereUniqueWithoutUserInput = {
    where: MenteeServiceFocusWhereUniqueInput
    update: XOR<MenteeServiceFocusUpdateWithoutUserInput, MenteeServiceFocusUncheckedUpdateWithoutUserInput>
    create: XOR<MenteeServiceFocusCreateWithoutUserInput, MenteeServiceFocusUncheckedCreateWithoutUserInput>
  }

  export type MenteeServiceFocusUpdateWithWhereUniqueWithoutUserInput = {
    where: MenteeServiceFocusWhereUniqueInput
    data: XOR<MenteeServiceFocusUpdateWithoutUserInput, MenteeServiceFocusUncheckedUpdateWithoutUserInput>
  }

  export type MenteeServiceFocusUpdateManyWithWhereWithoutUserInput = {
    where: MenteeServiceFocusScalarWhereInput
    data: XOR<MenteeServiceFocusUpdateManyMutationInput, MenteeServiceFocusUncheckedUpdateManyWithoutUserInput>
  }

  export type MenteeServiceFocusScalarWhereInput = {
    AND?: MenteeServiceFocusScalarWhereInput | MenteeServiceFocusScalarWhereInput[]
    OR?: MenteeServiceFocusScalarWhereInput[]
    NOT?: MenteeServiceFocusScalarWhereInput | MenteeServiceFocusScalarWhereInput[]
    user_id?: UuidFilter<"MenteeServiceFocus"> | string
    service_focus_id?: StringFilter<"MenteeServiceFocus"> | string
  }

  export type MenteeLanguageRefUpsertWithWhereUniqueWithoutUserInput = {
    where: MenteeLanguageRefWhereUniqueInput
    update: XOR<MenteeLanguageRefUpdateWithoutUserInput, MenteeLanguageRefUncheckedUpdateWithoutUserInput>
    create: XOR<MenteeLanguageRefCreateWithoutUserInput, MenteeLanguageRefUncheckedCreateWithoutUserInput>
  }

  export type MenteeLanguageRefUpdateWithWhereUniqueWithoutUserInput = {
    where: MenteeLanguageRefWhereUniqueInput
    data: XOR<MenteeLanguageRefUpdateWithoutUserInput, MenteeLanguageRefUncheckedUpdateWithoutUserInput>
  }

  export type MenteeLanguageRefUpdateManyWithWhereWithoutUserInput = {
    where: MenteeLanguageRefScalarWhereInput
    data: XOR<MenteeLanguageRefUpdateManyMutationInput, MenteeLanguageRefUncheckedUpdateManyWithoutUserInput>
  }

  export type MenteeLanguageRefScalarWhereInput = {
    AND?: MenteeLanguageRefScalarWhereInput | MenteeLanguageRefScalarWhereInput[]
    OR?: MenteeLanguageRefScalarWhereInput[]
    NOT?: MenteeLanguageRefScalarWhereInput | MenteeLanguageRefScalarWhereInput[]
    user_id?: UuidFilter<"MenteeLanguageRef"> | string
    language_id?: StringFilter<"MenteeLanguageRef"> | string
  }

  export type MenteeDisciplineRefUpsertWithWhereUniqueWithoutUserInput = {
    where: MenteeDisciplineRefWhereUniqueInput
    update: XOR<MenteeDisciplineRefUpdateWithoutUserInput, MenteeDisciplineRefUncheckedUpdateWithoutUserInput>
    create: XOR<MenteeDisciplineRefCreateWithoutUserInput, MenteeDisciplineRefUncheckedCreateWithoutUserInput>
  }

  export type MenteeDisciplineRefUpdateWithWhereUniqueWithoutUserInput = {
    where: MenteeDisciplineRefWhereUniqueInput
    data: XOR<MenteeDisciplineRefUpdateWithoutUserInput, MenteeDisciplineRefUncheckedUpdateWithoutUserInput>
  }

  export type MenteeDisciplineRefUpdateManyWithWhereWithoutUserInput = {
    where: MenteeDisciplineRefScalarWhereInput
    data: XOR<MenteeDisciplineRefUpdateManyMutationInput, MenteeDisciplineRefUncheckedUpdateManyWithoutUserInput>
  }

  export type MenteeDisciplineRefScalarWhereInput = {
    AND?: MenteeDisciplineRefScalarWhereInput | MenteeDisciplineRefScalarWhereInput[]
    OR?: MenteeDisciplineRefScalarWhereInput[]
    NOT?: MenteeDisciplineRefScalarWhereInput | MenteeDisciplineRefScalarWhereInput[]
    user_id?: UuidFilter<"MenteeDisciplineRef"> | string
    discipline_id?: StringFilter<"MenteeDisciplineRef"> | string
  }

  export type MenteePreferenceRefUpsertWithWhereUniqueWithoutUserInput = {
    where: MenteePreferenceRefWhereUniqueInput
    update: XOR<MenteePreferenceRefUpdateWithoutUserInput, MenteePreferenceRefUncheckedUpdateWithoutUserInput>
    create: XOR<MenteePreferenceRefCreateWithoutUserInput, MenteePreferenceRefUncheckedCreateWithoutUserInput>
  }

  export type MenteePreferenceRefUpdateWithWhereUniqueWithoutUserInput = {
    where: MenteePreferenceRefWhereUniqueInput
    data: XOR<MenteePreferenceRefUpdateWithoutUserInput, MenteePreferenceRefUncheckedUpdateWithoutUserInput>
  }

  export type MenteePreferenceRefUpdateManyWithWhereWithoutUserInput = {
    where: MenteePreferenceRefScalarWhereInput
    data: XOR<MenteePreferenceRefUpdateManyMutationInput, MenteePreferenceRefUncheckedUpdateManyWithoutUserInput>
  }

  export type MenteePreferenceRefScalarWhereInput = {
    AND?: MenteePreferenceRefScalarWhereInput | MenteePreferenceRefScalarWhereInput[]
    OR?: MenteePreferenceRefScalarWhereInput[]
    NOT?: MenteePreferenceRefScalarWhereInput | MenteePreferenceRefScalarWhereInput[]
    user_id?: UuidFilter<"MenteePreferenceRef"> | string
    preference_id?: StringFilter<"MenteePreferenceRef"> | string
  }

  export type MentorCompanyMembershipUpsertWithWhereUniqueWithoutUserInput = {
    where: MentorCompanyMembershipWhereUniqueInput
    update: XOR<MentorCompanyMembershipUpdateWithoutUserInput, MentorCompanyMembershipUncheckedUpdateWithoutUserInput>
    create: XOR<MentorCompanyMembershipCreateWithoutUserInput, MentorCompanyMembershipUncheckedCreateWithoutUserInput>
  }

  export type MentorCompanyMembershipUpdateWithWhereUniqueWithoutUserInput = {
    where: MentorCompanyMembershipWhereUniqueInput
    data: XOR<MentorCompanyMembershipUpdateWithoutUserInput, MentorCompanyMembershipUncheckedUpdateWithoutUserInput>
  }

  export type MentorCompanyMembershipUpdateManyWithWhereWithoutUserInput = {
    where: MentorCompanyMembershipScalarWhereInput
    data: XOR<MentorCompanyMembershipUpdateManyMutationInput, MentorCompanyMembershipUncheckedUpdateManyWithoutUserInput>
  }

  export type MentorCompanyMembershipScalarWhereInput = {
    AND?: MentorCompanyMembershipScalarWhereInput | MentorCompanyMembershipScalarWhereInput[]
    OR?: MentorCompanyMembershipScalarWhereInput[]
    NOT?: MentorCompanyMembershipScalarWhereInput | MentorCompanyMembershipScalarWhereInput[]
    mentor_id?: UuidFilter<"MentorCompanyMembership"> | string
    company_id?: UuidFilter<"MentorCompanyMembership"> | string
    role_title?: StringNullableFilter<"MentorCompanyMembership"> | string | null
    work_email?: StringNullableFilter<"MentorCompanyMembership"> | string | null
    created_at?: DateTimeFilter<"MentorCompanyMembership"> | Date | string
  }

  export type UserCreateWithoutMentee_profileInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentor_profile?: MentorCreateNestedOneWithoutUserInput
    user_consent?: UserConsentCreateNestedOneWithoutUserInput
    mentee_languages?: MenteeLanguageCreateNestedManyWithoutUserInput
    mentee_interests?: MenteeInterestCreateNestedManyWithoutUserInput
    mentee_priorities?: MenteePriorityCreateNestedManyWithoutUserInput
    mentor_languages?: MentorLanguageCreateNestedManyWithoutUserInput
    mentor_categories?: MentorCategoryCreateNestedManyWithoutUserInput
    mentor_skills?: MentorSkillCreateNestedManyWithoutUserInput
    mentee_service_focus?: MenteeServiceFocusCreateNestedManyWithoutUserInput
    mentee_languages_ref?: MenteeLanguageRefCreateNestedManyWithoutUserInput
    mentee_disciplines_ref?: MenteeDisciplineRefCreateNestedManyWithoutUserInput
    mentee_preferences_ref?: MenteePreferenceRefCreateNestedManyWithoutUserInput
    mentor_company_membership?: MentorCompanyMembershipCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMentee_profileInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentor_profile?: MentorUncheckedCreateNestedOneWithoutUserInput
    user_consent?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    mentee_languages?: MenteeLanguageUncheckedCreateNestedManyWithoutUserInput
    mentee_interests?: MenteeInterestUncheckedCreateNestedManyWithoutUserInput
    mentee_priorities?: MenteePriorityUncheckedCreateNestedManyWithoutUserInput
    mentor_languages?: MentorLanguageUncheckedCreateNestedManyWithoutUserInput
    mentor_categories?: MentorCategoryUncheckedCreateNestedManyWithoutUserInput
    mentor_skills?: MentorSkillUncheckedCreateNestedManyWithoutUserInput
    mentee_service_focus?: MenteeServiceFocusUncheckedCreateNestedManyWithoutUserInput
    mentee_languages_ref?: MenteeLanguageRefUncheckedCreateNestedManyWithoutUserInput
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedCreateNestedManyWithoutUserInput
    mentee_preferences_ref?: MenteePreferenceRefUncheckedCreateNestedManyWithoutUserInput
    mentor_company_membership?: MentorCompanyMembershipUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMentee_profileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMentee_profileInput, UserUncheckedCreateWithoutMentee_profileInput>
  }

  export type UserUpsertWithoutMentee_profileInput = {
    update: XOR<UserUpdateWithoutMentee_profileInput, UserUncheckedUpdateWithoutMentee_profileInput>
    create: XOR<UserCreateWithoutMentee_profileInput, UserUncheckedCreateWithoutMentee_profileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMentee_profileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMentee_profileInput, UserUncheckedUpdateWithoutMentee_profileInput>
  }

  export type UserUpdateWithoutMentee_profileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentor_profile?: MentorUpdateOneWithoutUserNestedInput
    user_consent?: UserConsentUpdateOneWithoutUserNestedInput
    mentee_languages?: MenteeLanguageUpdateManyWithoutUserNestedInput
    mentee_interests?: MenteeInterestUpdateManyWithoutUserNestedInput
    mentee_priorities?: MenteePriorityUpdateManyWithoutUserNestedInput
    mentor_languages?: MentorLanguageUpdateManyWithoutUserNestedInput
    mentor_categories?: MentorCategoryUpdateManyWithoutUserNestedInput
    mentor_skills?: MentorSkillUpdateManyWithoutUserNestedInput
    mentee_service_focus?: MenteeServiceFocusUpdateManyWithoutUserNestedInput
    mentee_languages_ref?: MenteeLanguageRefUpdateManyWithoutUserNestedInput
    mentee_disciplines_ref?: MenteeDisciplineRefUpdateManyWithoutUserNestedInput
    mentee_preferences_ref?: MenteePreferenceRefUpdateManyWithoutUserNestedInput
    mentor_company_membership?: MentorCompanyMembershipUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMentee_profileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentor_profile?: MentorUncheckedUpdateOneWithoutUserNestedInput
    user_consent?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    mentee_languages?: MenteeLanguageUncheckedUpdateManyWithoutUserNestedInput
    mentee_interests?: MenteeInterestUncheckedUpdateManyWithoutUserNestedInput
    mentee_priorities?: MenteePriorityUncheckedUpdateManyWithoutUserNestedInput
    mentor_languages?: MentorLanguageUncheckedUpdateManyWithoutUserNestedInput
    mentor_categories?: MentorCategoryUncheckedUpdateManyWithoutUserNestedInput
    mentor_skills?: MentorSkillUncheckedUpdateManyWithoutUserNestedInput
    mentee_service_focus?: MenteeServiceFocusUncheckedUpdateManyWithoutUserNestedInput
    mentee_languages_ref?: MenteeLanguageRefUncheckedUpdateManyWithoutUserNestedInput
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedUpdateManyWithoutUserNestedInput
    mentee_preferences_ref?: MenteePreferenceRefUncheckedUpdateManyWithoutUserNestedInput
    mentor_company_membership?: MentorCompanyMembershipUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMentor_profileInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentee_profile?: MenteeCreateNestedOneWithoutUserInput
    user_consent?: UserConsentCreateNestedOneWithoutUserInput
    mentee_languages?: MenteeLanguageCreateNestedManyWithoutUserInput
    mentee_interests?: MenteeInterestCreateNestedManyWithoutUserInput
    mentee_priorities?: MenteePriorityCreateNestedManyWithoutUserInput
    mentor_languages?: MentorLanguageCreateNestedManyWithoutUserInput
    mentor_categories?: MentorCategoryCreateNestedManyWithoutUserInput
    mentor_skills?: MentorSkillCreateNestedManyWithoutUserInput
    mentee_service_focus?: MenteeServiceFocusCreateNestedManyWithoutUserInput
    mentee_languages_ref?: MenteeLanguageRefCreateNestedManyWithoutUserInput
    mentee_disciplines_ref?: MenteeDisciplineRefCreateNestedManyWithoutUserInput
    mentee_preferences_ref?: MenteePreferenceRefCreateNestedManyWithoutUserInput
    mentor_company_membership?: MentorCompanyMembershipCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMentor_profileInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentee_profile?: MenteeUncheckedCreateNestedOneWithoutUserInput
    user_consent?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    mentee_languages?: MenteeLanguageUncheckedCreateNestedManyWithoutUserInput
    mentee_interests?: MenteeInterestUncheckedCreateNestedManyWithoutUserInput
    mentee_priorities?: MenteePriorityUncheckedCreateNestedManyWithoutUserInput
    mentor_languages?: MentorLanguageUncheckedCreateNestedManyWithoutUserInput
    mentor_categories?: MentorCategoryUncheckedCreateNestedManyWithoutUserInput
    mentor_skills?: MentorSkillUncheckedCreateNestedManyWithoutUserInput
    mentee_service_focus?: MenteeServiceFocusUncheckedCreateNestedManyWithoutUserInput
    mentee_languages_ref?: MenteeLanguageRefUncheckedCreateNestedManyWithoutUserInput
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedCreateNestedManyWithoutUserInput
    mentee_preferences_ref?: MenteePreferenceRefUncheckedCreateNestedManyWithoutUserInput
    mentor_company_membership?: MentorCompanyMembershipUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMentor_profileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMentor_profileInput, UserUncheckedCreateWithoutMentor_profileInput>
  }

  export type UserUpsertWithoutMentor_profileInput = {
    update: XOR<UserUpdateWithoutMentor_profileInput, UserUncheckedUpdateWithoutMentor_profileInput>
    create: XOR<UserCreateWithoutMentor_profileInput, UserUncheckedCreateWithoutMentor_profileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMentor_profileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMentor_profileInput, UserUncheckedUpdateWithoutMentor_profileInput>
  }

  export type UserUpdateWithoutMentor_profileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee_profile?: MenteeUpdateOneWithoutUserNestedInput
    user_consent?: UserConsentUpdateOneWithoutUserNestedInput
    mentee_languages?: MenteeLanguageUpdateManyWithoutUserNestedInput
    mentee_interests?: MenteeInterestUpdateManyWithoutUserNestedInput
    mentee_priorities?: MenteePriorityUpdateManyWithoutUserNestedInput
    mentor_languages?: MentorLanguageUpdateManyWithoutUserNestedInput
    mentor_categories?: MentorCategoryUpdateManyWithoutUserNestedInput
    mentor_skills?: MentorSkillUpdateManyWithoutUserNestedInput
    mentee_service_focus?: MenteeServiceFocusUpdateManyWithoutUserNestedInput
    mentee_languages_ref?: MenteeLanguageRefUpdateManyWithoutUserNestedInput
    mentee_disciplines_ref?: MenteeDisciplineRefUpdateManyWithoutUserNestedInput
    mentee_preferences_ref?: MenteePreferenceRefUpdateManyWithoutUserNestedInput
    mentor_company_membership?: MentorCompanyMembershipUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMentor_profileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee_profile?: MenteeUncheckedUpdateOneWithoutUserNestedInput
    user_consent?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    mentee_languages?: MenteeLanguageUncheckedUpdateManyWithoutUserNestedInput
    mentee_interests?: MenteeInterestUncheckedUpdateManyWithoutUserNestedInput
    mentee_priorities?: MenteePriorityUncheckedUpdateManyWithoutUserNestedInput
    mentor_languages?: MentorLanguageUncheckedUpdateManyWithoutUserNestedInput
    mentor_categories?: MentorCategoryUncheckedUpdateManyWithoutUserNestedInput
    mentor_skills?: MentorSkillUncheckedUpdateManyWithoutUserNestedInput
    mentee_service_focus?: MenteeServiceFocusUncheckedUpdateManyWithoutUserNestedInput
    mentee_languages_ref?: MenteeLanguageRefUncheckedUpdateManyWithoutUserNestedInput
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedUpdateManyWithoutUserNestedInput
    mentee_preferences_ref?: MenteePreferenceRefUncheckedUpdateManyWithoutUserNestedInput
    mentor_company_membership?: MentorCompanyMembershipUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MenteeServiceFocusCreateWithoutService_focusInput = {
    user: UserCreateNestedOneWithoutMentee_service_focusInput
  }

  export type MenteeServiceFocusUncheckedCreateWithoutService_focusInput = {
    user_id: string
  }

  export type MenteeServiceFocusCreateOrConnectWithoutService_focusInput = {
    where: MenteeServiceFocusWhereUniqueInput
    create: XOR<MenteeServiceFocusCreateWithoutService_focusInput, MenteeServiceFocusUncheckedCreateWithoutService_focusInput>
  }

  export type MenteeServiceFocusCreateManyService_focusInputEnvelope = {
    data: MenteeServiceFocusCreateManyService_focusInput | MenteeServiceFocusCreateManyService_focusInput[]
    skipDuplicates?: boolean
  }

  export type MenteeServiceFocusUpsertWithWhereUniqueWithoutService_focusInput = {
    where: MenteeServiceFocusWhereUniqueInput
    update: XOR<MenteeServiceFocusUpdateWithoutService_focusInput, MenteeServiceFocusUncheckedUpdateWithoutService_focusInput>
    create: XOR<MenteeServiceFocusCreateWithoutService_focusInput, MenteeServiceFocusUncheckedCreateWithoutService_focusInput>
  }

  export type MenteeServiceFocusUpdateWithWhereUniqueWithoutService_focusInput = {
    where: MenteeServiceFocusWhereUniqueInput
    data: XOR<MenteeServiceFocusUpdateWithoutService_focusInput, MenteeServiceFocusUncheckedUpdateWithoutService_focusInput>
  }

  export type MenteeServiceFocusUpdateManyWithWhereWithoutService_focusInput = {
    where: MenteeServiceFocusScalarWhereInput
    data: XOR<MenteeServiceFocusUpdateManyMutationInput, MenteeServiceFocusUncheckedUpdateManyWithoutService_focusInput>
  }

  export type MenteeLanguageRefCreateWithoutLanguageInput = {
    user: UserCreateNestedOneWithoutMentee_languages_refInput
  }

  export type MenteeLanguageRefUncheckedCreateWithoutLanguageInput = {
    user_id: string
  }

  export type MenteeLanguageRefCreateOrConnectWithoutLanguageInput = {
    where: MenteeLanguageRefWhereUniqueInput
    create: XOR<MenteeLanguageRefCreateWithoutLanguageInput, MenteeLanguageRefUncheckedCreateWithoutLanguageInput>
  }

  export type MenteeLanguageRefCreateManyLanguageInputEnvelope = {
    data: MenteeLanguageRefCreateManyLanguageInput | MenteeLanguageRefCreateManyLanguageInput[]
    skipDuplicates?: boolean
  }

  export type MenteeLanguageRefUpsertWithWhereUniqueWithoutLanguageInput = {
    where: MenteeLanguageRefWhereUniqueInput
    update: XOR<MenteeLanguageRefUpdateWithoutLanguageInput, MenteeLanguageRefUncheckedUpdateWithoutLanguageInput>
    create: XOR<MenteeLanguageRefCreateWithoutLanguageInput, MenteeLanguageRefUncheckedCreateWithoutLanguageInput>
  }

  export type MenteeLanguageRefUpdateWithWhereUniqueWithoutLanguageInput = {
    where: MenteeLanguageRefWhereUniqueInput
    data: XOR<MenteeLanguageRefUpdateWithoutLanguageInput, MenteeLanguageRefUncheckedUpdateWithoutLanguageInput>
  }

  export type MenteeLanguageRefUpdateManyWithWhereWithoutLanguageInput = {
    where: MenteeLanguageRefScalarWhereInput
    data: XOR<MenteeLanguageRefUpdateManyMutationInput, MenteeLanguageRefUncheckedUpdateManyWithoutLanguageInput>
  }

  export type MenteeDisciplineRefCreateWithoutDisciplineInput = {
    user: UserCreateNestedOneWithoutMentee_disciplines_refInput
  }

  export type MenteeDisciplineRefUncheckedCreateWithoutDisciplineInput = {
    user_id: string
  }

  export type MenteeDisciplineRefCreateOrConnectWithoutDisciplineInput = {
    where: MenteeDisciplineRefWhereUniqueInput
    create: XOR<MenteeDisciplineRefCreateWithoutDisciplineInput, MenteeDisciplineRefUncheckedCreateWithoutDisciplineInput>
  }

  export type MenteeDisciplineRefCreateManyDisciplineInputEnvelope = {
    data: MenteeDisciplineRefCreateManyDisciplineInput | MenteeDisciplineRefCreateManyDisciplineInput[]
    skipDuplicates?: boolean
  }

  export type MenteeDisciplineRefUpsertWithWhereUniqueWithoutDisciplineInput = {
    where: MenteeDisciplineRefWhereUniqueInput
    update: XOR<MenteeDisciplineRefUpdateWithoutDisciplineInput, MenteeDisciplineRefUncheckedUpdateWithoutDisciplineInput>
    create: XOR<MenteeDisciplineRefCreateWithoutDisciplineInput, MenteeDisciplineRefUncheckedCreateWithoutDisciplineInput>
  }

  export type MenteeDisciplineRefUpdateWithWhereUniqueWithoutDisciplineInput = {
    where: MenteeDisciplineRefWhereUniqueInput
    data: XOR<MenteeDisciplineRefUpdateWithoutDisciplineInput, MenteeDisciplineRefUncheckedUpdateWithoutDisciplineInput>
  }

  export type MenteeDisciplineRefUpdateManyWithWhereWithoutDisciplineInput = {
    where: MenteeDisciplineRefScalarWhereInput
    data: XOR<MenteeDisciplineRefUpdateManyMutationInput, MenteeDisciplineRefUncheckedUpdateManyWithoutDisciplineInput>
  }

  export type MenteePreferenceRefCreateWithoutPreferenceInput = {
    user: UserCreateNestedOneWithoutMentee_preferences_refInput
  }

  export type MenteePreferenceRefUncheckedCreateWithoutPreferenceInput = {
    user_id: string
  }

  export type MenteePreferenceRefCreateOrConnectWithoutPreferenceInput = {
    where: MenteePreferenceRefWhereUniqueInput
    create: XOR<MenteePreferenceRefCreateWithoutPreferenceInput, MenteePreferenceRefUncheckedCreateWithoutPreferenceInput>
  }

  export type MenteePreferenceRefCreateManyPreferenceInputEnvelope = {
    data: MenteePreferenceRefCreateManyPreferenceInput | MenteePreferenceRefCreateManyPreferenceInput[]
    skipDuplicates?: boolean
  }

  export type MenteePreferenceRefUpsertWithWhereUniqueWithoutPreferenceInput = {
    where: MenteePreferenceRefWhereUniqueInput
    update: XOR<MenteePreferenceRefUpdateWithoutPreferenceInput, MenteePreferenceRefUncheckedUpdateWithoutPreferenceInput>
    create: XOR<MenteePreferenceRefCreateWithoutPreferenceInput, MenteePreferenceRefUncheckedCreateWithoutPreferenceInput>
  }

  export type MenteePreferenceRefUpdateWithWhereUniqueWithoutPreferenceInput = {
    where: MenteePreferenceRefWhereUniqueInput
    data: XOR<MenteePreferenceRefUpdateWithoutPreferenceInput, MenteePreferenceRefUncheckedUpdateWithoutPreferenceInput>
  }

  export type MenteePreferenceRefUpdateManyWithWhereWithoutPreferenceInput = {
    where: MenteePreferenceRefScalarWhereInput
    data: XOR<MenteePreferenceRefUpdateManyMutationInput, MenteePreferenceRefUncheckedUpdateManyWithoutPreferenceInput>
  }

  export type UserCreateWithoutMentee_languagesInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentee_profile?: MenteeCreateNestedOneWithoutUserInput
    mentor_profile?: MentorCreateNestedOneWithoutUserInput
    user_consent?: UserConsentCreateNestedOneWithoutUserInput
    mentee_interests?: MenteeInterestCreateNestedManyWithoutUserInput
    mentee_priorities?: MenteePriorityCreateNestedManyWithoutUserInput
    mentor_languages?: MentorLanguageCreateNestedManyWithoutUserInput
    mentor_categories?: MentorCategoryCreateNestedManyWithoutUserInput
    mentor_skills?: MentorSkillCreateNestedManyWithoutUserInput
    mentee_service_focus?: MenteeServiceFocusCreateNestedManyWithoutUserInput
    mentee_languages_ref?: MenteeLanguageRefCreateNestedManyWithoutUserInput
    mentee_disciplines_ref?: MenteeDisciplineRefCreateNestedManyWithoutUserInput
    mentee_preferences_ref?: MenteePreferenceRefCreateNestedManyWithoutUserInput
    mentor_company_membership?: MentorCompanyMembershipCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMentee_languagesInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentee_profile?: MenteeUncheckedCreateNestedOneWithoutUserInput
    mentor_profile?: MentorUncheckedCreateNestedOneWithoutUserInput
    user_consent?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    mentee_interests?: MenteeInterestUncheckedCreateNestedManyWithoutUserInput
    mentee_priorities?: MenteePriorityUncheckedCreateNestedManyWithoutUserInput
    mentor_languages?: MentorLanguageUncheckedCreateNestedManyWithoutUserInput
    mentor_categories?: MentorCategoryUncheckedCreateNestedManyWithoutUserInput
    mentor_skills?: MentorSkillUncheckedCreateNestedManyWithoutUserInput
    mentee_service_focus?: MenteeServiceFocusUncheckedCreateNestedManyWithoutUserInput
    mentee_languages_ref?: MenteeLanguageRefUncheckedCreateNestedManyWithoutUserInput
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedCreateNestedManyWithoutUserInput
    mentee_preferences_ref?: MenteePreferenceRefUncheckedCreateNestedManyWithoutUserInput
    mentor_company_membership?: MentorCompanyMembershipUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMentee_languagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMentee_languagesInput, UserUncheckedCreateWithoutMentee_languagesInput>
  }

  export type UserUpsertWithoutMentee_languagesInput = {
    update: XOR<UserUpdateWithoutMentee_languagesInput, UserUncheckedUpdateWithoutMentee_languagesInput>
    create: XOR<UserCreateWithoutMentee_languagesInput, UserUncheckedCreateWithoutMentee_languagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMentee_languagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMentee_languagesInput, UserUncheckedUpdateWithoutMentee_languagesInput>
  }

  export type UserUpdateWithoutMentee_languagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee_profile?: MenteeUpdateOneWithoutUserNestedInput
    mentor_profile?: MentorUpdateOneWithoutUserNestedInput
    user_consent?: UserConsentUpdateOneWithoutUserNestedInput
    mentee_interests?: MenteeInterestUpdateManyWithoutUserNestedInput
    mentee_priorities?: MenteePriorityUpdateManyWithoutUserNestedInput
    mentor_languages?: MentorLanguageUpdateManyWithoutUserNestedInput
    mentor_categories?: MentorCategoryUpdateManyWithoutUserNestedInput
    mentor_skills?: MentorSkillUpdateManyWithoutUserNestedInput
    mentee_service_focus?: MenteeServiceFocusUpdateManyWithoutUserNestedInput
    mentee_languages_ref?: MenteeLanguageRefUpdateManyWithoutUserNestedInput
    mentee_disciplines_ref?: MenteeDisciplineRefUpdateManyWithoutUserNestedInput
    mentee_preferences_ref?: MenteePreferenceRefUpdateManyWithoutUserNestedInput
    mentor_company_membership?: MentorCompanyMembershipUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMentee_languagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee_profile?: MenteeUncheckedUpdateOneWithoutUserNestedInput
    mentor_profile?: MentorUncheckedUpdateOneWithoutUserNestedInput
    user_consent?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    mentee_interests?: MenteeInterestUncheckedUpdateManyWithoutUserNestedInput
    mentee_priorities?: MenteePriorityUncheckedUpdateManyWithoutUserNestedInput
    mentor_languages?: MentorLanguageUncheckedUpdateManyWithoutUserNestedInput
    mentor_categories?: MentorCategoryUncheckedUpdateManyWithoutUserNestedInput
    mentor_skills?: MentorSkillUncheckedUpdateManyWithoutUserNestedInput
    mentee_service_focus?: MenteeServiceFocusUncheckedUpdateManyWithoutUserNestedInput
    mentee_languages_ref?: MenteeLanguageRefUncheckedUpdateManyWithoutUserNestedInput
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedUpdateManyWithoutUserNestedInput
    mentee_preferences_ref?: MenteePreferenceRefUncheckedUpdateManyWithoutUserNestedInput
    mentor_company_membership?: MentorCompanyMembershipUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMentee_interestsInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentee_profile?: MenteeCreateNestedOneWithoutUserInput
    mentor_profile?: MentorCreateNestedOneWithoutUserInput
    user_consent?: UserConsentCreateNestedOneWithoutUserInput
    mentee_languages?: MenteeLanguageCreateNestedManyWithoutUserInput
    mentee_priorities?: MenteePriorityCreateNestedManyWithoutUserInput
    mentor_languages?: MentorLanguageCreateNestedManyWithoutUserInput
    mentor_categories?: MentorCategoryCreateNestedManyWithoutUserInput
    mentor_skills?: MentorSkillCreateNestedManyWithoutUserInput
    mentee_service_focus?: MenteeServiceFocusCreateNestedManyWithoutUserInput
    mentee_languages_ref?: MenteeLanguageRefCreateNestedManyWithoutUserInput
    mentee_disciplines_ref?: MenteeDisciplineRefCreateNestedManyWithoutUserInput
    mentee_preferences_ref?: MenteePreferenceRefCreateNestedManyWithoutUserInput
    mentor_company_membership?: MentorCompanyMembershipCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMentee_interestsInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentee_profile?: MenteeUncheckedCreateNestedOneWithoutUserInput
    mentor_profile?: MentorUncheckedCreateNestedOneWithoutUserInput
    user_consent?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    mentee_languages?: MenteeLanguageUncheckedCreateNestedManyWithoutUserInput
    mentee_priorities?: MenteePriorityUncheckedCreateNestedManyWithoutUserInput
    mentor_languages?: MentorLanguageUncheckedCreateNestedManyWithoutUserInput
    mentor_categories?: MentorCategoryUncheckedCreateNestedManyWithoutUserInput
    mentor_skills?: MentorSkillUncheckedCreateNestedManyWithoutUserInput
    mentee_service_focus?: MenteeServiceFocusUncheckedCreateNestedManyWithoutUserInput
    mentee_languages_ref?: MenteeLanguageRefUncheckedCreateNestedManyWithoutUserInput
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedCreateNestedManyWithoutUserInput
    mentee_preferences_ref?: MenteePreferenceRefUncheckedCreateNestedManyWithoutUserInput
    mentor_company_membership?: MentorCompanyMembershipUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMentee_interestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMentee_interestsInput, UserUncheckedCreateWithoutMentee_interestsInput>
  }

  export type UserUpsertWithoutMentee_interestsInput = {
    update: XOR<UserUpdateWithoutMentee_interestsInput, UserUncheckedUpdateWithoutMentee_interestsInput>
    create: XOR<UserCreateWithoutMentee_interestsInput, UserUncheckedCreateWithoutMentee_interestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMentee_interestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMentee_interestsInput, UserUncheckedUpdateWithoutMentee_interestsInput>
  }

  export type UserUpdateWithoutMentee_interestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee_profile?: MenteeUpdateOneWithoutUserNestedInput
    mentor_profile?: MentorUpdateOneWithoutUserNestedInput
    user_consent?: UserConsentUpdateOneWithoutUserNestedInput
    mentee_languages?: MenteeLanguageUpdateManyWithoutUserNestedInput
    mentee_priorities?: MenteePriorityUpdateManyWithoutUserNestedInput
    mentor_languages?: MentorLanguageUpdateManyWithoutUserNestedInput
    mentor_categories?: MentorCategoryUpdateManyWithoutUserNestedInput
    mentor_skills?: MentorSkillUpdateManyWithoutUserNestedInput
    mentee_service_focus?: MenteeServiceFocusUpdateManyWithoutUserNestedInput
    mentee_languages_ref?: MenteeLanguageRefUpdateManyWithoutUserNestedInput
    mentee_disciplines_ref?: MenteeDisciplineRefUpdateManyWithoutUserNestedInput
    mentee_preferences_ref?: MenteePreferenceRefUpdateManyWithoutUserNestedInput
    mentor_company_membership?: MentorCompanyMembershipUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMentee_interestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee_profile?: MenteeUncheckedUpdateOneWithoutUserNestedInput
    mentor_profile?: MentorUncheckedUpdateOneWithoutUserNestedInput
    user_consent?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    mentee_languages?: MenteeLanguageUncheckedUpdateManyWithoutUserNestedInput
    mentee_priorities?: MenteePriorityUncheckedUpdateManyWithoutUserNestedInput
    mentor_languages?: MentorLanguageUncheckedUpdateManyWithoutUserNestedInput
    mentor_categories?: MentorCategoryUncheckedUpdateManyWithoutUserNestedInput
    mentor_skills?: MentorSkillUncheckedUpdateManyWithoutUserNestedInput
    mentee_service_focus?: MenteeServiceFocusUncheckedUpdateManyWithoutUserNestedInput
    mentee_languages_ref?: MenteeLanguageRefUncheckedUpdateManyWithoutUserNestedInput
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedUpdateManyWithoutUserNestedInput
    mentee_preferences_ref?: MenteePreferenceRefUncheckedUpdateManyWithoutUserNestedInput
    mentor_company_membership?: MentorCompanyMembershipUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMentee_prioritiesInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentee_profile?: MenteeCreateNestedOneWithoutUserInput
    mentor_profile?: MentorCreateNestedOneWithoutUserInput
    user_consent?: UserConsentCreateNestedOneWithoutUserInput
    mentee_languages?: MenteeLanguageCreateNestedManyWithoutUserInput
    mentee_interests?: MenteeInterestCreateNestedManyWithoutUserInput
    mentor_languages?: MentorLanguageCreateNestedManyWithoutUserInput
    mentor_categories?: MentorCategoryCreateNestedManyWithoutUserInput
    mentor_skills?: MentorSkillCreateNestedManyWithoutUserInput
    mentee_service_focus?: MenteeServiceFocusCreateNestedManyWithoutUserInput
    mentee_languages_ref?: MenteeLanguageRefCreateNestedManyWithoutUserInput
    mentee_disciplines_ref?: MenteeDisciplineRefCreateNestedManyWithoutUserInput
    mentee_preferences_ref?: MenteePreferenceRefCreateNestedManyWithoutUserInput
    mentor_company_membership?: MentorCompanyMembershipCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMentee_prioritiesInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentee_profile?: MenteeUncheckedCreateNestedOneWithoutUserInput
    mentor_profile?: MentorUncheckedCreateNestedOneWithoutUserInput
    user_consent?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    mentee_languages?: MenteeLanguageUncheckedCreateNestedManyWithoutUserInput
    mentee_interests?: MenteeInterestUncheckedCreateNestedManyWithoutUserInput
    mentor_languages?: MentorLanguageUncheckedCreateNestedManyWithoutUserInput
    mentor_categories?: MentorCategoryUncheckedCreateNestedManyWithoutUserInput
    mentor_skills?: MentorSkillUncheckedCreateNestedManyWithoutUserInput
    mentee_service_focus?: MenteeServiceFocusUncheckedCreateNestedManyWithoutUserInput
    mentee_languages_ref?: MenteeLanguageRefUncheckedCreateNestedManyWithoutUserInput
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedCreateNestedManyWithoutUserInput
    mentee_preferences_ref?: MenteePreferenceRefUncheckedCreateNestedManyWithoutUserInput
    mentor_company_membership?: MentorCompanyMembershipUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMentee_prioritiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMentee_prioritiesInput, UserUncheckedCreateWithoutMentee_prioritiesInput>
  }

  export type UserUpsertWithoutMentee_prioritiesInput = {
    update: XOR<UserUpdateWithoutMentee_prioritiesInput, UserUncheckedUpdateWithoutMentee_prioritiesInput>
    create: XOR<UserCreateWithoutMentee_prioritiesInput, UserUncheckedCreateWithoutMentee_prioritiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMentee_prioritiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMentee_prioritiesInput, UserUncheckedUpdateWithoutMentee_prioritiesInput>
  }

  export type UserUpdateWithoutMentee_prioritiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee_profile?: MenteeUpdateOneWithoutUserNestedInput
    mentor_profile?: MentorUpdateOneWithoutUserNestedInput
    user_consent?: UserConsentUpdateOneWithoutUserNestedInput
    mentee_languages?: MenteeLanguageUpdateManyWithoutUserNestedInput
    mentee_interests?: MenteeInterestUpdateManyWithoutUserNestedInput
    mentor_languages?: MentorLanguageUpdateManyWithoutUserNestedInput
    mentor_categories?: MentorCategoryUpdateManyWithoutUserNestedInput
    mentor_skills?: MentorSkillUpdateManyWithoutUserNestedInput
    mentee_service_focus?: MenteeServiceFocusUpdateManyWithoutUserNestedInput
    mentee_languages_ref?: MenteeLanguageRefUpdateManyWithoutUserNestedInput
    mentee_disciplines_ref?: MenteeDisciplineRefUpdateManyWithoutUserNestedInput
    mentee_preferences_ref?: MenteePreferenceRefUpdateManyWithoutUserNestedInput
    mentor_company_membership?: MentorCompanyMembershipUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMentee_prioritiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee_profile?: MenteeUncheckedUpdateOneWithoutUserNestedInput
    mentor_profile?: MentorUncheckedUpdateOneWithoutUserNestedInput
    user_consent?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    mentee_languages?: MenteeLanguageUncheckedUpdateManyWithoutUserNestedInput
    mentee_interests?: MenteeInterestUncheckedUpdateManyWithoutUserNestedInput
    mentor_languages?: MentorLanguageUncheckedUpdateManyWithoutUserNestedInput
    mentor_categories?: MentorCategoryUncheckedUpdateManyWithoutUserNestedInput
    mentor_skills?: MentorSkillUncheckedUpdateManyWithoutUserNestedInput
    mentee_service_focus?: MenteeServiceFocusUncheckedUpdateManyWithoutUserNestedInput
    mentee_languages_ref?: MenteeLanguageRefUncheckedUpdateManyWithoutUserNestedInput
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedUpdateManyWithoutUserNestedInput
    mentee_preferences_ref?: MenteePreferenceRefUncheckedUpdateManyWithoutUserNestedInput
    mentor_company_membership?: MentorCompanyMembershipUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMentor_languagesInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentee_profile?: MenteeCreateNestedOneWithoutUserInput
    mentor_profile?: MentorCreateNestedOneWithoutUserInput
    user_consent?: UserConsentCreateNestedOneWithoutUserInput
    mentee_languages?: MenteeLanguageCreateNestedManyWithoutUserInput
    mentee_interests?: MenteeInterestCreateNestedManyWithoutUserInput
    mentee_priorities?: MenteePriorityCreateNestedManyWithoutUserInput
    mentor_categories?: MentorCategoryCreateNestedManyWithoutUserInput
    mentor_skills?: MentorSkillCreateNestedManyWithoutUserInput
    mentee_service_focus?: MenteeServiceFocusCreateNestedManyWithoutUserInput
    mentee_languages_ref?: MenteeLanguageRefCreateNestedManyWithoutUserInput
    mentee_disciplines_ref?: MenteeDisciplineRefCreateNestedManyWithoutUserInput
    mentee_preferences_ref?: MenteePreferenceRefCreateNestedManyWithoutUserInput
    mentor_company_membership?: MentorCompanyMembershipCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMentor_languagesInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentee_profile?: MenteeUncheckedCreateNestedOneWithoutUserInput
    mentor_profile?: MentorUncheckedCreateNestedOneWithoutUserInput
    user_consent?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    mentee_languages?: MenteeLanguageUncheckedCreateNestedManyWithoutUserInput
    mentee_interests?: MenteeInterestUncheckedCreateNestedManyWithoutUserInput
    mentee_priorities?: MenteePriorityUncheckedCreateNestedManyWithoutUserInput
    mentor_categories?: MentorCategoryUncheckedCreateNestedManyWithoutUserInput
    mentor_skills?: MentorSkillUncheckedCreateNestedManyWithoutUserInput
    mentee_service_focus?: MenteeServiceFocusUncheckedCreateNestedManyWithoutUserInput
    mentee_languages_ref?: MenteeLanguageRefUncheckedCreateNestedManyWithoutUserInput
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedCreateNestedManyWithoutUserInput
    mentee_preferences_ref?: MenteePreferenceRefUncheckedCreateNestedManyWithoutUserInput
    mentor_company_membership?: MentorCompanyMembershipUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMentor_languagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMentor_languagesInput, UserUncheckedCreateWithoutMentor_languagesInput>
  }

  export type UserUpsertWithoutMentor_languagesInput = {
    update: XOR<UserUpdateWithoutMentor_languagesInput, UserUncheckedUpdateWithoutMentor_languagesInput>
    create: XOR<UserCreateWithoutMentor_languagesInput, UserUncheckedCreateWithoutMentor_languagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMentor_languagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMentor_languagesInput, UserUncheckedUpdateWithoutMentor_languagesInput>
  }

  export type UserUpdateWithoutMentor_languagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee_profile?: MenteeUpdateOneWithoutUserNestedInput
    mentor_profile?: MentorUpdateOneWithoutUserNestedInput
    user_consent?: UserConsentUpdateOneWithoutUserNestedInput
    mentee_languages?: MenteeLanguageUpdateManyWithoutUserNestedInput
    mentee_interests?: MenteeInterestUpdateManyWithoutUserNestedInput
    mentee_priorities?: MenteePriorityUpdateManyWithoutUserNestedInput
    mentor_categories?: MentorCategoryUpdateManyWithoutUserNestedInput
    mentor_skills?: MentorSkillUpdateManyWithoutUserNestedInput
    mentee_service_focus?: MenteeServiceFocusUpdateManyWithoutUserNestedInput
    mentee_languages_ref?: MenteeLanguageRefUpdateManyWithoutUserNestedInput
    mentee_disciplines_ref?: MenteeDisciplineRefUpdateManyWithoutUserNestedInput
    mentee_preferences_ref?: MenteePreferenceRefUpdateManyWithoutUserNestedInput
    mentor_company_membership?: MentorCompanyMembershipUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMentor_languagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee_profile?: MenteeUncheckedUpdateOneWithoutUserNestedInput
    mentor_profile?: MentorUncheckedUpdateOneWithoutUserNestedInput
    user_consent?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    mentee_languages?: MenteeLanguageUncheckedUpdateManyWithoutUserNestedInput
    mentee_interests?: MenteeInterestUncheckedUpdateManyWithoutUserNestedInput
    mentee_priorities?: MenteePriorityUncheckedUpdateManyWithoutUserNestedInput
    mentor_categories?: MentorCategoryUncheckedUpdateManyWithoutUserNestedInput
    mentor_skills?: MentorSkillUncheckedUpdateManyWithoutUserNestedInput
    mentee_service_focus?: MenteeServiceFocusUncheckedUpdateManyWithoutUserNestedInput
    mentee_languages_ref?: MenteeLanguageRefUncheckedUpdateManyWithoutUserNestedInput
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedUpdateManyWithoutUserNestedInput
    mentee_preferences_ref?: MenteePreferenceRefUncheckedUpdateManyWithoutUserNestedInput
    mentor_company_membership?: MentorCompanyMembershipUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMentor_categoriesInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentee_profile?: MenteeCreateNestedOneWithoutUserInput
    mentor_profile?: MentorCreateNestedOneWithoutUserInput
    user_consent?: UserConsentCreateNestedOneWithoutUserInput
    mentee_languages?: MenteeLanguageCreateNestedManyWithoutUserInput
    mentee_interests?: MenteeInterestCreateNestedManyWithoutUserInput
    mentee_priorities?: MenteePriorityCreateNestedManyWithoutUserInput
    mentor_languages?: MentorLanguageCreateNestedManyWithoutUserInput
    mentor_skills?: MentorSkillCreateNestedManyWithoutUserInput
    mentee_service_focus?: MenteeServiceFocusCreateNestedManyWithoutUserInput
    mentee_languages_ref?: MenteeLanguageRefCreateNestedManyWithoutUserInput
    mentee_disciplines_ref?: MenteeDisciplineRefCreateNestedManyWithoutUserInput
    mentee_preferences_ref?: MenteePreferenceRefCreateNestedManyWithoutUserInput
    mentor_company_membership?: MentorCompanyMembershipCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMentor_categoriesInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentee_profile?: MenteeUncheckedCreateNestedOneWithoutUserInput
    mentor_profile?: MentorUncheckedCreateNestedOneWithoutUserInput
    user_consent?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    mentee_languages?: MenteeLanguageUncheckedCreateNestedManyWithoutUserInput
    mentee_interests?: MenteeInterestUncheckedCreateNestedManyWithoutUserInput
    mentee_priorities?: MenteePriorityUncheckedCreateNestedManyWithoutUserInput
    mentor_languages?: MentorLanguageUncheckedCreateNestedManyWithoutUserInput
    mentor_skills?: MentorSkillUncheckedCreateNestedManyWithoutUserInput
    mentee_service_focus?: MenteeServiceFocusUncheckedCreateNestedManyWithoutUserInput
    mentee_languages_ref?: MenteeLanguageRefUncheckedCreateNestedManyWithoutUserInput
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedCreateNestedManyWithoutUserInput
    mentee_preferences_ref?: MenteePreferenceRefUncheckedCreateNestedManyWithoutUserInput
    mentor_company_membership?: MentorCompanyMembershipUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMentor_categoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMentor_categoriesInput, UserUncheckedCreateWithoutMentor_categoriesInput>
  }

  export type UserUpsertWithoutMentor_categoriesInput = {
    update: XOR<UserUpdateWithoutMentor_categoriesInput, UserUncheckedUpdateWithoutMentor_categoriesInput>
    create: XOR<UserCreateWithoutMentor_categoriesInput, UserUncheckedCreateWithoutMentor_categoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMentor_categoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMentor_categoriesInput, UserUncheckedUpdateWithoutMentor_categoriesInput>
  }

  export type UserUpdateWithoutMentor_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee_profile?: MenteeUpdateOneWithoutUserNestedInput
    mentor_profile?: MentorUpdateOneWithoutUserNestedInput
    user_consent?: UserConsentUpdateOneWithoutUserNestedInput
    mentee_languages?: MenteeLanguageUpdateManyWithoutUserNestedInput
    mentee_interests?: MenteeInterestUpdateManyWithoutUserNestedInput
    mentee_priorities?: MenteePriorityUpdateManyWithoutUserNestedInput
    mentor_languages?: MentorLanguageUpdateManyWithoutUserNestedInput
    mentor_skills?: MentorSkillUpdateManyWithoutUserNestedInput
    mentee_service_focus?: MenteeServiceFocusUpdateManyWithoutUserNestedInput
    mentee_languages_ref?: MenteeLanguageRefUpdateManyWithoutUserNestedInput
    mentee_disciplines_ref?: MenteeDisciplineRefUpdateManyWithoutUserNestedInput
    mentee_preferences_ref?: MenteePreferenceRefUpdateManyWithoutUserNestedInput
    mentor_company_membership?: MentorCompanyMembershipUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMentor_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee_profile?: MenteeUncheckedUpdateOneWithoutUserNestedInput
    mentor_profile?: MentorUncheckedUpdateOneWithoutUserNestedInput
    user_consent?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    mentee_languages?: MenteeLanguageUncheckedUpdateManyWithoutUserNestedInput
    mentee_interests?: MenteeInterestUncheckedUpdateManyWithoutUserNestedInput
    mentee_priorities?: MenteePriorityUncheckedUpdateManyWithoutUserNestedInput
    mentor_languages?: MentorLanguageUncheckedUpdateManyWithoutUserNestedInput
    mentor_skills?: MentorSkillUncheckedUpdateManyWithoutUserNestedInput
    mentee_service_focus?: MenteeServiceFocusUncheckedUpdateManyWithoutUserNestedInput
    mentee_languages_ref?: MenteeLanguageRefUncheckedUpdateManyWithoutUserNestedInput
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedUpdateManyWithoutUserNestedInput
    mentee_preferences_ref?: MenteePreferenceRefUncheckedUpdateManyWithoutUserNestedInput
    mentor_company_membership?: MentorCompanyMembershipUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMentor_skillsInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentee_profile?: MenteeCreateNestedOneWithoutUserInput
    mentor_profile?: MentorCreateNestedOneWithoutUserInput
    user_consent?: UserConsentCreateNestedOneWithoutUserInput
    mentee_languages?: MenteeLanguageCreateNestedManyWithoutUserInput
    mentee_interests?: MenteeInterestCreateNestedManyWithoutUserInput
    mentee_priorities?: MenteePriorityCreateNestedManyWithoutUserInput
    mentor_languages?: MentorLanguageCreateNestedManyWithoutUserInput
    mentor_categories?: MentorCategoryCreateNestedManyWithoutUserInput
    mentee_service_focus?: MenteeServiceFocusCreateNestedManyWithoutUserInput
    mentee_languages_ref?: MenteeLanguageRefCreateNestedManyWithoutUserInput
    mentee_disciplines_ref?: MenteeDisciplineRefCreateNestedManyWithoutUserInput
    mentee_preferences_ref?: MenteePreferenceRefCreateNestedManyWithoutUserInput
    mentor_company_membership?: MentorCompanyMembershipCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMentor_skillsInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentee_profile?: MenteeUncheckedCreateNestedOneWithoutUserInput
    mentor_profile?: MentorUncheckedCreateNestedOneWithoutUserInput
    user_consent?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    mentee_languages?: MenteeLanguageUncheckedCreateNestedManyWithoutUserInput
    mentee_interests?: MenteeInterestUncheckedCreateNestedManyWithoutUserInput
    mentee_priorities?: MenteePriorityUncheckedCreateNestedManyWithoutUserInput
    mentor_languages?: MentorLanguageUncheckedCreateNestedManyWithoutUserInput
    mentor_categories?: MentorCategoryUncheckedCreateNestedManyWithoutUserInput
    mentee_service_focus?: MenteeServiceFocusUncheckedCreateNestedManyWithoutUserInput
    mentee_languages_ref?: MenteeLanguageRefUncheckedCreateNestedManyWithoutUserInput
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedCreateNestedManyWithoutUserInput
    mentee_preferences_ref?: MenteePreferenceRefUncheckedCreateNestedManyWithoutUserInput
    mentor_company_membership?: MentorCompanyMembershipUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMentor_skillsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMentor_skillsInput, UserUncheckedCreateWithoutMentor_skillsInput>
  }

  export type UserUpsertWithoutMentor_skillsInput = {
    update: XOR<UserUpdateWithoutMentor_skillsInput, UserUncheckedUpdateWithoutMentor_skillsInput>
    create: XOR<UserCreateWithoutMentor_skillsInput, UserUncheckedCreateWithoutMentor_skillsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMentor_skillsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMentor_skillsInput, UserUncheckedUpdateWithoutMentor_skillsInput>
  }

  export type UserUpdateWithoutMentor_skillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee_profile?: MenteeUpdateOneWithoutUserNestedInput
    mentor_profile?: MentorUpdateOneWithoutUserNestedInput
    user_consent?: UserConsentUpdateOneWithoutUserNestedInput
    mentee_languages?: MenteeLanguageUpdateManyWithoutUserNestedInput
    mentee_interests?: MenteeInterestUpdateManyWithoutUserNestedInput
    mentee_priorities?: MenteePriorityUpdateManyWithoutUserNestedInput
    mentor_languages?: MentorLanguageUpdateManyWithoutUserNestedInput
    mentor_categories?: MentorCategoryUpdateManyWithoutUserNestedInput
    mentee_service_focus?: MenteeServiceFocusUpdateManyWithoutUserNestedInput
    mentee_languages_ref?: MenteeLanguageRefUpdateManyWithoutUserNestedInput
    mentee_disciplines_ref?: MenteeDisciplineRefUpdateManyWithoutUserNestedInput
    mentee_preferences_ref?: MenteePreferenceRefUpdateManyWithoutUserNestedInput
    mentor_company_membership?: MentorCompanyMembershipUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMentor_skillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee_profile?: MenteeUncheckedUpdateOneWithoutUserNestedInput
    mentor_profile?: MentorUncheckedUpdateOneWithoutUserNestedInput
    user_consent?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    mentee_languages?: MenteeLanguageUncheckedUpdateManyWithoutUserNestedInput
    mentee_interests?: MenteeInterestUncheckedUpdateManyWithoutUserNestedInput
    mentee_priorities?: MenteePriorityUncheckedUpdateManyWithoutUserNestedInput
    mentor_languages?: MentorLanguageUncheckedUpdateManyWithoutUserNestedInput
    mentor_categories?: MentorCategoryUncheckedUpdateManyWithoutUserNestedInput
    mentee_service_focus?: MenteeServiceFocusUncheckedUpdateManyWithoutUserNestedInput
    mentee_languages_ref?: MenteeLanguageRefUncheckedUpdateManyWithoutUserNestedInput
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedUpdateManyWithoutUserNestedInput
    mentee_preferences_ref?: MenteePreferenceRefUncheckedUpdateManyWithoutUserNestedInput
    mentor_company_membership?: MentorCompanyMembershipUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMentee_service_focusInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentee_profile?: MenteeCreateNestedOneWithoutUserInput
    mentor_profile?: MentorCreateNestedOneWithoutUserInput
    user_consent?: UserConsentCreateNestedOneWithoutUserInput
    mentee_languages?: MenteeLanguageCreateNestedManyWithoutUserInput
    mentee_interests?: MenteeInterestCreateNestedManyWithoutUserInput
    mentee_priorities?: MenteePriorityCreateNestedManyWithoutUserInput
    mentor_languages?: MentorLanguageCreateNestedManyWithoutUserInput
    mentor_categories?: MentorCategoryCreateNestedManyWithoutUserInput
    mentor_skills?: MentorSkillCreateNestedManyWithoutUserInput
    mentee_languages_ref?: MenteeLanguageRefCreateNestedManyWithoutUserInput
    mentee_disciplines_ref?: MenteeDisciplineRefCreateNestedManyWithoutUserInput
    mentee_preferences_ref?: MenteePreferenceRefCreateNestedManyWithoutUserInput
    mentor_company_membership?: MentorCompanyMembershipCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMentee_service_focusInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentee_profile?: MenteeUncheckedCreateNestedOneWithoutUserInput
    mentor_profile?: MentorUncheckedCreateNestedOneWithoutUserInput
    user_consent?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    mentee_languages?: MenteeLanguageUncheckedCreateNestedManyWithoutUserInput
    mentee_interests?: MenteeInterestUncheckedCreateNestedManyWithoutUserInput
    mentee_priorities?: MenteePriorityUncheckedCreateNestedManyWithoutUserInput
    mentor_languages?: MentorLanguageUncheckedCreateNestedManyWithoutUserInput
    mentor_categories?: MentorCategoryUncheckedCreateNestedManyWithoutUserInput
    mentor_skills?: MentorSkillUncheckedCreateNestedManyWithoutUserInput
    mentee_languages_ref?: MenteeLanguageRefUncheckedCreateNestedManyWithoutUserInput
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedCreateNestedManyWithoutUserInput
    mentee_preferences_ref?: MenteePreferenceRefUncheckedCreateNestedManyWithoutUserInput
    mentor_company_membership?: MentorCompanyMembershipUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMentee_service_focusInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMentee_service_focusInput, UserUncheckedCreateWithoutMentee_service_focusInput>
  }

  export type ServiceFocusRefCreateWithoutMentee_service_focusInput = {
    id: string
    label: string
    active?: boolean
    sort_order?: number
  }

  export type ServiceFocusRefUncheckedCreateWithoutMentee_service_focusInput = {
    id: string
    label: string
    active?: boolean
    sort_order?: number
  }

  export type ServiceFocusRefCreateOrConnectWithoutMentee_service_focusInput = {
    where: ServiceFocusRefWhereUniqueInput
    create: XOR<ServiceFocusRefCreateWithoutMentee_service_focusInput, ServiceFocusRefUncheckedCreateWithoutMentee_service_focusInput>
  }

  export type UserUpsertWithoutMentee_service_focusInput = {
    update: XOR<UserUpdateWithoutMentee_service_focusInput, UserUncheckedUpdateWithoutMentee_service_focusInput>
    create: XOR<UserCreateWithoutMentee_service_focusInput, UserUncheckedCreateWithoutMentee_service_focusInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMentee_service_focusInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMentee_service_focusInput, UserUncheckedUpdateWithoutMentee_service_focusInput>
  }

  export type UserUpdateWithoutMentee_service_focusInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee_profile?: MenteeUpdateOneWithoutUserNestedInput
    mentor_profile?: MentorUpdateOneWithoutUserNestedInput
    user_consent?: UserConsentUpdateOneWithoutUserNestedInput
    mentee_languages?: MenteeLanguageUpdateManyWithoutUserNestedInput
    mentee_interests?: MenteeInterestUpdateManyWithoutUserNestedInput
    mentee_priorities?: MenteePriorityUpdateManyWithoutUserNestedInput
    mentor_languages?: MentorLanguageUpdateManyWithoutUserNestedInput
    mentor_categories?: MentorCategoryUpdateManyWithoutUserNestedInput
    mentor_skills?: MentorSkillUpdateManyWithoutUserNestedInput
    mentee_languages_ref?: MenteeLanguageRefUpdateManyWithoutUserNestedInput
    mentee_disciplines_ref?: MenteeDisciplineRefUpdateManyWithoutUserNestedInput
    mentee_preferences_ref?: MenteePreferenceRefUpdateManyWithoutUserNestedInput
    mentor_company_membership?: MentorCompanyMembershipUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMentee_service_focusInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee_profile?: MenteeUncheckedUpdateOneWithoutUserNestedInput
    mentor_profile?: MentorUncheckedUpdateOneWithoutUserNestedInput
    user_consent?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    mentee_languages?: MenteeLanguageUncheckedUpdateManyWithoutUserNestedInput
    mentee_interests?: MenteeInterestUncheckedUpdateManyWithoutUserNestedInput
    mentee_priorities?: MenteePriorityUncheckedUpdateManyWithoutUserNestedInput
    mentor_languages?: MentorLanguageUncheckedUpdateManyWithoutUserNestedInput
    mentor_categories?: MentorCategoryUncheckedUpdateManyWithoutUserNestedInput
    mentor_skills?: MentorSkillUncheckedUpdateManyWithoutUserNestedInput
    mentee_languages_ref?: MenteeLanguageRefUncheckedUpdateManyWithoutUserNestedInput
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedUpdateManyWithoutUserNestedInput
    mentee_preferences_ref?: MenteePreferenceRefUncheckedUpdateManyWithoutUserNestedInput
    mentor_company_membership?: MentorCompanyMembershipUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ServiceFocusRefUpsertWithoutMentee_service_focusInput = {
    update: XOR<ServiceFocusRefUpdateWithoutMentee_service_focusInput, ServiceFocusRefUncheckedUpdateWithoutMentee_service_focusInput>
    create: XOR<ServiceFocusRefCreateWithoutMentee_service_focusInput, ServiceFocusRefUncheckedCreateWithoutMentee_service_focusInput>
    where?: ServiceFocusRefWhereInput
  }

  export type ServiceFocusRefUpdateToOneWithWhereWithoutMentee_service_focusInput = {
    where?: ServiceFocusRefWhereInput
    data: XOR<ServiceFocusRefUpdateWithoutMentee_service_focusInput, ServiceFocusRefUncheckedUpdateWithoutMentee_service_focusInput>
  }

  export type ServiceFocusRefUpdateWithoutMentee_service_focusInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type ServiceFocusRefUncheckedUpdateWithoutMentee_service_focusInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateWithoutMentee_languages_refInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentee_profile?: MenteeCreateNestedOneWithoutUserInput
    mentor_profile?: MentorCreateNestedOneWithoutUserInput
    user_consent?: UserConsentCreateNestedOneWithoutUserInput
    mentee_languages?: MenteeLanguageCreateNestedManyWithoutUserInput
    mentee_interests?: MenteeInterestCreateNestedManyWithoutUserInput
    mentee_priorities?: MenteePriorityCreateNestedManyWithoutUserInput
    mentor_languages?: MentorLanguageCreateNestedManyWithoutUserInput
    mentor_categories?: MentorCategoryCreateNestedManyWithoutUserInput
    mentor_skills?: MentorSkillCreateNestedManyWithoutUserInput
    mentee_service_focus?: MenteeServiceFocusCreateNestedManyWithoutUserInput
    mentee_disciplines_ref?: MenteeDisciplineRefCreateNestedManyWithoutUserInput
    mentee_preferences_ref?: MenteePreferenceRefCreateNestedManyWithoutUserInput
    mentor_company_membership?: MentorCompanyMembershipCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMentee_languages_refInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentee_profile?: MenteeUncheckedCreateNestedOneWithoutUserInput
    mentor_profile?: MentorUncheckedCreateNestedOneWithoutUserInput
    user_consent?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    mentee_languages?: MenteeLanguageUncheckedCreateNestedManyWithoutUserInput
    mentee_interests?: MenteeInterestUncheckedCreateNestedManyWithoutUserInput
    mentee_priorities?: MenteePriorityUncheckedCreateNestedManyWithoutUserInput
    mentor_languages?: MentorLanguageUncheckedCreateNestedManyWithoutUserInput
    mentor_categories?: MentorCategoryUncheckedCreateNestedManyWithoutUserInput
    mentor_skills?: MentorSkillUncheckedCreateNestedManyWithoutUserInput
    mentee_service_focus?: MenteeServiceFocusUncheckedCreateNestedManyWithoutUserInput
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedCreateNestedManyWithoutUserInput
    mentee_preferences_ref?: MenteePreferenceRefUncheckedCreateNestedManyWithoutUserInput
    mentor_company_membership?: MentorCompanyMembershipUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMentee_languages_refInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMentee_languages_refInput, UserUncheckedCreateWithoutMentee_languages_refInput>
  }

  export type LanguageRefCreateWithoutMentee_languages_refInput = {
    id: string
    label: string
    active?: boolean
    sort_order?: number
  }

  export type LanguageRefUncheckedCreateWithoutMentee_languages_refInput = {
    id: string
    label: string
    active?: boolean
    sort_order?: number
  }

  export type LanguageRefCreateOrConnectWithoutMentee_languages_refInput = {
    where: LanguageRefWhereUniqueInput
    create: XOR<LanguageRefCreateWithoutMentee_languages_refInput, LanguageRefUncheckedCreateWithoutMentee_languages_refInput>
  }

  export type UserUpsertWithoutMentee_languages_refInput = {
    update: XOR<UserUpdateWithoutMentee_languages_refInput, UserUncheckedUpdateWithoutMentee_languages_refInput>
    create: XOR<UserCreateWithoutMentee_languages_refInput, UserUncheckedCreateWithoutMentee_languages_refInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMentee_languages_refInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMentee_languages_refInput, UserUncheckedUpdateWithoutMentee_languages_refInput>
  }

  export type UserUpdateWithoutMentee_languages_refInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee_profile?: MenteeUpdateOneWithoutUserNestedInput
    mentor_profile?: MentorUpdateOneWithoutUserNestedInput
    user_consent?: UserConsentUpdateOneWithoutUserNestedInput
    mentee_languages?: MenteeLanguageUpdateManyWithoutUserNestedInput
    mentee_interests?: MenteeInterestUpdateManyWithoutUserNestedInput
    mentee_priorities?: MenteePriorityUpdateManyWithoutUserNestedInput
    mentor_languages?: MentorLanguageUpdateManyWithoutUserNestedInput
    mentor_categories?: MentorCategoryUpdateManyWithoutUserNestedInput
    mentor_skills?: MentorSkillUpdateManyWithoutUserNestedInput
    mentee_service_focus?: MenteeServiceFocusUpdateManyWithoutUserNestedInput
    mentee_disciplines_ref?: MenteeDisciplineRefUpdateManyWithoutUserNestedInput
    mentee_preferences_ref?: MenteePreferenceRefUpdateManyWithoutUserNestedInput
    mentor_company_membership?: MentorCompanyMembershipUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMentee_languages_refInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee_profile?: MenteeUncheckedUpdateOneWithoutUserNestedInput
    mentor_profile?: MentorUncheckedUpdateOneWithoutUserNestedInput
    user_consent?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    mentee_languages?: MenteeLanguageUncheckedUpdateManyWithoutUserNestedInput
    mentee_interests?: MenteeInterestUncheckedUpdateManyWithoutUserNestedInput
    mentee_priorities?: MenteePriorityUncheckedUpdateManyWithoutUserNestedInput
    mentor_languages?: MentorLanguageUncheckedUpdateManyWithoutUserNestedInput
    mentor_categories?: MentorCategoryUncheckedUpdateManyWithoutUserNestedInput
    mentor_skills?: MentorSkillUncheckedUpdateManyWithoutUserNestedInput
    mentee_service_focus?: MenteeServiceFocusUncheckedUpdateManyWithoutUserNestedInput
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedUpdateManyWithoutUserNestedInput
    mentee_preferences_ref?: MenteePreferenceRefUncheckedUpdateManyWithoutUserNestedInput
    mentor_company_membership?: MentorCompanyMembershipUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LanguageRefUpsertWithoutMentee_languages_refInput = {
    update: XOR<LanguageRefUpdateWithoutMentee_languages_refInput, LanguageRefUncheckedUpdateWithoutMentee_languages_refInput>
    create: XOR<LanguageRefCreateWithoutMentee_languages_refInput, LanguageRefUncheckedCreateWithoutMentee_languages_refInput>
    where?: LanguageRefWhereInput
  }

  export type LanguageRefUpdateToOneWithWhereWithoutMentee_languages_refInput = {
    where?: LanguageRefWhereInput
    data: XOR<LanguageRefUpdateWithoutMentee_languages_refInput, LanguageRefUncheckedUpdateWithoutMentee_languages_refInput>
  }

  export type LanguageRefUpdateWithoutMentee_languages_refInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type LanguageRefUncheckedUpdateWithoutMentee_languages_refInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateWithoutMentee_disciplines_refInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentee_profile?: MenteeCreateNestedOneWithoutUserInput
    mentor_profile?: MentorCreateNestedOneWithoutUserInput
    user_consent?: UserConsentCreateNestedOneWithoutUserInput
    mentee_languages?: MenteeLanguageCreateNestedManyWithoutUserInput
    mentee_interests?: MenteeInterestCreateNestedManyWithoutUserInput
    mentee_priorities?: MenteePriorityCreateNestedManyWithoutUserInput
    mentor_languages?: MentorLanguageCreateNestedManyWithoutUserInput
    mentor_categories?: MentorCategoryCreateNestedManyWithoutUserInput
    mentor_skills?: MentorSkillCreateNestedManyWithoutUserInput
    mentee_service_focus?: MenteeServiceFocusCreateNestedManyWithoutUserInput
    mentee_languages_ref?: MenteeLanguageRefCreateNestedManyWithoutUserInput
    mentee_preferences_ref?: MenteePreferenceRefCreateNestedManyWithoutUserInput
    mentor_company_membership?: MentorCompanyMembershipCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMentee_disciplines_refInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentee_profile?: MenteeUncheckedCreateNestedOneWithoutUserInput
    mentor_profile?: MentorUncheckedCreateNestedOneWithoutUserInput
    user_consent?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    mentee_languages?: MenteeLanguageUncheckedCreateNestedManyWithoutUserInput
    mentee_interests?: MenteeInterestUncheckedCreateNestedManyWithoutUserInput
    mentee_priorities?: MenteePriorityUncheckedCreateNestedManyWithoutUserInput
    mentor_languages?: MentorLanguageUncheckedCreateNestedManyWithoutUserInput
    mentor_categories?: MentorCategoryUncheckedCreateNestedManyWithoutUserInput
    mentor_skills?: MentorSkillUncheckedCreateNestedManyWithoutUserInput
    mentee_service_focus?: MenteeServiceFocusUncheckedCreateNestedManyWithoutUserInput
    mentee_languages_ref?: MenteeLanguageRefUncheckedCreateNestedManyWithoutUserInput
    mentee_preferences_ref?: MenteePreferenceRefUncheckedCreateNestedManyWithoutUserInput
    mentor_company_membership?: MentorCompanyMembershipUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMentee_disciplines_refInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMentee_disciplines_refInput, UserUncheckedCreateWithoutMentee_disciplines_refInput>
  }

  export type DisciplineRefCreateWithoutMentee_disciplines_refInput = {
    id: string
    label: string
    active?: boolean
    sort_order?: number
  }

  export type DisciplineRefUncheckedCreateWithoutMentee_disciplines_refInput = {
    id: string
    label: string
    active?: boolean
    sort_order?: number
  }

  export type DisciplineRefCreateOrConnectWithoutMentee_disciplines_refInput = {
    where: DisciplineRefWhereUniqueInput
    create: XOR<DisciplineRefCreateWithoutMentee_disciplines_refInput, DisciplineRefUncheckedCreateWithoutMentee_disciplines_refInput>
  }

  export type UserUpsertWithoutMentee_disciplines_refInput = {
    update: XOR<UserUpdateWithoutMentee_disciplines_refInput, UserUncheckedUpdateWithoutMentee_disciplines_refInput>
    create: XOR<UserCreateWithoutMentee_disciplines_refInput, UserUncheckedCreateWithoutMentee_disciplines_refInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMentee_disciplines_refInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMentee_disciplines_refInput, UserUncheckedUpdateWithoutMentee_disciplines_refInput>
  }

  export type UserUpdateWithoutMentee_disciplines_refInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee_profile?: MenteeUpdateOneWithoutUserNestedInput
    mentor_profile?: MentorUpdateOneWithoutUserNestedInput
    user_consent?: UserConsentUpdateOneWithoutUserNestedInput
    mentee_languages?: MenteeLanguageUpdateManyWithoutUserNestedInput
    mentee_interests?: MenteeInterestUpdateManyWithoutUserNestedInput
    mentee_priorities?: MenteePriorityUpdateManyWithoutUserNestedInput
    mentor_languages?: MentorLanguageUpdateManyWithoutUserNestedInput
    mentor_categories?: MentorCategoryUpdateManyWithoutUserNestedInput
    mentor_skills?: MentorSkillUpdateManyWithoutUserNestedInput
    mentee_service_focus?: MenteeServiceFocusUpdateManyWithoutUserNestedInput
    mentee_languages_ref?: MenteeLanguageRefUpdateManyWithoutUserNestedInput
    mentee_preferences_ref?: MenteePreferenceRefUpdateManyWithoutUserNestedInput
    mentor_company_membership?: MentorCompanyMembershipUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMentee_disciplines_refInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee_profile?: MenteeUncheckedUpdateOneWithoutUserNestedInput
    mentor_profile?: MentorUncheckedUpdateOneWithoutUserNestedInput
    user_consent?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    mentee_languages?: MenteeLanguageUncheckedUpdateManyWithoutUserNestedInput
    mentee_interests?: MenteeInterestUncheckedUpdateManyWithoutUserNestedInput
    mentee_priorities?: MenteePriorityUncheckedUpdateManyWithoutUserNestedInput
    mentor_languages?: MentorLanguageUncheckedUpdateManyWithoutUserNestedInput
    mentor_categories?: MentorCategoryUncheckedUpdateManyWithoutUserNestedInput
    mentor_skills?: MentorSkillUncheckedUpdateManyWithoutUserNestedInput
    mentee_service_focus?: MenteeServiceFocusUncheckedUpdateManyWithoutUserNestedInput
    mentee_languages_ref?: MenteeLanguageRefUncheckedUpdateManyWithoutUserNestedInput
    mentee_preferences_ref?: MenteePreferenceRefUncheckedUpdateManyWithoutUserNestedInput
    mentor_company_membership?: MentorCompanyMembershipUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DisciplineRefUpsertWithoutMentee_disciplines_refInput = {
    update: XOR<DisciplineRefUpdateWithoutMentee_disciplines_refInput, DisciplineRefUncheckedUpdateWithoutMentee_disciplines_refInput>
    create: XOR<DisciplineRefCreateWithoutMentee_disciplines_refInput, DisciplineRefUncheckedCreateWithoutMentee_disciplines_refInput>
    where?: DisciplineRefWhereInput
  }

  export type DisciplineRefUpdateToOneWithWhereWithoutMentee_disciplines_refInput = {
    where?: DisciplineRefWhereInput
    data: XOR<DisciplineRefUpdateWithoutMentee_disciplines_refInput, DisciplineRefUncheckedUpdateWithoutMentee_disciplines_refInput>
  }

  export type DisciplineRefUpdateWithoutMentee_disciplines_refInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type DisciplineRefUncheckedUpdateWithoutMentee_disciplines_refInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateWithoutMentee_preferences_refInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentee_profile?: MenteeCreateNestedOneWithoutUserInput
    mentor_profile?: MentorCreateNestedOneWithoutUserInput
    user_consent?: UserConsentCreateNestedOneWithoutUserInput
    mentee_languages?: MenteeLanguageCreateNestedManyWithoutUserInput
    mentee_interests?: MenteeInterestCreateNestedManyWithoutUserInput
    mentee_priorities?: MenteePriorityCreateNestedManyWithoutUserInput
    mentor_languages?: MentorLanguageCreateNestedManyWithoutUserInput
    mentor_categories?: MentorCategoryCreateNestedManyWithoutUserInput
    mentor_skills?: MentorSkillCreateNestedManyWithoutUserInput
    mentee_service_focus?: MenteeServiceFocusCreateNestedManyWithoutUserInput
    mentee_languages_ref?: MenteeLanguageRefCreateNestedManyWithoutUserInput
    mentee_disciplines_ref?: MenteeDisciplineRefCreateNestedManyWithoutUserInput
    mentor_company_membership?: MentorCompanyMembershipCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMentee_preferences_refInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentee_profile?: MenteeUncheckedCreateNestedOneWithoutUserInput
    mentor_profile?: MentorUncheckedCreateNestedOneWithoutUserInput
    user_consent?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    mentee_languages?: MenteeLanguageUncheckedCreateNestedManyWithoutUserInput
    mentee_interests?: MenteeInterestUncheckedCreateNestedManyWithoutUserInput
    mentee_priorities?: MenteePriorityUncheckedCreateNestedManyWithoutUserInput
    mentor_languages?: MentorLanguageUncheckedCreateNestedManyWithoutUserInput
    mentor_categories?: MentorCategoryUncheckedCreateNestedManyWithoutUserInput
    mentor_skills?: MentorSkillUncheckedCreateNestedManyWithoutUserInput
    mentee_service_focus?: MenteeServiceFocusUncheckedCreateNestedManyWithoutUserInput
    mentee_languages_ref?: MenteeLanguageRefUncheckedCreateNestedManyWithoutUserInput
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedCreateNestedManyWithoutUserInput
    mentor_company_membership?: MentorCompanyMembershipUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMentee_preferences_refInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMentee_preferences_refInput, UserUncheckedCreateWithoutMentee_preferences_refInput>
  }

  export type PreferenceRefCreateWithoutMentee_preferences_refInput = {
    id: string
    label: string
    active?: boolean
    sort_order?: number
  }

  export type PreferenceRefUncheckedCreateWithoutMentee_preferences_refInput = {
    id: string
    label: string
    active?: boolean
    sort_order?: number
  }

  export type PreferenceRefCreateOrConnectWithoutMentee_preferences_refInput = {
    where: PreferenceRefWhereUniqueInput
    create: XOR<PreferenceRefCreateWithoutMentee_preferences_refInput, PreferenceRefUncheckedCreateWithoutMentee_preferences_refInput>
  }

  export type UserUpsertWithoutMentee_preferences_refInput = {
    update: XOR<UserUpdateWithoutMentee_preferences_refInput, UserUncheckedUpdateWithoutMentee_preferences_refInput>
    create: XOR<UserCreateWithoutMentee_preferences_refInput, UserUncheckedCreateWithoutMentee_preferences_refInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMentee_preferences_refInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMentee_preferences_refInput, UserUncheckedUpdateWithoutMentee_preferences_refInput>
  }

  export type UserUpdateWithoutMentee_preferences_refInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee_profile?: MenteeUpdateOneWithoutUserNestedInput
    mentor_profile?: MentorUpdateOneWithoutUserNestedInput
    user_consent?: UserConsentUpdateOneWithoutUserNestedInput
    mentee_languages?: MenteeLanguageUpdateManyWithoutUserNestedInput
    mentee_interests?: MenteeInterestUpdateManyWithoutUserNestedInput
    mentee_priorities?: MenteePriorityUpdateManyWithoutUserNestedInput
    mentor_languages?: MentorLanguageUpdateManyWithoutUserNestedInput
    mentor_categories?: MentorCategoryUpdateManyWithoutUserNestedInput
    mentor_skills?: MentorSkillUpdateManyWithoutUserNestedInput
    mentee_service_focus?: MenteeServiceFocusUpdateManyWithoutUserNestedInput
    mentee_languages_ref?: MenteeLanguageRefUpdateManyWithoutUserNestedInput
    mentee_disciplines_ref?: MenteeDisciplineRefUpdateManyWithoutUserNestedInput
    mentor_company_membership?: MentorCompanyMembershipUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMentee_preferences_refInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee_profile?: MenteeUncheckedUpdateOneWithoutUserNestedInput
    mentor_profile?: MentorUncheckedUpdateOneWithoutUserNestedInput
    user_consent?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    mentee_languages?: MenteeLanguageUncheckedUpdateManyWithoutUserNestedInput
    mentee_interests?: MenteeInterestUncheckedUpdateManyWithoutUserNestedInput
    mentee_priorities?: MenteePriorityUncheckedUpdateManyWithoutUserNestedInput
    mentor_languages?: MentorLanguageUncheckedUpdateManyWithoutUserNestedInput
    mentor_categories?: MentorCategoryUncheckedUpdateManyWithoutUserNestedInput
    mentor_skills?: MentorSkillUncheckedUpdateManyWithoutUserNestedInput
    mentee_service_focus?: MenteeServiceFocusUncheckedUpdateManyWithoutUserNestedInput
    mentee_languages_ref?: MenteeLanguageRefUncheckedUpdateManyWithoutUserNestedInput
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedUpdateManyWithoutUserNestedInput
    mentor_company_membership?: MentorCompanyMembershipUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PreferenceRefUpsertWithoutMentee_preferences_refInput = {
    update: XOR<PreferenceRefUpdateWithoutMentee_preferences_refInput, PreferenceRefUncheckedUpdateWithoutMentee_preferences_refInput>
    create: XOR<PreferenceRefCreateWithoutMentee_preferences_refInput, PreferenceRefUncheckedCreateWithoutMentee_preferences_refInput>
    where?: PreferenceRefWhereInput
  }

  export type PreferenceRefUpdateToOneWithWhereWithoutMentee_preferences_refInput = {
    where?: PreferenceRefWhereInput
    data: XOR<PreferenceRefUpdateWithoutMentee_preferences_refInput, PreferenceRefUncheckedUpdateWithoutMentee_preferences_refInput>
  }

  export type PreferenceRefUpdateWithoutMentee_preferences_refInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type PreferenceRefUncheckedUpdateWithoutMentee_preferences_refInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type MentorCompanyMembershipCreateWithoutCompanyInput = {
    role_title?: string | null
    work_email?: string | null
    created_at?: Date | string
    user: UserCreateNestedOneWithoutMentor_company_membershipInput
  }

  export type MentorCompanyMembershipUncheckedCreateWithoutCompanyInput = {
    mentor_id: string
    role_title?: string | null
    work_email?: string | null
    created_at?: Date | string
  }

  export type MentorCompanyMembershipCreateOrConnectWithoutCompanyInput = {
    where: MentorCompanyMembershipWhereUniqueInput
    create: XOR<MentorCompanyMembershipCreateWithoutCompanyInput, MentorCompanyMembershipUncheckedCreateWithoutCompanyInput>
  }

  export type MentorCompanyMembershipCreateManyCompanyInputEnvelope = {
    data: MentorCompanyMembershipCreateManyCompanyInput | MentorCompanyMembershipCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type MentorCompanyMembershipUpsertWithWhereUniqueWithoutCompanyInput = {
    where: MentorCompanyMembershipWhereUniqueInput
    update: XOR<MentorCompanyMembershipUpdateWithoutCompanyInput, MentorCompanyMembershipUncheckedUpdateWithoutCompanyInput>
    create: XOR<MentorCompanyMembershipCreateWithoutCompanyInput, MentorCompanyMembershipUncheckedCreateWithoutCompanyInput>
  }

  export type MentorCompanyMembershipUpdateWithWhereUniqueWithoutCompanyInput = {
    where: MentorCompanyMembershipWhereUniqueInput
    data: XOR<MentorCompanyMembershipUpdateWithoutCompanyInput, MentorCompanyMembershipUncheckedUpdateWithoutCompanyInput>
  }

  export type MentorCompanyMembershipUpdateManyWithWhereWithoutCompanyInput = {
    where: MentorCompanyMembershipScalarWhereInput
    data: XOR<MentorCompanyMembershipUpdateManyMutationInput, MentorCompanyMembershipUncheckedUpdateManyWithoutCompanyInput>
  }

  export type UserCreateWithoutMentor_company_membershipInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentee_profile?: MenteeCreateNestedOneWithoutUserInput
    mentor_profile?: MentorCreateNestedOneWithoutUserInput
    user_consent?: UserConsentCreateNestedOneWithoutUserInput
    mentee_languages?: MenteeLanguageCreateNestedManyWithoutUserInput
    mentee_interests?: MenteeInterestCreateNestedManyWithoutUserInput
    mentee_priorities?: MenteePriorityCreateNestedManyWithoutUserInput
    mentor_languages?: MentorLanguageCreateNestedManyWithoutUserInput
    mentor_categories?: MentorCategoryCreateNestedManyWithoutUserInput
    mentor_skills?: MentorSkillCreateNestedManyWithoutUserInput
    mentee_service_focus?: MenteeServiceFocusCreateNestedManyWithoutUserInput
    mentee_languages_ref?: MenteeLanguageRefCreateNestedManyWithoutUserInput
    mentee_disciplines_ref?: MenteeDisciplineRefCreateNestedManyWithoutUserInput
    mentee_preferences_ref?: MenteePreferenceRefCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMentor_company_membershipInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentee_profile?: MenteeUncheckedCreateNestedOneWithoutUserInput
    mentor_profile?: MentorUncheckedCreateNestedOneWithoutUserInput
    user_consent?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    mentee_languages?: MenteeLanguageUncheckedCreateNestedManyWithoutUserInput
    mentee_interests?: MenteeInterestUncheckedCreateNestedManyWithoutUserInput
    mentee_priorities?: MenteePriorityUncheckedCreateNestedManyWithoutUserInput
    mentor_languages?: MentorLanguageUncheckedCreateNestedManyWithoutUserInput
    mentor_categories?: MentorCategoryUncheckedCreateNestedManyWithoutUserInput
    mentor_skills?: MentorSkillUncheckedCreateNestedManyWithoutUserInput
    mentee_service_focus?: MenteeServiceFocusUncheckedCreateNestedManyWithoutUserInput
    mentee_languages_ref?: MenteeLanguageRefUncheckedCreateNestedManyWithoutUserInput
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedCreateNestedManyWithoutUserInput
    mentee_preferences_ref?: MenteePreferenceRefUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMentor_company_membershipInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMentor_company_membershipInput, UserUncheckedCreateWithoutMentor_company_membershipInput>
  }

  export type CompanyCreateWithoutMentor_company_membershipInput = {
    id?: string
    name: string
    website?: string | null
    tax_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CompanyUncheckedCreateWithoutMentor_company_membershipInput = {
    id?: string
    name: string
    website?: string | null
    tax_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CompanyCreateOrConnectWithoutMentor_company_membershipInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutMentor_company_membershipInput, CompanyUncheckedCreateWithoutMentor_company_membershipInput>
  }

  export type UserUpsertWithoutMentor_company_membershipInput = {
    update: XOR<UserUpdateWithoutMentor_company_membershipInput, UserUncheckedUpdateWithoutMentor_company_membershipInput>
    create: XOR<UserCreateWithoutMentor_company_membershipInput, UserUncheckedCreateWithoutMentor_company_membershipInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMentor_company_membershipInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMentor_company_membershipInput, UserUncheckedUpdateWithoutMentor_company_membershipInput>
  }

  export type UserUpdateWithoutMentor_company_membershipInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee_profile?: MenteeUpdateOneWithoutUserNestedInput
    mentor_profile?: MentorUpdateOneWithoutUserNestedInput
    user_consent?: UserConsentUpdateOneWithoutUserNestedInput
    mentee_languages?: MenteeLanguageUpdateManyWithoutUserNestedInput
    mentee_interests?: MenteeInterestUpdateManyWithoutUserNestedInput
    mentee_priorities?: MenteePriorityUpdateManyWithoutUserNestedInput
    mentor_languages?: MentorLanguageUpdateManyWithoutUserNestedInput
    mentor_categories?: MentorCategoryUpdateManyWithoutUserNestedInput
    mentor_skills?: MentorSkillUpdateManyWithoutUserNestedInput
    mentee_service_focus?: MenteeServiceFocusUpdateManyWithoutUserNestedInput
    mentee_languages_ref?: MenteeLanguageRefUpdateManyWithoutUserNestedInput
    mentee_disciplines_ref?: MenteeDisciplineRefUpdateManyWithoutUserNestedInput
    mentee_preferences_ref?: MenteePreferenceRefUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMentor_company_membershipInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee_profile?: MenteeUncheckedUpdateOneWithoutUserNestedInput
    mentor_profile?: MentorUncheckedUpdateOneWithoutUserNestedInput
    user_consent?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    mentee_languages?: MenteeLanguageUncheckedUpdateManyWithoutUserNestedInput
    mentee_interests?: MenteeInterestUncheckedUpdateManyWithoutUserNestedInput
    mentee_priorities?: MenteePriorityUncheckedUpdateManyWithoutUserNestedInput
    mentor_languages?: MentorLanguageUncheckedUpdateManyWithoutUserNestedInput
    mentor_categories?: MentorCategoryUncheckedUpdateManyWithoutUserNestedInput
    mentor_skills?: MentorSkillUncheckedUpdateManyWithoutUserNestedInput
    mentee_service_focus?: MenteeServiceFocusUncheckedUpdateManyWithoutUserNestedInput
    mentee_languages_ref?: MenteeLanguageRefUncheckedUpdateManyWithoutUserNestedInput
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedUpdateManyWithoutUserNestedInput
    mentee_preferences_ref?: MenteePreferenceRefUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyUpsertWithoutMentor_company_membershipInput = {
    update: XOR<CompanyUpdateWithoutMentor_company_membershipInput, CompanyUncheckedUpdateWithoutMentor_company_membershipInput>
    create: XOR<CompanyCreateWithoutMentor_company_membershipInput, CompanyUncheckedCreateWithoutMentor_company_membershipInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutMentor_company_membershipInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutMentor_company_membershipInput, CompanyUncheckedUpdateWithoutMentor_company_membershipInput>
  }

  export type CompanyUpdateWithoutMentor_company_membershipInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateWithoutMentor_company_membershipInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutUser_consentInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentee_profile?: MenteeCreateNestedOneWithoutUserInput
    mentor_profile?: MentorCreateNestedOneWithoutUserInput
    mentee_languages?: MenteeLanguageCreateNestedManyWithoutUserInput
    mentee_interests?: MenteeInterestCreateNestedManyWithoutUserInput
    mentee_priorities?: MenteePriorityCreateNestedManyWithoutUserInput
    mentor_languages?: MentorLanguageCreateNestedManyWithoutUserInput
    mentor_categories?: MentorCategoryCreateNestedManyWithoutUserInput
    mentor_skills?: MentorSkillCreateNestedManyWithoutUserInput
    mentee_service_focus?: MenteeServiceFocusCreateNestedManyWithoutUserInput
    mentee_languages_ref?: MenteeLanguageRefCreateNestedManyWithoutUserInput
    mentee_disciplines_ref?: MenteeDisciplineRefCreateNestedManyWithoutUserInput
    mentee_preferences_ref?: MenteePreferenceRefCreateNestedManyWithoutUserInput
    mentor_company_membership?: MentorCompanyMembershipCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUser_consentInput = {
    id?: string
    email: string
    full_name: string
    role: $Enums.UserRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    mentee_profile?: MenteeUncheckedCreateNestedOneWithoutUserInput
    mentor_profile?: MentorUncheckedCreateNestedOneWithoutUserInput
    mentee_languages?: MenteeLanguageUncheckedCreateNestedManyWithoutUserInput
    mentee_interests?: MenteeInterestUncheckedCreateNestedManyWithoutUserInput
    mentee_priorities?: MenteePriorityUncheckedCreateNestedManyWithoutUserInput
    mentor_languages?: MentorLanguageUncheckedCreateNestedManyWithoutUserInput
    mentor_categories?: MentorCategoryUncheckedCreateNestedManyWithoutUserInput
    mentor_skills?: MentorSkillUncheckedCreateNestedManyWithoutUserInput
    mentee_service_focus?: MenteeServiceFocusUncheckedCreateNestedManyWithoutUserInput
    mentee_languages_ref?: MenteeLanguageRefUncheckedCreateNestedManyWithoutUserInput
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedCreateNestedManyWithoutUserInput
    mentee_preferences_ref?: MenteePreferenceRefUncheckedCreateNestedManyWithoutUserInput
    mentor_company_membership?: MentorCompanyMembershipUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUser_consentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUser_consentInput, UserUncheckedCreateWithoutUser_consentInput>
  }

  export type UserUpsertWithoutUser_consentInput = {
    update: XOR<UserUpdateWithoutUser_consentInput, UserUncheckedUpdateWithoutUser_consentInput>
    create: XOR<UserCreateWithoutUser_consentInput, UserUncheckedCreateWithoutUser_consentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUser_consentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUser_consentInput, UserUncheckedUpdateWithoutUser_consentInput>
  }

  export type UserUpdateWithoutUser_consentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee_profile?: MenteeUpdateOneWithoutUserNestedInput
    mentor_profile?: MentorUpdateOneWithoutUserNestedInput
    mentee_languages?: MenteeLanguageUpdateManyWithoutUserNestedInput
    mentee_interests?: MenteeInterestUpdateManyWithoutUserNestedInput
    mentee_priorities?: MenteePriorityUpdateManyWithoutUserNestedInput
    mentor_languages?: MentorLanguageUpdateManyWithoutUserNestedInput
    mentor_categories?: MentorCategoryUpdateManyWithoutUserNestedInput
    mentor_skills?: MentorSkillUpdateManyWithoutUserNestedInput
    mentee_service_focus?: MenteeServiceFocusUpdateManyWithoutUserNestedInput
    mentee_languages_ref?: MenteeLanguageRefUpdateManyWithoutUserNestedInput
    mentee_disciplines_ref?: MenteeDisciplineRefUpdateManyWithoutUserNestedInput
    mentee_preferences_ref?: MenteePreferenceRefUpdateManyWithoutUserNestedInput
    mentor_company_membership?: MentorCompanyMembershipUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUser_consentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mentee_profile?: MenteeUncheckedUpdateOneWithoutUserNestedInput
    mentor_profile?: MentorUncheckedUpdateOneWithoutUserNestedInput
    mentee_languages?: MenteeLanguageUncheckedUpdateManyWithoutUserNestedInput
    mentee_interests?: MenteeInterestUncheckedUpdateManyWithoutUserNestedInput
    mentee_priorities?: MenteePriorityUncheckedUpdateManyWithoutUserNestedInput
    mentor_languages?: MentorLanguageUncheckedUpdateManyWithoutUserNestedInput
    mentor_categories?: MentorCategoryUncheckedUpdateManyWithoutUserNestedInput
    mentor_skills?: MentorSkillUncheckedUpdateManyWithoutUserNestedInput
    mentee_service_focus?: MenteeServiceFocusUncheckedUpdateManyWithoutUserNestedInput
    mentee_languages_ref?: MenteeLanguageRefUncheckedUpdateManyWithoutUserNestedInput
    mentee_disciplines_ref?: MenteeDisciplineRefUncheckedUpdateManyWithoutUserNestedInput
    mentee_preferences_ref?: MenteePreferenceRefUncheckedUpdateManyWithoutUserNestedInput
    mentor_company_membership?: MentorCompanyMembershipUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MenteeLanguageCreateManyUserInput = {
    lang_code: string
  }

  export type MenteeInterestCreateManyUserInput = {
    interest: string
    created_at?: Date | string
  }

  export type MenteePriorityCreateManyUserInput = {
    priority: string
    created_at?: Date | string
  }

  export type MentorLanguageCreateManyUserInput = {
    lang_code: string
  }

  export type MentorCategoryCreateManyUserInput = {
    category: string
  }

  export type MentorSkillCreateManyUserInput = {
    skill: string
  }

  export type MenteeServiceFocusCreateManyUserInput = {
    service_focus_id: string
  }

  export type MenteeLanguageRefCreateManyUserInput = {
    language_id: string
  }

  export type MenteeDisciplineRefCreateManyUserInput = {
    discipline_id: string
  }

  export type MenteePreferenceRefCreateManyUserInput = {
    preference_id: string
  }

  export type MentorCompanyMembershipCreateManyUserInput = {
    company_id: string
    role_title?: string | null
    work_email?: string | null
    created_at?: Date | string
  }

  export type MenteeLanguageUpdateWithoutUserInput = {
    lang_code?: StringFieldUpdateOperationsInput | string
  }

  export type MenteeLanguageUncheckedUpdateWithoutUserInput = {
    lang_code?: StringFieldUpdateOperationsInput | string
  }

  export type MenteeLanguageUncheckedUpdateManyWithoutUserInput = {
    lang_code?: StringFieldUpdateOperationsInput | string
  }

  export type MenteeInterestUpdateWithoutUserInput = {
    interest?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenteeInterestUncheckedUpdateWithoutUserInput = {
    interest?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenteeInterestUncheckedUpdateManyWithoutUserInput = {
    interest?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenteePriorityUpdateWithoutUserInput = {
    priority?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenteePriorityUncheckedUpdateWithoutUserInput = {
    priority?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenteePriorityUncheckedUpdateManyWithoutUserInput = {
    priority?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentorLanguageUpdateWithoutUserInput = {
    lang_code?: StringFieldUpdateOperationsInput | string
  }

  export type MentorLanguageUncheckedUpdateWithoutUserInput = {
    lang_code?: StringFieldUpdateOperationsInput | string
  }

  export type MentorLanguageUncheckedUpdateManyWithoutUserInput = {
    lang_code?: StringFieldUpdateOperationsInput | string
  }

  export type MentorCategoryUpdateWithoutUserInput = {
    category?: StringFieldUpdateOperationsInput | string
  }

  export type MentorCategoryUncheckedUpdateWithoutUserInput = {
    category?: StringFieldUpdateOperationsInput | string
  }

  export type MentorCategoryUncheckedUpdateManyWithoutUserInput = {
    category?: StringFieldUpdateOperationsInput | string
  }

  export type MentorSkillUpdateWithoutUserInput = {
    skill?: StringFieldUpdateOperationsInput | string
  }

  export type MentorSkillUncheckedUpdateWithoutUserInput = {
    skill?: StringFieldUpdateOperationsInput | string
  }

  export type MentorSkillUncheckedUpdateManyWithoutUserInput = {
    skill?: StringFieldUpdateOperationsInput | string
  }

  export type MenteeServiceFocusUpdateWithoutUserInput = {
    service_focus?: ServiceFocusRefUpdateOneRequiredWithoutMentee_service_focusNestedInput
  }

  export type MenteeServiceFocusUncheckedUpdateWithoutUserInput = {
    service_focus_id?: StringFieldUpdateOperationsInput | string
  }

  export type MenteeServiceFocusUncheckedUpdateManyWithoutUserInput = {
    service_focus_id?: StringFieldUpdateOperationsInput | string
  }

  export type MenteeLanguageRefUpdateWithoutUserInput = {
    language?: LanguageRefUpdateOneRequiredWithoutMentee_languages_refNestedInput
  }

  export type MenteeLanguageRefUncheckedUpdateWithoutUserInput = {
    language_id?: StringFieldUpdateOperationsInput | string
  }

  export type MenteeLanguageRefUncheckedUpdateManyWithoutUserInput = {
    language_id?: StringFieldUpdateOperationsInput | string
  }

  export type MenteeDisciplineRefUpdateWithoutUserInput = {
    discipline?: DisciplineRefUpdateOneRequiredWithoutMentee_disciplines_refNestedInput
  }

  export type MenteeDisciplineRefUncheckedUpdateWithoutUserInput = {
    discipline_id?: StringFieldUpdateOperationsInput | string
  }

  export type MenteeDisciplineRefUncheckedUpdateManyWithoutUserInput = {
    discipline_id?: StringFieldUpdateOperationsInput | string
  }

  export type MenteePreferenceRefUpdateWithoutUserInput = {
    preference?: PreferenceRefUpdateOneRequiredWithoutMentee_preferences_refNestedInput
  }

  export type MenteePreferenceRefUncheckedUpdateWithoutUserInput = {
    preference_id?: StringFieldUpdateOperationsInput | string
  }

  export type MenteePreferenceRefUncheckedUpdateManyWithoutUserInput = {
    preference_id?: StringFieldUpdateOperationsInput | string
  }

  export type MentorCompanyMembershipUpdateWithoutUserInput = {
    role_title?: NullableStringFieldUpdateOperationsInput | string | null
    work_email?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutMentor_company_membershipNestedInput
  }

  export type MentorCompanyMembershipUncheckedUpdateWithoutUserInput = {
    company_id?: StringFieldUpdateOperationsInput | string
    role_title?: NullableStringFieldUpdateOperationsInput | string | null
    work_email?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentorCompanyMembershipUncheckedUpdateManyWithoutUserInput = {
    company_id?: StringFieldUpdateOperationsInput | string
    role_title?: NullableStringFieldUpdateOperationsInput | string | null
    work_email?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenteeServiceFocusCreateManyService_focusInput = {
    user_id: string
  }

  export type MenteeServiceFocusUpdateWithoutService_focusInput = {
    user?: UserUpdateOneRequiredWithoutMentee_service_focusNestedInput
  }

  export type MenteeServiceFocusUncheckedUpdateWithoutService_focusInput = {
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type MenteeServiceFocusUncheckedUpdateManyWithoutService_focusInput = {
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type MenteeLanguageRefCreateManyLanguageInput = {
    user_id: string
  }

  export type MenteeLanguageRefUpdateWithoutLanguageInput = {
    user?: UserUpdateOneRequiredWithoutMentee_languages_refNestedInput
  }

  export type MenteeLanguageRefUncheckedUpdateWithoutLanguageInput = {
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type MenteeLanguageRefUncheckedUpdateManyWithoutLanguageInput = {
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type MenteeDisciplineRefCreateManyDisciplineInput = {
    user_id: string
  }

  export type MenteeDisciplineRefUpdateWithoutDisciplineInput = {
    user?: UserUpdateOneRequiredWithoutMentee_disciplines_refNestedInput
  }

  export type MenteeDisciplineRefUncheckedUpdateWithoutDisciplineInput = {
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type MenteeDisciplineRefUncheckedUpdateManyWithoutDisciplineInput = {
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type MenteePreferenceRefCreateManyPreferenceInput = {
    user_id: string
  }

  export type MenteePreferenceRefUpdateWithoutPreferenceInput = {
    user?: UserUpdateOneRequiredWithoutMentee_preferences_refNestedInput
  }

  export type MenteePreferenceRefUncheckedUpdateWithoutPreferenceInput = {
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type MenteePreferenceRefUncheckedUpdateManyWithoutPreferenceInput = {
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type MentorCompanyMembershipCreateManyCompanyInput = {
    mentor_id: string
    role_title?: string | null
    work_email?: string | null
    created_at?: Date | string
  }

  export type MentorCompanyMembershipUpdateWithoutCompanyInput = {
    role_title?: NullableStringFieldUpdateOperationsInput | string | null
    work_email?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMentor_company_membershipNestedInput
  }

  export type MentorCompanyMembershipUncheckedUpdateWithoutCompanyInput = {
    mentor_id?: StringFieldUpdateOperationsInput | string
    role_title?: NullableStringFieldUpdateOperationsInput | string | null
    work_email?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentorCompanyMembershipUncheckedUpdateManyWithoutCompanyInput = {
    mentor_id?: StringFieldUpdateOperationsInput | string
    role_title?: NullableStringFieldUpdateOperationsInput | string | null
    work_email?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}